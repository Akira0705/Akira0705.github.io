<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Akira</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://akira.wang/"/>
  <updated>2018-10-05T04:16:40.848Z</updated>
  <id>http://akira.wang/</id>
  
  <author>
    <name>Akira</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>推流 &amp;&amp; 直播开发</title>
    <link href="http://akira.wang/%E6%8E%A8%E6%B5%81%20&amp;&amp;%20%E7%9B%B4%E6%92%AD%E5%BC%80%E5%8F%91/"/>
    <id>http://akira.wang/推流 &amp;&amp; 直播开发/</id>
    <published>2018-10-05T04:15:23.231Z</published>
    <updated>2018-10-05T04:16:40.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="直播流程概览图"><a href="#直播流程概览图" class="headerlink" title="直播流程概览图"></a>直播流程概览图</h3><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2018/png/155686/1538539991537-5fb494ea-304f-4825-a574-d0b3aa05fc9b.png" alt="image | left | 827x293"></h2><h2 id="常见直播协议"><a href="#常见直播协议" class="headerlink" title="常见直播协议"></a>常见直播协议</h2><ul><li>HLS</li><li>RTMP</li><li>HTTP-FLV</li></ul><h4 id="常见直播协议延迟与性能数据-以下数据只做对比参考"><a href="#常见直播协议延迟与性能数据-以下数据只做对比参考" class="headerlink" title="常见直播协议延迟与性能数据 ~^以下数据只做对比参考^~"></a>常见直播协议延迟与性能数据 ~^以下数据只做对比参考^~</h4><table><thead><tr><th style="text-align:left">传输协议</th><th style="text-align:left">播放器</th><th style="text-align:left">延迟</th><th style="text-align:left">内存</th><th style="text-align:left">CPU</th></tr></thead><tbody><tr><td style="text-align:left">RTMP</td><td style="text-align:left">Flash</td><td style="text-align:left">1s</td><td style="text-align:left">430M</td><td style="text-align:left">11%</td></tr><tr><td style="text-align:left">HTTP-FLV</td><td style="text-align:left">Video</td><td style="text-align:left">1s</td><td style="text-align:left">310M</td><td style="text-align:left">4.4%</td></tr><tr><td style="text-align:left">HLS</td><td style="text-align:left">Video</td><td style="text-align:left">20s</td><td style="text-align:left">205M</td><td style="text-align:left">3%</td></tr></tbody></table><h2 id="推流"><a href="#推流" class="headerlink" title="推流"></a>推流</h2><h3 id="rtmp服务器"><a href="#rtmp服务器" class="headerlink" title="rtmp服务器"></a>rtmp服务器</h3><p><a href="https://github.com/illuspas/nginx-rtmp-win32" target="_blank" rel="noopener">https://github.com/illuspas/nginx-rtmp-win32</a><br>直接下载以上地址启动服务器，默认rtmp服务是<span data-type="color" style="color:#9254DE">1935</span>端口<br>可看<span data-type="color" style="color:#9254DE">nginx.conf</span>自行配置</p><h3 id="ffmpeg推流命令"><a href="#ffmpeg推流命令" class="headerlink" title="ffmpeg推流命令"></a>ffmpeg推流命令</h3><p><em><span data-type="background" style="background-color:#FFFB8F"><span data-type="color" style="color:#262626">ffmpeg -re -i [视频地址] -vcodec libx264 -acodec aac -f fl<br>v rtmp://[rtmp地址]</span></span></em></p><p>例如：</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/155686/1538587583721-e8ca7d1a-82f6-46b8-b6e8-0d5ef23df213.png" alt="image | left | 616x114"></p><p>在该命令行模式下执行<br><em>ffmpeg -re -i ./siyue.mp4 -vcodec libx264 -acodec aac -f fl<br>v rtmp://127.0.0.1:1935/live/rtmp</em></p><p>推流成功后，如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/155686/1538587792606-65ca1d23-d8dc-4595-9f2d-68b39cbcbc7a.png" alt="image | left | 649x416"><br>会不断的刷这些信息数据</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>可在<span data-type="color" style="color:#9254DE">8080</span>端口进行调试</p><p><img src="https://cdn.nlark.com/yuque/0/2018/png/155686/1538587737505-d9166c38-f600-41b7-bc26-6cd3951e45b6.png" alt="image | left | 827x382"></p><p>在红色框输入rtmp地址，点击play即可</p><h2 id="Web端"><a href="#Web端" class="headerlink" title="Web端"></a>Web端</h2><h3 id="播放器选型"><a href="#播放器选型" class="headerlink" title="播放器选型"></a>播放器选型</h3><ul><li><a href="https://github.com/videojs/video.js" target="_blank" rel="noopener">video.js</a><ul><li>现成的UI播放器</li></ul></li><li><a href="https://github.com/video-dev/hls.js" target="_blank" rel="noopener">hls.js</a></li><li><a href="https://github.com/bilibili/flv.js" target="_blank" rel="noopener">flv.js</a><ul><li>hls和flv都是需要自定义播放器，使用更灵活，更简洁<br>这些库demo官方都有，自个儿看吧 0.0</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2018/png/155686/1538675356930-b1565977-6024-440a-85ef-dea6e349e40c.png" alt="image | left | 300x300"></p><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>确定好库后，就进行业务开发了。什么弹幕，刷礼物，聊天窗口喊666，以后接触到这些业务再细去研究吧。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本来文章名想叫 直播开发，可是感觉主要还是记录一下推流的方法吧。<br>然后有人就说，我一小~~前端干嘛要自己推流噢。<br>嘛嘛，这样前端大大们可以在不依靠后端童鞋的提供接口下也能先自行开发，了解整个直播流程，开发中有问题出错了也能更快速的定位出来~</p><p>最近写文档什么的都在用语雀，恩很好用，就酱。 溜=3</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;直播流程概览图&quot;&gt;&lt;a href=&quot;#直播流程概览图&quot; class=&quot;headerlink&quot; title=&quot;直播流程概览图&quot;&gt;&lt;/a&gt;直播流程概览图&lt;/h3&gt;&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="前端" scheme="http://akira.wang/categories/web/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Re0：从零开始的JavaScript - 可暂停异步任务队列的3种方式</title>
    <link href="http://akira.wang/%E5%AE%9E%E7%8E%B0%E5%8F%AF%E6%9A%82%E5%81%9C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://akira.wang/实现可暂停异步任务队列的3种方式/</id>
    <published>2018-06-24T03:11:25.919Z</published>
    <updated>2018-06-24T03:12:49.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现可暂停异步任务队列的3种方式"><a href="#实现可暂停异步任务队列的3种方式" class="headerlink" title="实现可暂停异步任务队列的3种方式"></a>实现可暂停异步任务队列的3种方式</h1><h3 id="需求：在爬取网页的时候需要同时向多个分页进行爬取，并能够进行爬取中间暂停。"><a href="#需求：在爬取网页的时候需要同时向多个分页进行爬取，并能够进行爬取中间暂停。" class="headerlink" title="需求：在爬取网页的时候需要同时向多个分页进行爬取，并能够进行爬取中间暂停。"></a>需求：在爬取网页的时候需要同时向多个分页进行爬取，并能够进行爬取中间暂停。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">let builder = x =&gt; async () =&gt; Promise.resolve(x);</div><div class="line"></div><div class="line">let tasks = Array.from(&#123; length:1120 &#125;).map((_, k) =&gt; builder(`console.log($&#123;k&#125;)`))</div><div class="line"></div><div class="line">let index = 0;</div><div class="line">let timer;</div><div class="line">let canRun = true;</div><div class="line"></div><div class="line">function run()&#123;</div><div class="line">    index++;</div><div class="line">     timer = setTimeout(async () =&gt; &#123;</div><div class="line">        let funcSource = await tasks[index](index);</div><div class="line">        let func = new Function(funcSource);</div><div class="line">        func()</div><div class="line">        if (canRun) &#123;</div><div class="line">            run()</div><div class="line">        &#125;else&#123;</div><div class="line">            clearTimeout(timer)</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">run()</div><div class="line"></div><div class="line">setTimeout(function () &#123;</div><div class="line">    console.log(&quot;change canRun&quot;)</div><div class="line">    canRun = false;</div><div class="line">&#125;, 10)</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function sleep(milliSeconds) &#123;</div><div class="line">    var startTime = new Date().getTime();</div><div class="line">    while (new Date().getTime() &lt; startTime + milliSeconds);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">const getRandom = async () =&gt; &#123;</div><div class="line">    sleep(300)</div><div class="line">    return Math.random() &gt; 0.1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let builder = x =&gt; async () =&gt; Promise.resolve(x);</div><div class="line"></div><div class="line">let tasks = Array.from(&#123;</div><div class="line">    length: 1120</div><div class="line">&#125;).map((_, k) =&gt; builder(`console.log($&#123;k&#125;)`))</div><div class="line"></div><div class="line">async function run() &#123;</div><div class="line">    for (let task of tasks) &#123;</div><div class="line">        let random = await getRandom()</div><div class="line">        if (random) &#123;</div><div class="line">            let source = await task();</div><div class="line">            (new Function(source))()</div><div class="line">        &#125;else&#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">run()</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">const EventEmitter = require(&apos;events&apos;);</div><div class="line"></div><div class="line">let builder = x =&gt; async () =&gt; Promise.resolve(x);</div><div class="line"></div><div class="line">let tasks = Array.from(&#123; length:1120 &#125;).map((_, k) =&gt; builder(`console.log($&#123;k&#125;)`))</div><div class="line"></div><div class="line">function sleep(milliSeconds) &#123;</div><div class="line">    var startTime = new Date().getTime();</div><div class="line">    while (new Date().getTime() &lt; startTime + milliSeconds);</div><div class="line"> &#125;;</div><div class="line"></div><div class="line">const getRandom = async () =&gt; &#123;</div><div class="line">    sleep(300)</div><div class="line">    return Math.random() &gt; 0.1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Queue extends EventEmitter &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    super();</div><div class="line">    this._index = 0;</div><div class="line">    this._start();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  _start() &#123;</div><div class="line">    this._timer = setTimeout(async () =&gt; &#123;</div><div class="line">      const source = await tasks[this._index]()</div><div class="line">      this.emit(&apos;next&apos;, source);</div><div class="line">      this._index++;</div><div class="line">      this._start();</div><div class="line">    &#125;, 0);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  _stop()&#123;</div><div class="line">    clearTimeout(this._timer)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">let q = new Queue();</div><div class="line">q.on(&apos;next&apos;, async (source) =&gt; &#123;</div><div class="line">  (new Function(source))()</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setTimeout(()=&gt;&#123;</div><div class="line">    q._stop()</div><div class="line">&#125;, 100)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实现可暂停异步任务队列的3种方式&quot;&gt;&lt;a href=&quot;#实现可暂停异步任务队列的3种方式&quot; class=&quot;headerlink&quot; title=&quot;实现可暂停异步任务队列的3种方式&quot;&gt;&lt;/a&gt;实现可暂停异步任务队列的3种方式&lt;/h1&gt;&lt;h3 id=&quot;需求：在爬取网页的
      
    
    </summary>
    
      <category term="前端" scheme="http://akira.wang/categories/web/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>看了再也不怕面试官问vue（面试装逼大法）</title>
    <link href="http://akira.wang/vue%E7%AE%97%E6%98%AF%E5%BE%88%E9%80%9A%E4%BF%97%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E9%9D%A2%E8%AF%95%E8%A3%85%E9%80%BC%E5%A4%A7%E6%B3%95%EF%BC%89/"/>
    <id>http://akira.wang/vue算是很通俗的源码分析（面试装逼大法）/</id>
    <published>2018-05-15T11:33:05.647Z</published>
    <updated>2018-05-15T11:36:10.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-请你说下数据绑定（数据绑定原理）："><a href="#1-请你说下数据绑定（数据绑定原理）：" class="headerlink" title="1.请你说下数据绑定（数据绑定原理）："></a>1.请你说下数据绑定（数据绑定原理）：</h2><p><img src="https://camo.githubusercontent.com/3845b9554e62650727fa7cae8f1c169060b879f7/68747470733a2f2f636e2e7675656a732e6f72672f696d616765732f646174612e706e67" alt="image"></p><ul><li>首先通过一次渲染操作触发Data的getter（这里保证只有视图中需要被用到的data才会触发getter）进行依赖收集，这时候其实Watcher与data可以看成一种被绑定的状态（实际上是data的闭包中有一个Deps订阅者，在修改的时候会通知所有的Watcher观察者），在data发生变化的时候会触发它的setter，setter通知Watcher，Watcher进行回调通知组件重新渲染的函数，之后根据diff算法来决定是否发生视图的更新。</li></ul><h3 id="初始化data（个人简化了的initData）"><a href="#初始化data（个人简化了的initData）" class="headerlink" title="初始化data（个人简化了的initData）"></a>初始化data（个人简化了的initData）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function initData (vm: Component) &#123;</div><div class="line">  /*得到data数据*/</div><div class="line">  let data = vm.$options.data</div><div class="line">  </div><div class="line">  /*遍历data，和props对象*/</div><div class="line">  const keys = Object.keys(data)</div><div class="line">  const props = vm.$options.props</div><div class="line">  let i = keys.length</div><div class="line"></div><div class="line">  //遍历data中的数据，且props和data没有key没有冲突</div><div class="line">  while (i--) &#123;</div><div class="line">      if (!(props &amp;&amp; hasOwn(props, keys[i]))) &#123; </div><div class="line">        proxy(vm, `_data`, keys[i])</div><div class="line">      &#125;    </div><div class="line">      /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  /*从这里开始我们要observe了，开始对数据进行绑定*/</div><div class="line">  observe(data, true /* asRootData */)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="initData函数主要做了两件事："><a href="#initData函数主要做了两件事：" class="headerlink" title="initData函数主要做了两件事："></a>initData函数主要做了两件事：</h4><ul><li>_data上面的数据代理到vm实例上</li><li>通过observe将所有数据变成observable</li></ul><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/*添加代理*/</div><div class="line">export function proxy (target: Object, sourceKey: string, key: string) &#123;</div><div class="line">  sharedPropertyDefinition.get = function proxyGetter () &#123;</div><div class="line">    return this[sourceKey][key]</div><div class="line">  &#125;</div><div class="line">  sharedPropertyDefinition.set = function proxySetter (val) &#123;</div><div class="line">    this[sourceKey][key] = val</div><div class="line">  &#125;</div><div class="line">  Object.defineProperty(target, key, sharedPropertyDefinition)</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>通过proxy函数将data上面的数据代理到vm上，这样就可以用app.text代替app._data.text了</li></ul><h3 id="Observe"><a href="#Observe" class="headerlink" title="Observe"></a>Observe</h3><ul><li><p>Vue的响应式数据都会有一个<strong>ob</strong>的属性作为标记，里面存放了该属性的观察器，也就是Observer的实例，防止重复绑定。</p></li><li><p>Observer为数据加上响应式属性进行双向绑定。如果是对象则进行深度遍历，为每一个子对象都绑定上方法，如果是数组则为每一个成员都绑定上方法。</p></li></ul><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><ul><li>Watcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Deps中，数据变动的时候会由Deps通知Watcher实例，然后由Watcher实例回调cb进行视图的更新。</li></ul><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><ul><li>Dep是一个发布者，可以订阅多个观察者，依赖收集之后Deps中会存在一个或多个Watcher对象，在数据变更的时候通知所有的Watcher。</li></ul><h3 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h3><h2 id="defineReactive的作用是通过Object-defineProperty为数据定义上getter-setter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。触发setter改变数据的时候会通知Deps订阅者通知所有的Watcher观察者对象进行试图的更新。"><a href="#defineReactive的作用是通过Object-defineProperty为数据定义上getter-setter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。触发setter改变数据的时候会通知Deps订阅者通知所有的Watcher观察者对象进行试图的更新。" class="headerlink" title="- defineReactive的作用是通过Object.defineProperty为数据定义上getter\setter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。触发setter改变数据的时候会通知Deps订阅者通知所有的Watcher观察者对象进行试图的更新。 "></a>- defineReactive的作用是通过Object.defineProperty为数据定义上getter\setter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。触发setter改变数据的时候会通知Deps订阅者通知所有的Watcher观察者对象进行试图的更新。 </h2><h2 id="2-小伙子，说下虚拟dom："><a href="#2-小伙子，说下虚拟dom：" class="headerlink" title="2.小伙子，说下虚拟dom："></a>2.小伙子，说下虚拟dom：</h2><ul><li><p>咳咳，一般来说，我们要修改试图的话需要直接操作dom执行各种事件才行，是应用一大就会变得难以维护。</p></li><li><p>vnode就是把真实dom都抽象成一颗以js对象构成的抽象树，在修改抽象树的数据后将抽象树转换成真实dom重绘到页面上去。</p></li><li><p>，当某个抽象树的某个数据被修改的时候，set方法会让闭包中的Dep调用notify通知所有订阅者Watcher，Watcher通过get方法执行vm._update(vm._render(),hydrating)</p></li><li>经过diff算法只需要修改抽象树修改了的部分即可，相对于一大片的HTML修改，大大提高了性能。</li><li>Vue使用了这样的抽象节点VNode，它是对真实DOM的一层抽象，所以它不依赖某个平台，比如weex</li></ul><h2 id="3-那diff算法你知道怎么运作的吗？"><a href="#3-那diff算法你知道怎么运作的吗？" class="headerlink" title="3.那diff算法你知道怎么运作的吗？"></a>3.那diff算法你知道怎么运作的吗？</h2><ul><li>diff算法在patch方法内，path将通过新老Vnode节点的对比，根据两者的比较结果进行最小单位地修改视图，而不是将整个视图根据Vnode重绘。</li><li>diff算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度是O（n），是非常高效的算法。</li><li><p><img src="https://camo.githubusercontent.com/db55af854af44f10b16053687c6c02d3d5ae4b98/68747470733a2f2f692e6c6f6c692e6e65742f323031372f30382f32372f353961323431396133633631372e706e67" alt="image"></p></li><li><p>这张图代表旧的VNode与新VNode进行patch的过程，他们只是在同层级的VNode之间进行比较得到变化（第二张图中相同颜色的方块代表互相进行比较的VNode节点）</p></li></ul><h2 id="4-使用v-for进行列表渲染的时候，加-key的效果是什么，为什么会这样？"><a href="#4-使用v-for进行列表渲染的时候，加-key的效果是什么，为什么会这样？" class="headerlink" title="4.使用v-for进行列表渲染的时候，加:key的效果是什么，为什么会这样？"></a>4.使用v-for进行列表渲染的时候，加:key的效果是什么，为什么会这样？</h2><ul><li>效果是更高效的更新虚拟dom。</li><li>数据更新后，新老Vnode如果是同一节点，就会直接修改现有的节点，否则就是创建新的dom，移除旧的dom</li><li><p>判断两个Vnode节点是否是同一节点，需要满足：</p><ul><li>==key相同==</li><li>tag（当前节点的标签名）相同</li><li>isComment（是否为注释节点）相同</li><li>是否data（当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息）都有定义</li><li>当标签是<input>的时候，type必须相同</li></ul></li><li><p>所以，这就是为什么尽可能在使用 v-for 时提供key</p></li></ul><h2 id="延伸：-更新虚拟dom的规则是这样："><a href="#延伸：-更新虚拟dom的规则是这样：" class="headerlink" title="延伸： 更新虚拟dom的规则是这样："></a>延伸： 更新虚拟dom的规则是这样：</h2><p>1.如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。</p><p>2.新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。</p><p>3.如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。</p><p>4.当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。</p><p>5.当新老节点都无子节点的时候，只是文本的替换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-请你说下数据绑定（数据绑定原理）：&quot;&gt;&lt;a href=&quot;#1-请你说下数据绑定（数据绑定原理）：&quot; class=&quot;headerlink&quot; title=&quot;1.请你说下数据绑定（数据绑定原理）：&quot;&gt;&lt;/a&gt;1.请你说下数据绑定（数据绑定原理）：&lt;/h2&gt;&lt;p&gt;&lt;i
      
    
    </summary>
    
      <category term="前端" scheme="http://akira.wang/categories/web/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2018.5.15 怎么这么难受做的~~ QAQ</title>
    <link href="http://akira.wang/2018.5.15%20%E6%80%8E%E4%B9%88%E8%BF%99%E4%B9%88%E9%9A%BE%E5%8F%97%E5%81%9A%E7%9A%84~~%20QAQ/"/>
    <id>http://akira.wang/2018.5.15 怎么这么难受做的~~ QAQ/</id>
    <published>2018-05-15T11:32:55.125Z</published>
    <updated>2018-05-15T11:35:04.536Z</updated>
    
    <content type="html"><![CDATA[<p>好难呀 QAQ，做的内心崩溃<br>Medium的题目真的是感觉在做高中数学卷子最后一大题的倒数第二问</p><hr><h2 id="Array-621-任务调度器"><a href="#Array-621-任务调度器" class="headerlink" title="Array - 621. 任务调度器"></a>Array - 621. 任务调度器</h2><h3 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。</p><p>然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的最短时间</p></blockquote><p>示例:</p><p>输入: [‘A’ <em> 5, ‘B’ </em> 4, ‘C’ <em> 4, ‘D’ </em> 2, ‘E’ * 1]， n = 5<br>输出: 25  </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>题意很简单，可是完全没思路。然后看答案吧，看了半天才看懂，果然只是凡人呐 QAQ</li><li>对tasks按照任务进行计数，记数目最多的任务为t，mx</li><li>问题转化为在tmax个任务之间的“槽”内尽可能安插别的任务，使idle最小化</li><li>本例中，数目最多的任务为t为 ‘A’ ，其间隔数n为5，我们先拟定一个这样的框架<ul><li>A o o o o o A o o o o o A o o o o o A o o o o o A</li></ul></li><li><p>标记为 ‘o’ 的槽用任务数递减的来插入，也就变为</p><ul><li>A B o o o o A B o o o o A B o o o o A B o o o o A</li><li>A B C o o o A B C o o o A B C o o o A B C o o o A</li><li>A B C D o o A B C D o o A B C o o o A B C o o o A</li><li>A B C D E o A B C D o o A B C o o o A B C o o o A</li></ul></li><li><p>当n为2的时候</p><ul><li>A o o A o o A o o A o o A</li><li>A B o A B o A B o A B o A</li><li>A B C A B C A B C A B C A</li><li>A B C A B C A B C A B D A C D E</li></ul></li></ul><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;character[]&#125; tasks</div><div class="line"> * @param &#123;number&#125; n</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line">var leastInterval = function(tasks, n) &#123;</div><div class="line">    let arr = [], obj = &#123;&#125;</div><div class="line">    let mx = 0, mxCnt = 0</div><div class="line">    let len = tasks.length</div><div class="line">    for(let i = 0; i &lt; len; i++) &#123;</div><div class="line">        if(obj[tasks[i]]) obj[tasks[i]]++</div><div class="line">        else obj[tasks[i]] = 1</div><div class="line">    &#125;</div><div class="line">    for(let key in obj) &#123;</div><div class="line">        arr.push(&#123;type: key, num: obj[key]&#125;)</div><div class="line">    &#125;</div><div class="line">    arr.sort(function(a, b) &#123;</div><div class="line">        return b.num - a.num</div><div class="line">    &#125;)</div><div class="line">    </div><div class="line">    let i = 0</div><div class="line">    mx = arr[0].num</div><div class="line">    while(i &lt; arr.length &amp;&amp; arr[i].num === mx) i++</div><div class="line">    </div><div class="line">    return Math.max(len, (mx - 1) * (n + 1) + i)</div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="Array-48-旋转图像"><a href="#Array-48-旋转图像" class="headerlink" title="Array - 48. 旋转图像"></a>Array - 48. 旋转图像</h2><h3 id="题目详情-1"><a href="#题目详情-1" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>给定一个 n × n 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p>说明：</p><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p></blockquote><p>示例:</p><p>给定 matrix =<br>        [<br>          [1,2,3],<br>          [4,5,6],<br>          [7,8,9]<br>        ]</p><p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]  </p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>先沿右下对角线进行交换，然后再以水平线进行交换</li></ul><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[][]&#125; matrix</div><div class="line"> * @return &#123;void&#125; Do not return anything, modify matrix in-place instead.</div><div class="line"> */</div><div class="line">var rotate = function(mat) &#123;</div><div class="line">    let xLen = mat[0].length,</div><div class="line">        yLen = mat.length</div><div class="line">    </div><div class="line">    for(let y = 0; y &lt; xLen - 1; y++) &#123;</div><div class="line">        for(let x = 0; x &lt; xLen - 1 - y; x++) &#123;</div><div class="line">            [mat[y][x], mat[xLen - 1 - x][yLen - 1 - y]] = [mat[xLen - 1 - x][yLen - 1 - y], mat[y][x]]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    for(let y = 0; y &lt; yLen / 2; y++) &#123;</div><div class="line">        for(let x = 0; x &lt; xLen; x++) &#123;</div><div class="line">            [mat[y][x], mat[yLen - 1 - y][x]] = [mat[yLen - 1 - y][x], mat[y][x]] </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好难呀 QAQ，做的内心崩溃&lt;br&gt;Medium的题目真的是感觉在做高中数学卷子最后一大题的倒数第二问&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Array-621-任务调度器&quot;&gt;&lt;a href=&quot;#Array-621-任务调度器&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="算法" scheme="http://akira.wang/categories/algorithm/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2018.5.11 或许前路永夜，即便如此我也要前进，因为星光即使微弱也会为我照亮前路。</title>
    <link href="http://akira.wang/2018.5.11%20%E6%88%96%E8%AE%B8%E5%89%8D%E8%B7%AF%E6%B0%B8%E5%A4%9C%EF%BC%8C%E5%8D%B3%E4%BE%BF%E5%A6%82%E6%AD%A4%E6%88%91%E4%B9%9F%E8%A6%81%E5%89%8D%E8%BF%9B%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%98%9F%E5%85%89%E5%8D%B3%E4%BD%BF%E5%BE%AE%E5%BC%B1%E4%B9%9F%E4%BC%9A%E4%B8%BA%E6%88%91%E7%85%A7%E4%BA%AE%E5%89%8D%E8%B7%AF%E3%80%82/"/>
    <id>http://akira.wang/2018.5.11 或许前路永夜，即便如此我也要前进，因为星光即使微弱也会为我照亮前路。/</id>
    <published>2018-05-15T11:32:50.466Z</published>
    <updated>2018-05-15T11:34:31.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Array-62-不同路径"><a href="#Array-62-不同路径" class="headerlink" title="Array - 62. 不同路径"></a>Array - 62. 不同路径</h2><h3 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p></blockquote><p>示例:  </p><p>输入: m = 3, n = 2  </p><p>输出: 3  </p><p>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>这是一个基本的DP问题</li><li><p>由于机器人只能向右和向下移动，当它到达某一点时，只有两种可能性：</p></li><li><p>1.它从上面到达那个点（向下移动到那一点）</p></li><li>2.它从左边到达那个点（向右移动到那一点）</li><li>因此，我们有下面的状态方程：假设到达某一点的路径数(i, j)表示为P[i][j]，很容易得出结论P[i][j] = P[i - 1][j] + P[i][j - 1]</li><li>然而实际上我们得出最后结果并用不到整个矩阵，只需要当前列上一个cell和左列的当前cell就够了。整理优化得：</li></ul><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number&#125; m</div><div class="line"> * @param &#123;number&#125; n</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line">var uniquePaths = function(m, n) &#123;</div><div class="line">    if (m &gt; n) return uniquePaths(n, m)</div><div class="line">    </div><div class="line">    let arr = Array(m).fill(1)</div><div class="line">    </div><div class="line">    for(let i = 1; i &lt; n; i ++) &#123;</div><div class="line">        for(let j = 1; j &lt; m; j++) &#123;</div><div class="line">            arr[j] += arr[j - 1]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return arr[m - 1]</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="Array-729-My-Calendar-I"><a href="#Array-729-My-Calendar-I" class="headerlink" title="Array - 729. My Calendar I"></a>Array - 729. My Calendar I</h2><h3 id="题目详情-1"><a href="#题目详情-1" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。</p><p>MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为，  start &lt;= x &lt; end。</p><p>当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。</p><p>每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。</p></blockquote><p>示例:<br>MyCalendar();<br>MyCalendar.book(10, 20); // returns true<br>MyCalendar.book(15, 25); // returns false<br>MyCalendar.book(20, 30); // returns true</p><p>解释:<br>第一个日程安排可以添加到日历中<br>第二个日程安排不能添加到日历中，因为时间 15 已经被第一个日程安排预定了<br>第三个日程安排可以添加到日历中，因为第一个日程安排并不包含时间 20 。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>要求两个日程范围不存在重复。<br>每次添加时需要和以往所有的日程进行比较。才可以确实是否可以添加。<br>现罗列出重叠的情况。</li></ul><p>a为已存在日程，b为待添加日程。</p><p>a　　 a0 l————l a1<br>b 　　　 b0 l—-l b1</p><p>a      a0 l————l a1<br>b       　　b0 l———l b1</p><p>a 　 a0 l————l a1<br>b  b0 l——l b1</p><ul><li>根据以上重叠情况，可以得到一个抽象的描述<br>max(a0, b0) &lt; min(a1, b1)</li></ul><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var MyCalendar = function() &#123;</div><div class="line">    this.calendar = &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/** </div><div class="line"> * @param &#123;number&#125; start </div><div class="line"> * @param &#123;number&#125; end</div><div class="line"> * @return &#123;boolean&#125;</div><div class="line"> */</div><div class="line">MyCalendar.prototype.book = function(start, end) &#123;</div><div class="line">    for(let key in this.calendar) &#123;</div><div class="line">        if(!((key &lt; start &amp;&amp; this.calendar[key] &lt;= start) || (key &gt;= end &amp;&amp; this.calendar[key] &gt; end))) return false</div><div class="line">    &#125;</div><div class="line">    this.calendar[start] = end</div><div class="line">    return true</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/** </div><div class="line"> * Your MyCalendar object will be instantiated and called as such:</div><div class="line"> * var obj = Object.create(MyCalendar).createNew()</div><div class="line"> * var param_1 = obj.book(start,end)</div><div class="line"> */</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Array-62-不同路径&quot;&gt;&lt;a href=&quot;#Array-62-不同路径&quot; class=&quot;headerlink&quot; title=&quot;Array - 62. 不同路径&quot;&gt;&lt;/a&gt;Array - 62. 不同路径&lt;/h2&gt;&lt;h3 id=&quot;题目详情&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="算法" scheme="http://akira.wang/categories/algorithm/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2018.5.8 Subsets &amp;&amp; 2 Keys Keyboard</title>
    <link href="http://akira.wang/2018.5.8%20Subsets%20&amp;&amp;%202%20Keys%20Keyboard/"/>
    <id>http://akira.wang/2018.5.8 Subsets &amp;&amp; 2 Keys Keyboard/</id>
    <published>2018-05-15T11:32:45.733Z</published>
    <updated>2018-05-15T11:33:52.558Z</updated>
    
    <content type="html"><![CDATA[<p>直接上题~~</p><h2 id="Array-78-子集"><a href="#Array-78-子集" class="headerlink" title="Array - 78. 子集"></a>Array - 78. 子集</h2><h3 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p></blockquote><p>示例:</p><p>输入: nums = [1,2,3]<br>输出:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>创建一个arr放置的是第i-1次的所有子集</li><li>每次遍历就把nums[i] push进arr</li><li>再把arr push进res</li></ul><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; nums</div><div class="line"> * @return &#123;number[][]&#125;</div><div class="line"> */</div><div class="line">var subsets = function(nums) &#123;</div><div class="line">    let arr = []</div><div class="line">    let res = [[]]</div><div class="line">    for(let i = 0, len = nums.length; i &lt; len; i++) &#123;</div><div class="line">        </div><div class="line">        for(let j = 0, resLen = res.length; j &lt; resLen; j++) &#123;</div><div class="line">            arr[j] = []</div><div class="line">            arr[j].push(...res[j])</div><div class="line">        &#125;</div><div class="line">        for(let j = 0, arrLen = arr.length; j &lt; arrLen; j++) &#123;</div><div class="line">            arr[j].push(nums[i])</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        res.push(...arr)</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    arr = null</div><div class="line">    return res</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="Array-650-2-Keys-Keyboard"><a href="#Array-650-2-Keys-Keyboard" class="headerlink" title="Array - 650. 2 Keys Keyboard"></a>Array - 650. 2 Keys Keyboard</h2><h3 id="题目详情-1"><a href="#题目详情-1" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：</p><p>1.Copy All (复制全部) :<br>你可以复制这个记事本中的所有字符(部分的复制是不允许的)。</p><p>2.Paste (粘贴) : 你可以粘贴你上一次复制的字符。</p><p>给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。</p></blockquote><p>示例:</p><p>输入: 3<br>输出: 3  </p><p>解释:<br>最初, 我们只有一个字符 ‘A’。<br>第 1 步, 我们使用 Copy All 操作。<br>第 2 步, 我们使用 Paste 操作来获得 ‘AA’。<br>第 3 步, 我们使用 Paste 操作来获得 ‘AAA’。  </p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>简单找下规律，n为质数那么，输出的就是n</li><li>如果非质数，那么输出就是n的最小公因数之和</li></ul><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number&#125; n</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line">var minSteps = function(n) &#123;</div><div class="line">    let res = 0</div><div class="line">    for(let i = 2; i &lt;= n; i++) &#123;</div><div class="line">        while(n % i === 0) &#123;</div><div class="line">            res += i</div><div class="line">            n /= i</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return res</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;直接上题~~&lt;/p&gt;
&lt;h2 id=&quot;Array-78-子集&quot;&gt;&lt;a href=&quot;#Array-78-子集&quot; class=&quot;headerlink&quot; title=&quot;Array - 78. 子集&quot;&gt;&lt;/a&gt;Array - 78. 子集&lt;/h2&gt;&lt;h3 id=&quot;题目详情&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="算法" scheme="http://akira.wang/categories/algorithm/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2018.5.7 因为害怕自己并非明珠而不敢刻苦琢磨，又因为有几分相信自己是明珠，而不能与瓦砾碌碌为伍</title>
    <link href="http://akira.wang/2018.5.7%20%E5%9B%A0%E4%B8%BA%E5%AE%B3%E6%80%95%E8%87%AA%E5%B7%B1%E5%B9%B6%E9%9D%9E%E6%98%8E%E7%8F%A0%E8%80%8C%E4%B8%8D%E6%95%A2%E5%88%BB%E8%8B%A6%E7%90%A2%E7%A3%A8%EF%BC%8C%E5%8F%88%E5%9B%A0%E4%B8%BA%E6%9C%89%E5%87%A0%E5%88%86%E7%9B%B8%E4%BF%A1%E8%87%AA%E5%B7%B1%E6%98%AF%E6%98%8E%E7%8F%A0%EF%BC%8C%E8%80%8C%E4%B8%8D%E8%83%BD%E4%B8%8E%E7%93%A6%E7%A0%BE%E7%A2%8C%E7%A2%8C%E4%B8%BA%E4%BC%8D/"/>
    <id>http://akira.wang/2018.5.7 因为害怕自己并非明珠而不敢刻苦琢磨，又因为有几分相信自己是明珠，而不能与瓦砾碌碌为伍/</id>
    <published>2018-05-07T11:37:01.104Z</published>
    <updated>2018-05-07T11:39:19.955Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="因为害怕自己并非明珠而不敢刻苦琢磨，又因为有几分相信自己是明珠，而不能与瓦砾碌碌为伍"><a href="#因为害怕自己并非明珠而不敢刻苦琢磨，又因为有几分相信自己是明珠，而不能与瓦砾碌碌为伍" class="headerlink" title="因为害怕自己并非明珠而不敢刻苦琢磨，又因为有几分相信自己是明珠，而不能与瓦砾碌碌为伍"></a>因为害怕自己并非明珠而不敢刻苦琢磨，又因为有几分相信自己是明珠，而不能与瓦砾碌碌为伍</h4></blockquote><p>前几天做题的时候，完全没思路，看了disscuss也没看懂。很是受打击，正如上面那句话所说，不知道自己是否适合再做下去。</p><p>总之，遇到不会的姑且先跳过吧。</p><h2 id="Array-769-最多能完成排序的块"><a href="#Array-769-最多能完成排序的块" class="headerlink" title="Array - 769. 最多能完成排序的块"></a>Array - 769. 最多能完成排序的块</h2><h3 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>数组arr是[0, 1, …, arr.length - 1]的一种排列，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p><p>我们最多能将数组分成多少块？</p></blockquote><p>示例 1:</p><p>输入: arr = [4,3,2,1,0]</p><p>输出: 1</p><p>解释:<br>将数组分成2块或者更多块，都无法得到所需的结果。<br>例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。</p><hr><p>输入: arr = [1,0,2,3,4]</p><p>输出: 4</p><p>解释:</p><p>我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。</p><p>然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>indexSum记录当前遍历的最大索引值</li><li>sum是当前和</li><li>count是块数</li><li>遍历过程中如果索引值的和 和 sum 不相等那就跳过继续循环直到相等了这一”分区”必然能排列成正确数列</li></ul><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; arr</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line">var maxChunksToSorted = function(arr) &#123;</div><div class="line">    let indexSum = sum = count = 0</div><div class="line">    for(let i = 0, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">        sum += arr[i]</div><div class="line">        indexSum += i</div><div class="line">        if(sum === indexSum) count++</div><div class="line">    &#125;</div><div class="line">    return count</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="Array-714-买卖股票的最佳时机含手续费（重点）"><a href="#Array-714-买卖股票的最佳时机含手续费（重点）" class="headerlink" title="Array - 714. 买卖股票的最佳时机含手续费（重点）"></a>Array - 714. 买卖股票的最佳时机含手续费（重点）</h2><p>之前在《JavaScript数据结构和算法》上也有过示例，然后我也理所当然的忘了。 QAQ</p><h3 id="题目详情-1"><a href="#题目详情-1" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p></blockquote><p>示例:</p><p>输入: prices = [1, 3, 2, 8, 4, 9], fee = 2</p><p>输出: 8</p><p>解释:<br>能够达到的最大利润:<br>在此处买入 prices[0] = 1<br>在此处卖出 prices[3] = 8<br>在此处买入 prices[4] = 4<br>在此处卖出 prices[5] = 9<br>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>DP</li><li>遍历过程算出每个i的最大利润值，最小买入值</li><li>最小买入值=Math.min(上一次买入, 当前总买入值)</li><li>最大利润=Math.max(上一次利润, 当前利润)</li></ul><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; prices</div><div class="line"> * @param &#123;number&#125; fee</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line">var maxProfit = function(prices, fee) &#123;</div><div class="line">    let n = prices.length;</div><div class="line">    let hold = prices[0],</div><div class="line">        sold = 0;</div><div class="line">    for (let i = 1; i &lt; n; ++i) &#123;</div><div class="line">        hold = Math.min(hold, prices[i] - sold);</div><div class="line">        sold = Math.max(sold, prices[i] - hold - fee);</div><div class="line">    &#125;</div><div class="line">    return sold;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;因为害怕自己并非明珠而不敢刻苦琢磨，又因为有几分相信自己是明珠，而不能与瓦砾碌碌为伍&quot;&gt;&lt;a href=&quot;#因为害怕自己并非明珠而不敢刻苦琢磨，又因为有几分相信自己是明珠，而不能与瓦砾碌碌为伍&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="算法" scheme="http://akira.wang/categories/algorithm/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2018.5.2 五一假期归来，算法不能停</title>
    <link href="http://akira.wang/2018.5.2%20%E4%BA%94%E4%B8%80%E5%81%87%E6%9C%9F%E5%BD%92%E6%9D%A5%EF%BC%8C%E7%AE%97%E6%B3%95%E4%B8%8D%E8%83%BD%E5%81%9C/"/>
    <id>http://akira.wang/2018.5.2 五一假期归来，算法不能停/</id>
    <published>2018-05-07T11:36:55.848Z</published>
    <updated>2018-05-07T11:38:59.211Z</updated>
    
    <content type="html"><![CDATA[<p>目前Array标签的easy题做完了，medium的题目做起来真的感到吃力</p><p>T.T </p><h2 id="Array-238-Product-of-Array-Except-Self（-除自身以外数组的乘积）"><a href="#Array-238-Product-of-Array-Except-Self（-除自身以外数组的乘积）" class="headerlink" title="Array - 238. Product of Array Except Self（ 除自身以外数组的乘积）"></a>Array - 238. Product of Array Except Self（ 除自身以外数组的乘积）</h2><h3 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>一个长度为 n 的整形数组nums，其中 n &gt; 1，返回一个数组 output ，其中 output[i] 等于nums中除nums[i]以外所有元素的乘积。</p><p>不用除法 且在O(n)内解决这个问题。</p></blockquote><p>Example:</p><p>Input: [1,2,3,4]</p><p>Output: [24,12,8,6]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>比较好的解决方法是构造两个数组相乘：</li></ul><blockquote><p>1.[1, a1, a1 <em> a2, a1 </em> a2 * a3]</p><p>2.[a2 <em> a3 </em> a4, a3 * a4, a4, 1]</p></blockquote><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; nums</div><div class="line"> * @return &#123;number[]&#125;</div><div class="line"> */</div><div class="line">var productExceptSelf = function(nums) &#123;</div><div class="line">    let len = nums.length</div><div class="line">    let arr = []</div><div class="line">    let p</div><div class="line">    arr[0] = p = 1</div><div class="line">    </div><div class="line">    for(let i = 1; i &lt; len; i++) &#123;</div><div class="line">        p *= nums[i-1]</div><div class="line">        arr[i] = p</div><div class="line">    &#125;</div><div class="line">    p = 1</div><div class="line">    for(let i = len - 2; i &gt;=0; i--) &#123;</div><div class="line">        arr[i] *= p*= nums[i+1]</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return arr</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="Array-565-Array-Nesting（数组嵌套）"><a href="#Array-565-Array-Nesting（数组嵌套）" class="headerlink" title="Array - 565. Array Nesting（数组嵌套）"></a>Array - 565. Array Nesting（数组嵌套）</h2><h3 id="题目详情-1"><a href="#题目详情-1" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到并返回最大的集合S，S[i] = {A[i], A[A[i]], A[A[A[i]]], … }且遵守以下的规则。</p><p>假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]… 以此类推，不断添加直到S出现重复的元素。</p></blockquote><p>Example:</p><p>Input: A = [5,4,0,3,1,6,2]</p><p>Output: 4</p><p>Explanation: </p><p>A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.</p><p>其中一种最长的 S[K]:<br>S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>按照题意思路去写</li></ul><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; nums</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */ </div><div class="line">var arrayNesting = function(nums) &#123;</div><div class="line">    let maxLen = 0</div><div class="line">    for(let i = 0, len = nums.length; i &lt; len; i++) &#123;</div><div class="line">        let curLen = 1,</div><div class="line">            val = nums[i]</div><div class="line">        while(Math.abs(val)!=i) &#123;</div><div class="line">            val = nums[Math.abs(val)]</div><div class="line">            curLen++</div><div class="line">        &#125;</div><div class="line">        maxLen = Math.max(curLen, maxLen)</div><div class="line">    &#125;</div><div class="line">    return maxLen</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前Array标签的easy题做完了，medium的题目做起来真的感到吃力&lt;/p&gt;
&lt;p&gt;T.T &lt;/p&gt;
&lt;h2 id=&quot;Array-238-Product-of-Array-Except-Self（-除自身以外数组的乘积）&quot;&gt;&lt;a href=&quot;#Array-238-Pr
      
    
    </summary>
    
      <category term="算法" scheme="http://akira.wang/categories/algorithm/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2018.4.26 题是做了，每天要更新博客还是有点略麻烦</title>
    <link href="http://akira.wang/2018.4.26%20%E9%A2%98%E6%98%AF%E5%81%9A%E4%BA%86%EF%BC%8C%E6%AF%8F%E5%A4%A9%E8%A6%81%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E8%BF%98%E6%98%AF%E6%9C%89%E7%82%B9%E7%95%A5%E9%BA%BB%E7%83%A6/"/>
    <id>http://akira.wang/2018.4.26 题是做了，每天要更新博客还是有点略麻烦/</id>
    <published>2018-05-07T11:36:49.446Z</published>
    <updated>2018-05-07T11:38:38.504Z</updated>
    
    <content type="html"><![CDATA[<p>下班前才提起精神写的… （坚持坚持…）</p><h2 id="Array-532-数组中的K-diff数对"><a href="#Array-532-数组中的K-diff数对" class="headerlink" title="Array - 532. 数组中的K-diff数对"></a>Array - 532. 数组中的K-diff数对</h2><h3 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.</p></blockquote><p>Example1:</p><p>输入: [3, 1, 4, 1, 5], k = 2</p><p>输出: 2</p><p>Example1:</p><p>输入: [1, 3, 1, 5, 4], k = 0</p><p>输出: 1</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>用哈希表储存每个数字的出现次数</li></ul><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; nums</div><div class="line"> * @param &#123;number&#125; k</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line">var findPairs = function(nums, k) &#123;</div><div class="line">    let obj = &#123;&#125;</div><div class="line">    let count = 0</div><div class="line">    let len = nums.length</div><div class="line">    </div><div class="line">    for(let i = 0; i &lt; len; i++) &#123;</div><div class="line">        if(obj[nums[i]]) &#123;</div><div class="line">            obj[nums[i]]++</div><div class="line">        &#125; else &#123;</div><div class="line">            obj[nums[i]] = 1</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(let key in obj) &#123;</div><div class="line">        if(k === 0) count += obj[key] &gt;= 2 ? 1 : 0;</div><div class="line">        if(k &gt; 0) &#123;</div><div class="line">            if(obj[String(key - 0 + k)]) &#123;</div><div class="line">                count += 1</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return count</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="Array-189-旋转数组"><a href="#Array-189-旋转数组" class="headerlink" title="Array - 189. 旋转数组"></a>Array - 189. 旋转数组</h2><h3 id="题目详情-1"><a href="#题目详情-1" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>将包含 n 个元素的数组向右旋转 k 步。<br>例如，如果  n = 7 ,  k = 3，给定数组  [1,2,3,4,5,6,7]  ，向右旋转后的结果为 [5,6,7,1,2,3,4]。</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>利用数组的length - k 把数组 分为两半</li><li>reverse 左边和右边的数组</li><li>reverse 总数组。</li></ul><blockquote><p>举一个例子： </p><p>　　1 2 3 4 5 6 7　　如果k = 3 的话， 会变成 5 6 7 1 2 3 4</p><p>　　==1 2 3 4== 5 6 7　　middle = 7 - 3 = 4，分为左边 4个数字，右边 3个数字</p><p>　　==4 3 2 1== 7 6 5　　分别把左右reverse 一下</p><p>　　==5 6 7== 1 2 3 4　　把总数组reverse 一下就会得到答案</p></blockquote><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; nums</div><div class="line"> * @param &#123;number&#125; k</div><div class="line"> * @return &#123;void&#125; Do not return anything, modify nums in-place instead.</div><div class="line"> */</div><div class="line">var rotate = function(nums, k) &#123;</div><div class="line">    if(nums == null || nums.length == 0 || k % nums.length == 0) return</div><div class="line">    </div><div class="line">    let len = nums.length</div><div class="line">    let turn = k % len</div><div class="line">    let mid = len - turn</div><div class="line">    </div><div class="line">    swap(nums, 0, mid - 1)</div><div class="line">    swap(nums, mid, len - 1)</div><div class="line">    swap(nums, 0, len - 1)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function swap(arr, s, e) &#123;</div><div class="line">    console.log(arr, s, e)</div><div class="line">    let temp</div><div class="line">    while(s &lt; e) &#123;</div><div class="line">        temp = arr[s]</div><div class="line">        arr[s] = arr[e]</div><div class="line">        arr[e] = temp</div><div class="line">        s++</div><div class="line">        e--</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h2 id="Array-665-非递减数列"><a href="#Array-665-非递减数列" class="headerlink" title="Array - 665. 非递减数列"></a>Array - 665. 非递减数列</h2><h3 id="题目详情-2"><a href="#题目详情-2" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。<br>我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &lt;= i &lt; n)，满足 array[i] &lt;= array[i + 1]。</p></blockquote><p>Example:</p><p>输入: [4,2,3]</p><p>输出: True</p><p>Example:</p><p>输入: [4,2,1]</p><p>输出: False</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>这个题目关键在于，当遇见一个 nums[i] &gt; nums[i+1] 的情况，我们是把 nums[i]降为nums[i+1] 还是 把nums[i+1]升为nums[i]</li><li>　来看一下两种情况：</li><li><ul><li>　a. 1 3 ==5 4== 6 7  –&gt;  1 3 ==4 4== 6 7</li></ul></li><li><ul><li>　当遇到5 &gt; 4 的情况，这里因为4比5之前的所有数字都大，所以可以把5 降为4。</li></ul></li><li><ul><li>　b. 1 4 ==5 3== 6 7  –&gt;  1 4 ==5 5== 6 7</li></ul></li><li>当遇到5 &gt; 3 的情况，这里3比5之前的4小，所以没有选择，只能把3 升为5。</li><li>当需要第二次改动的时候，可以直接返回false，不需要把剩下的array走完。</li></ul><h3 id="具体代码-2"><a href="#具体代码-2" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; nums</div><div class="line"> * @return &#123;boolean&#125;</div><div class="line"> */</div><div class="line">var checkPossibility = function(nums) &#123;</div><div class="line">    let boo = true</div><div class="line">    </div><div class="line">    for(let i = 1, len = nums.length; i &lt; len - 2; i++) &#123;</div><div class="line">        if(nums[i] &gt; nums[i + 1]) &#123;</div><div class="line">            if(boo) &#123;</div><div class="line">                return false</div><div class="line">            &#125; else if (nums[i + 1] &lt; nums[i - 1] &amp;&amp; nums[i] &lt; nums[i + 2]) &#123;</div><div class="line">                console.log(nums)</div><div class="line">                nums[i + 1] = nums[i]</div><div class="line">                boo = true</div><div class="line">            &#125; else &#123;</div><div class="line">                nums[i] = nums[i + 1]</div><div class="line">                boo = true</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return true</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下班前才提起精神写的… （坚持坚持…）&lt;/p&gt;
&lt;h2 id=&quot;Array-532-数组中的K-diff数对&quot;&gt;&lt;a href=&quot;#Array-532-数组中的K-diff数对&quot; class=&quot;headerlink&quot; title=&quot;Array - 532. 数组中的K-di
      
    
    </summary>
    
      <category term="算法" scheme="http://akira.wang/categories/algorithm/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2018.4.25 leetcode中文官网用起~</title>
    <link href="http://akira.wang/2018.4.25%20leetcode%E4%B8%AD%E6%96%87/"/>
    <id>http://akira.wang/2018.4.25 leetcode中文/</id>
    <published>2018-05-07T11:36:39.488Z</published>
    <updated>2018-05-07T11:38:08.276Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始用中文官网的leetcode了</p><h2 id="Array-581-最短无序连续子数组"><a href="#Array-581-最短无序连续子数组" class="headerlink" title="Array - 581. 最短无序连续子数组"></a>Array - 581. 最短无序连续子数组</h2><h3 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>你找到的子数组应是最短的，请输出它的长度。</p></blockquote><p>示例1:</p><p>输入: [2, 5, 6, 4, 8, 11, 9, 10, 15]</p><p>输出: 5</p><p>解释: 你只需要对 [6, 4, 8, 10, 9]进行升序排序，那么整个表都会变为升序排序。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>当我们找到第一个违反ascending排序的数字 4的时候，我们不能是仅仅把beg 标记为4的前面一个数字6，而是要一直往前，找到一个合适的位置，找到在最前面位置的比4大的数字，这里是5。</li><li>同样的，为了找end，我们要从11的后面找，找比11小的数，这里是10</li><li>这样的话，范围就是5到10 是我们要找的子数组。把3到6排序完了之后，整个array 就已经是排序的了。</li><li>这里发现，这组无序数组中，4是最小值，11是最大值</li><li>所以，从左遍历的时候更新已遍历元素的当前最大值，当下一个元素小于最大值，那么更新end的值</li></ul><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; nums</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line">var findUnsortedSubarray = function(nums) &#123;</div><div class="line">    let n = nums.length</div><div class="line">    let beg = -1</div><div class="line">    let end = -2</div><div class="line">    let min = nums[n-1];</div><div class="line">    let max = nums[0];</div><div class="line"></div><div class="line">    for(let i=0; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        max = Math.max(max, nums[i]);</div><div class="line">        min = Math.min(min, nums[n-1-i]);</div><div class="line">        </div><div class="line">        if(nums[i] &lt; max) end = i;</div><div class="line">        if(nums[n-1-i] &gt; min) beg = n-1-i;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return end - beg + 1</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>由于这题用了不少时间… 所以今天就做一题好了 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天开始用中文官网的leetcode了&lt;/p&gt;
&lt;h2 id=&quot;Array-581-最短无序连续子数组&quot;&gt;&lt;a href=&quot;#Array-581-最短无序连续子数组&quot; class=&quot;headerlink&quot; title=&quot;Array - 581. 最短无序连续子数组&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="算法" scheme="http://akira.wang/categories/algorithm/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2018.4.24 还是DP....</title>
    <link href="http://akira.wang/2018.4.24%20%E8%BF%98%E6%98%AFDP..../"/>
    <id>http://akira.wang/2018.4.24 还是DP..../</id>
    <published>2018-04-24T11:52:34.250Z</published>
    <updated>2018-04-24T11:53:02.375Z</updated>
    
    <content type="html"><![CDATA[<p>今天3题，就最后一题涉及贪心，DP的看了一下disscuss</p><h2 id="Array-219-Contains-Duplicate-II"><a href="#Array-219-Contains-Duplicate-II" class="headerlink" title="Array - 219. Contains Duplicate II"></a>Array - 219. Contains Duplicate II</h2><h3 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p><p>查找有没相同的值，但是索引(i j不同)不同，且他们的索引距离小于k，有返回true</p></blockquote><p>Example:</p><p>Input: matrix = [0, 1, 0, 1, 12], k = 3</p><p>Output: true</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>跟数组去重一样，利用键值对，值存储索引值，键值存储值</li></ul><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; nums</div><div class="line"> * @param &#123;number&#125; k</div><div class="line"> * @return &#123;boolean&#125;</div><div class="line"> */</div><div class="line">var containsNearbyDuplicate = function(nums, k) &#123;</div><div class="line">    let obj = &#123;&#125;</div><div class="line">    for(let i = 0, len = nums.length; i &lt; len; i++) &#123;</div><div class="line">        if(obj[nums[i]] !== undefined) &#123;</div><div class="line">            if(Math.abs(obj[nums[i]] - i) &lt;= k) &#123;</div><div class="line">                return true</div><div class="line">            &#125;</div><div class="line">            obj[nums[i]] = i</div><div class="line">        &#125; else &#123;</div><div class="line">            obj[nums[i]] = i</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="Array-643-Maximum-Average-Subarray-I"><a href="#Array-643-Maximum-Average-Subarray-I" class="headerlink" title="Array - 643. Maximum Average Subarray I"></a>Array - 643. Maximum Average Subarray I</h2><h3 id="题目详情-1"><a href="#题目详情-1" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value.</p><p>在数组中找到长度为k的最大值除以k的值。其实就是找到长度为&gt;k的最大值</p></blockquote><p>Example:</p><p>Input: [1,12,-5,-6,50,3], k = 4</p><p>Output: 12.75</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>先求前 k - 1长度数组的和</li><li>然后遍历数组，从k-1开始加，之后就加一个尾减个头，这样保证长度不变。</li></ul><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; nums</div><div class="line"> * @param &#123;number&#125; k</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line">var findMaxAverage = function(nums, k) &#123;</div><div class="line">    if(nums.length === 1) return nums[0]</div><div class="line">    </div><div class="line">    let currSum = 0</div><div class="line">    for(let i = 0; i &lt; k - 1; i++) &#123;</div><div class="line">        currSum += nums[i]</div><div class="line">    &#125;</div><div class="line">    if(nums.length === k) return (currSum + nums[k - 1]) / k</div><div class="line">    </div><div class="line">    let maxSum = -Infinity</div><div class="line">    for(let i = k - 1, len = nums.length; i &lt; len; i++) &#123;</div><div class="line">        currSum += nums[i]</div><div class="line">        if(i - k &gt; -1) &#123;</div><div class="line">            currSum -= nums[i - k]</div><div class="line">        &#125;</div><div class="line">        maxSum = Math.max(currSum, maxSum)</div><div class="line">    &#125;</div><div class="line">    return maxSum / 1.0 / k</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="Array-605-Can-Place-Flowers"><a href="#Array-605-Can-Place-Flowers" class="headerlink" title="Array - 605. Can Place Flowers"></a>Array - 605. Can Place Flowers</h2><h3 id="题目详情-2"><a href="#题目详情-2" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.</p><p>Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.</p><p>这道题给了我们一个01数组，其中1表示已经放了花，0表示可以放花的位置，但是有个限制条件是不能有相邻的花。</p></blockquote><p>Example:</p><p>Input: flowerbed = [1,0,0,0,1], n = 1</p><p>Output: True</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>遍历数组，在为0的元素，判断该元素前后是否为0</li><li>如果是，判断该位置前后是不是有花</li><li>没有花就在该位置种花，种花次数和n相等</li></ul><h3 id="具体代码-2"><a href="#具体代码-2" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; flowerbed</div><div class="line"> * @param &#123;number&#125; n</div><div class="line"> * @return &#123;boolean&#125;</div><div class="line"> */</div><div class="line">var canPlaceFlowers = function(arr, n) &#123;</div><div class="line">    let count = 0</div><div class="line">    for(let i = 0, len = arr.length; i &lt; len &amp;&amp; count &lt; n; i++) &#123;</div><div class="line">        if(arr[i] === 0) &#123;</div><div class="line">            let prev = i === 0 ? 0 : arr[i - 1]</div><div class="line">            let next = i === len - 1 ? 0 : arr[i + 1]</div><div class="line">            if(prev === 0 &amp;&amp; next === 0) &#123;</div><div class="line">                arr[i] = 1</div><div class="line">                count ++</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    console.log(count)</div><div class="line">    return count === n</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天3题，就最后一题涉及贪心，DP的看了一下disscuss&lt;/p&gt;
&lt;h2 id=&quot;Array-219-Contains-Duplicate-II&quot;&gt;&lt;a href=&quot;#Array-219-Contains-Duplicate-II&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="算法" scheme="http://akira.wang/categories/algorithm/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2018.4.20 leetcode DP看的头大...</title>
    <link href="http://akira.wang/2018.4.20%20leetcode%20DP%E7%9C%8B%E7%9A%84%E5%A4%B4%E5%A4%A7.../"/>
    <id>http://akira.wang/2018.4.20 leetcode DP看的头大.../</id>
    <published>2018-04-23T16:04:03.152Z</published>
    <updated>2018-04-23T16:35:39.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018-4-20-Array-628-Maximum-Product-of-Three-Numbers"><a href="#2018-4-20-Array-628-Maximum-Product-of-Three-Numbers" class="headerlink" title="2018.4.20## Array - 628. Maximum Product of Three Numbers"></a>2018.4.20## Array - 628. Maximum Product of Three Numbers</h1><h3 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p><p>找到一列数组中，乘积结果最大的三个值的乘积。每个值范围是[1000,-1000]</p></blockquote><p>Example:</p><p>Input: [1,2,3,4]<br>Output: 24</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>找出最大前三位值和最小前两位值</li><li>前三大值的乘积 和 最大值和前两小值的乘机</li></ul><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; nums</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line">var maximumProduct = function(nums) &#123;</div><div class="line">    let min1 = min2 = 1001</div><div class="line">        max1 = max2 = max3 = -1001</div><div class="line">    for(let i = 0, len = nums.length; i &lt; len; i++) &#123;</div><div class="line">        if(nums[i] &gt; max1) &#123;</div><div class="line">            max3 = max2</div><div class="line">            max2 = max1</div><div class="line">            max1 = nums[i]</div><div class="line">        &#125; else if(nums[i] &gt; max2) &#123;</div><div class="line">            max3 = max2</div><div class="line">            max2 = nums[i]</div><div class="line">        &#125; else if(nums[i] &gt; max3) &#123;</div><div class="line">            max3 = nums[i]</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if(nums[i] &lt; min1) &#123;</div><div class="line">            min2 = min1</div><div class="line">            min1 = nums[i]</div><div class="line">        &#125; else if(nums[i] &lt; min2) &#123;</div><div class="line">            min2 = nums[i]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return Math.max(max1*max2*max3, min1*min2*max1)</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="Array-746-Min-Cost-Climbing-Stairs"><a href="#Array-746-Min-Cost-Climbing-Stairs" class="headerlink" title="Array - 746. Min Cost Climbing Stairs"></a>Array - 746. Min Cost Climbing Stairs</h2><h3 id="题目详情-1"><a href="#题目详情-1" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).</p><p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p><p>有一个楼梯，每次可以走1层或者2层，cost数组表示每一层所需要花费的值。可以从第一层或者第二层开始。求，到达顶端所花费大的最小的值。</p></blockquote><p>Example:</p><p>Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</p><p>Output: 6</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>让dp[i]成为第i层楼梯的最低成本。</li><li>dp的转换方程 dp[i] = cost[i] + Math.min(dp[i-1], dp[i-2])</li></ul><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; cost</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line">var minCostClimbingStairs = function(cost) &#123;</div><div class="line">    let len = cost.length;</div><div class="line">    let dp = []</div><div class="line">    dp[0] = cost[0]</div><div class="line">    dp[1] = cost[1]</div><div class="line">    for(let i = 2; i &lt; len; i++) &#123;</div><div class="line">        dp[i] = cost[i] + Math.min(dp[i-2], dp[i-1])</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return Math.min(dp[len-2], dp[len-1])</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2018-4-20-Array-628-Maximum-Product-of-Three-Numbers&quot;&gt;&lt;a href=&quot;#2018-4-20-Array-628-Maximum-Product-of-Three-Numbers&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="算法" scheme="http://akira.wang/categories/algorithm/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2018.4.23 leetcode 即便是慵懒的星期一，也不能落下</title>
    <link href="http://akira.wang/2018.4.23%20leetcode%20%E5%8D%B3%E4%BE%BF%E6%98%AF%E6%85%B5%E6%87%92%E7%9A%84%E6%98%9F%E6%9C%9F%E4%B8%80%EF%BC%8C%E4%B9%9F%E4%B8%8D%E8%83%BD%E8%90%BD%E4%B8%8B/"/>
    <id>http://akira.wang/2018.4.23 leetcode 即便是慵懒的星期一，也不能落下/</id>
    <published>2018-04-23T16:03:52.243Z</published>
    <updated>2018-04-23T16:36:36.224Z</updated>
    
    <content type="html"><![CDATA[<p>今天做的三题easy竟然没百度…也没看disscuss</p><h1 id="2018-4-23"><a href="#2018-4-23" class="headerlink" title="2018.4.23"></a>2018.4.23</h1><h2 id="Array-747-Largest-Number-At-Least-Twice-of-Others"><a href="#Array-747-Largest-Number-At-Least-Twice-of-Others" class="headerlink" title="Array - 747. Largest Number At Least Twice of Others"></a>Array - 747. Largest Number At Least Twice of Others</h2><h3 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>In a given integer array nums, there is always exactly one largest element.</p><p>Find whether the largest element in the array is at least twice as much as every other number in the array.</p><p>If it is, return the index of the largest element, otherwise return -1.</p><p>在给定的整数数组中nums，只有一个最大的元素。</p><p>查找数组中有没元素是这个最大值的两倍或者以上</p><p>如果有，则返回最大元素的索引，否则返回-1。</p></blockquote><p>Example:</p><p>Input: nums = [3, 6, 1, 0]</p><p>Output: 1</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>很简单，找到前两最大值，再进行比较即可</li></ul><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var dominantIndex = function(nums) &#123;</div><div class="line">    let max1 = max2 = maxIndex =  0</div><div class="line">    for(let i = 0; i &lt; nums.length; i++) &#123;</div><div class="line">        if(nums[i] &gt; max2) &#123;</div><div class="line">            max2 = Math.min(nums[i],max1)</div><div class="line">            if(nums[i] &gt; max1) &#123;</div><div class="line">                max1 = nums[i]</div><div class="line">                maxIndex = i</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return max1 / max2 &gt;= 2 ? maxIndex : -1</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="Array-283-Move-Zeroes"><a href="#Array-283-Move-Zeroes" class="headerlink" title="Array - 283. Move Zeroes"></a>Array - 283. Move Zeroes</h2><h3 id="题目详情-1"><a href="#题目详情-1" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).</p><p>找出数组中最长连续增加子序列的长度</p></blockquote><p>Example1:</p><p>Input: [1,3,5,4,7]</p><p>Output: 3</p><p>Explanation: 最长连续增加子序列为[1,3,5]，其长度为3.</p><p>Example2:</p><p>Input: [2,2,2,2,2]</p><p>Output: 1</p><p>Explanation: 最长连续增长子序列为[2]，其长度为1。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>遍历的时候判断当前元素是否大于前一个元素，</li><li></li></ul><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; nums</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line">var findLengthOfLCIS = function(nums) &#123;</div><div class="line">    if(nums.length === 0) return 0</div><div class="line">    let maxContLen = currContLen = 1</div><div class="line">    for(let i = 1, len = nums.length; i &lt; len; i++) &#123;</div><div class="line">        if(nums[i] &lt;= nums[i-1]) &#123;</div><div class="line">            currContLen = 1</div><div class="line">        &#125; else if(nums[i] - nums[i-1] &gt; 0) &#123;</div><div class="line">            currContLen++</div><div class="line">            maxContLen = Math.max(currContLen, maxContLen)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return maxContLen</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="Array-724-Find-Pivot-Index"><a href="#Array-724-Find-Pivot-Index" class="headerlink" title="Array - 724. Find Pivot Index"></a>Array - 724. Find Pivot Index</h2><h3 id="题目详情-2"><a href="#题目详情-2" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>Given an array of integers nums, write a method that returns the “pivot” index of this array.</p><p>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</p><p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p><p>给定一个数组，一找到元素左边求和等于元素右边求和的元素就返回他的索引，没有就返回-1</p></blockquote><p>Example:</p><p>Input: nums = [1, 7, 3, 6, 5, 6]</p><p>Output: 3</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>先把整个数组求和</li><li>再遍历一遍，一遍遍历一遍进行左边的求和，每次求和都判断总和减当前元素值和当前的左数组和 是否等于 左数组和</li></ul><h3 id="具体代码-2"><a href="#具体代码-2" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; nums</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line">var pivotIndex = function(nums) &#123;</div><div class="line">    let total = 0</div><div class="line">    for(let i = 0, len = nums.length; i &lt; len; i++) &#123;</div><div class="line">        total += nums[i]</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    let leftS = 0</div><div class="line">    for(let i = 0, len = nums.length; i &lt; len; i++) &#123;</div><div class="line">        if(total - leftS - nums[i] === leftS) &#123;</div><div class="line">            return i</div><div class="line">        &#125;</div><div class="line">        leftS += nums[i]</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    return -1</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天做的三题easy竟然没百度…也没看disscuss&lt;/p&gt;
&lt;h1 id=&quot;2018-4-23&quot;&gt;&lt;a href=&quot;#2018-4-23&quot; class=&quot;headerlink&quot; title=&quot;2018.4.23&quot;&gt;&lt;/a&gt;2018.4.23&lt;/h1&gt;&lt;h2 id=&quot;Ar
      
    
    </summary>
    
      <category term="算法" scheme="http://akira.wang/categories/algorithm/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Re0：从零开始的JavaScript - sort 踩坑记 &amp;&amp; 多条件排序</title>
    <link href="http://akira.wang/Re0%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84JavaScript%20-%20sort%20%E8%B8%A9%E5%9D%91%E8%AE%B0%20&amp;&amp;%20%E5%A4%9A%E6%9D%A1%E4%BB%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://akira.wang/Re0：从零开始的JavaScript - sort 踩坑记 &amp;&amp; 多条件排序/</id>
    <published>2018-04-23T16:03:43.466Z</published>
    <updated>2018-04-23T16:36:09.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多条件排序"><a href="#多条件排序" class="headerlink" title="多条件排序"></a>多条件排序</h1><p>有个这么个要求，给一组数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var data = [</div><div class="line">    &#123;a:1,b:2&#125;,</div><div class="line">    &#123;a:2,b:5&#125;,</div><div class="line">    &#123;a:3,b:4&#125;,</div><div class="line">    &#123;a:2,b:7&#125;,</div><div class="line">    &#123;a:1,b:2&#125;,</div><div class="line">    &#123;a:2,b:7&#125;,</div><div class="line">    &#123;a:4,b:8&#125;,</div><div class="line">    &#123;a:2,b:123&#125;,</div><div class="line">    &#123;a:5,b:23&#125;,</div><div class="line">]</div></pre></td></tr></table></figure><p>要求a从小到大排序，a相等的b从大到小排序</p><hr><p>首先实现属性a从小到大排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data.sort(function(a,b) &#123;</div><div class="line">    return a.a - b.a</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>接着继续掉调用把属性a排序好的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">data.sort(function(a,b) &#123;</div><div class="line">    return a.a - b.a</div><div class="line">&#125;).sort(function(a,b) &#123;</div><div class="line">    // 如果a属性相等则进行比较，否则不改变位置</div><div class="line">    if(a.a === b.a) &#123;</div><div class="line">        return b.b - a.b</div><div class="line">    &#125; else &#123;</div><div class="line">        return -1</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">console.log(data)</div></pre></td></tr></table></figure><p>打印一下，也没问题。本以为就这样能搞定的我，还是图样了。</p><p>当我把数组的元素增加多几个的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var data = [</div><div class="line">    &#123;a:1,b:2&#125;,</div><div class="line">    &#123;a:2,b:5&#125;,</div><div class="line">    &#123;a:3,b:4&#125;,</div><div class="line">    &#123;a:2,b:7&#125;,</div><div class="line">    &#123;a:1,b:2&#125;,</div><div class="line">    &#123;a:2,b:7&#125;,</div><div class="line">    &#123;a:4,b:8&#125;,</div><div class="line">    &#123;a:2,b:123&#125;,</div><div class="line">    &#123;a:5,b:23&#125;,</div><div class="line">    &#123;a:1,b:23&#125;,</div><div class="line">    &#123;a:2,b:55&#125;,</div><div class="line">    &#123;a:4,b:8&#125;,</div><div class="line">    &#123;a:2,b:12&#125;,</div><div class="line">    &#123;a:5,b:33&#125;,</div><div class="line">]</div></pre></td></tr></table></figure><p>问题就来了，使用上面的方法排序，完全得不到预想的结果。</p><p>这明明刚才还可以的怎么增加一点数据就完全变样了呢，所谓一言不合看源码。还真是有道理</p><p><a href="https://github.com/v8/v8/blob/master/src/js/array.js" target="_blank" rel="noopener">v8 array部分源码</a> （搜索“InnerArraySort”）</p><p>可以看到该方法首行就备注了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// In-place QuickSort algorithm.</div><div class="line">// For short (length &lt;= 10) arrays, insertion sort is used for efficiency.</div></pre></td></tr></table></figure></p><p><strong>V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数量小于10的数组使用 InsertionSort，比10大的数组则使用 QuickSort。</strong></p><p>快排不像插入排序，从后往前扫相邻的两个元素进行比较，而是找基准，遍历数组，小于基准的放在left，大于基准的放在right，递归</p><h2 id="修改后的方法"><a href="#修改后的方法" class="headerlink" title="修改后的方法"></a>修改后的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data.sort((a, b) =&gt; &#123;</div><div class="line">    return a.a === b.a ? ( a.b - b.b ) : a.a - b.b;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="封装一下"><a href="#封装一下" class="headerlink" title="封装一下"></a>封装一下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var by = function(name, minor)&#123;</div><div class="line">    return function(o, p) &#123;</div><div class="line">        var a, b;</div><div class="line">        a = o[name];</div><div class="line">        b = p[name];</div><div class="line">        if (a === b) &#123;</div><div class="line">            return typeof minor === &apos;function&apos; ? minor(o,p) : 0;</div><div class="line">        &#125;</div><div class="line">        if (typeof a === typeof b) &#123;</div><div class="line">            return a &lt; b ? -1 : 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">data.sort(by(&apos;age&apos;,by(&apos;sin&apos;)));</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多条件排序&quot;&gt;&lt;a href=&quot;#多条件排序&quot; class=&quot;headerlink&quot; title=&quot;多条件排序&quot;&gt;&lt;/a&gt;多条件排序&lt;/h1&gt;&lt;p&gt;有个这么个要求，给一组数组&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://akira.wang/categories/web/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2018.4.19 leetCode的夜路</title>
    <link href="http://akira.wang/2018.4.19%20leetCode%E7%9A%84%E5%A4%9C%E8%B7%AF/"/>
    <id>http://akira.wang/2018.4.19 leetCode的夜路/</id>
    <published>2018-04-19T15:09:40.256Z</published>
    <updated>2018-04-19T15:17:58.829Z</updated>
    
    <content type="html"><![CDATA[<p>今儿上班没时间刷，不过好在项目进度有很大进展。下班回来继续补，争取每天至少刷一题。喔！！~~</p><h1 id="2018-4-19-leetCode的夜路"><a href="#2018-4-19-leetCode的夜路" class="headerlink" title="2018.4.19 leetCode的夜路"></a>2018.4.19 leetCode的夜路</h1><h2 id="Array-217-Contains-Duplicate"><a href="#Array-217-Contains-Duplicate" class="headerlink" title="Array - 217. Contains Duplicate"></a>Array - 217. Contains Duplicate</h2><h3 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p><p>就是给一个数组，如果数组内有重复元素就返回true，否则返回false。</p></blockquote><p>Example:</p><p>Input: matrix = [0, 1, 0, 3, 12]</p><p>Output: true</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>太简单了，跟数组去重一样</li></ul><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; nums</div><div class="line"> * @return &#123;boolean&#125;</div><div class="line"> */</div><div class="line">var containsDuplicate = function(nums) &#123;</div><div class="line">    let obj = &#123;&#125;</div><div class="line">    for(let i = 0, len = nums.length; i &lt; len; i++) &#123;</div><div class="line">        if(obj[nums[i]])&#123;</div><div class="line">            return true</div><div class="line">        &#125; else &#123;</div><div class="line">            obj[nums[i]] = 1</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="Array-661-Image-Smootheroes"><a href="#Array-661-Image-Smootheroes" class="headerlink" title="Array - 661. Image Smootheroes"></a>Array - 661. Image Smootheroes</h2><h3 id="题目详情-1"><a href="#题目详情-1" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can.</p><p>题目给了我们一个2d M array，让我们平滑处理图片。对于每一个cell，把它更新为 以自身为中心 3x3 的平均值。</p><p>　　就用常规方法做，新设一个 长度跟传入数组一样大小的arr，遍历M，对于每一个cell， 遍历以它为中心的3x3的cells，得到平均值，存入arr。</p><p>　　需要注意的就是，3x3的边界问题。</p></blockquote><p>Example:</p><p>Input:<br>[[1,1,1],<br> [1,0,1],<br> [1,1,1]]</p><p>Output:<br>[[0, 0, 0],<br> [0, 0, 0],<br> [0, 0, 0]]</p><p>Explanation:</p><blockquote><p>For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0<br>For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0<br>For the point (1,1): floor(8/9) = floor(0.88888889) = 0</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>每个cell遍历周围方块</li></ul><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[][]&#125; M</div><div class="line"> * @return &#123;number[][]&#125;</div><div class="line"> */</div><div class="line">var imageSmoother = function(M) &#123;</div><div class="line">    let arr = Array.from(Array(M.length)).map(() =&gt; Array(M[0].length).fill(0))</div><div class="line">    let val = 0</div><div class="line">    let count = 0</div><div class="line">    </div><div class="line">    for(let i = 0, y = M.length; i &lt; y; i++) &#123;</div><div class="line">        for(let j = 0, x = M[0].length; j &lt; x; j++) &#123;</div><div class="line">            </div><div class="line">            for(let a = -1; a &lt; 2; a++) &#123;</div><div class="line">                for(let b = -1; b &lt; 2; b++) &#123;</div><div class="line">                    if(j + b &gt;= 0 &amp;&amp; i + a &gt;= 0 &amp;&amp; i + a &lt; M.length &amp;&amp; j + b &lt;  M[0].length ) &#123;</div><div class="line">                        val += M[i + a][j + b];</div><div class="line">                        count++</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            arr[i][j] = Math.floor(val/count)</div><div class="line">            val = 0</div><div class="line">            count = 0</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return arr</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今儿上班没时间刷，不过好在项目进度有很大进展。下班回来继续补，争取每天至少刷一题。喔！！~~&lt;/p&gt;
&lt;h1 id=&quot;2018-4-19-leetCode的夜路&quot;&gt;&lt;a href=&quot;#2018-4-19-leetCode的夜路&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="算法" scheme="http://akira.wang/categories/algorithm/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2018.4.18 继续刷几题</title>
    <link href="http://akira.wang/2018.4.18%20%E5%88%B7%E9%A2%98%E5%88%B7%E9%A2%98/"/>
    <id>http://akira.wang/2018.4.18 刷题刷题/</id>
    <published>2018-04-18T14:23:38.702Z</published>
    <updated>2018-04-19T13:35:35.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018-4-18"><a href="#2018-4-18" class="headerlink" title="2018.4.18"></a>2018.4.18</h1><h2 id="leetcode-485-Max-Consecutive-Ones"><a href="#leetcode-485-Max-Consecutive-Ones" class="headerlink" title="leetcode 485.Max Consecutive Ones"></a>leetcode 485.Max Consecutive Ones</h2><h3 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>Given a binary array, find the maximum number of consecutive 1s in this array.</p><p>就是求数组中连续1的个数最大是多少</p></blockquote><p>Example:</p><p>Input: [1,1,0,1,1,1]</p><p>Output: 3</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>用一个对象记录最大值和当前连续的值</li></ul><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; nums</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line">var findMaxConsecutiveOnes = function(nums) &#123;</div><div class="line">    let num = &#123; max:0, other:0 &#125;;</div><div class="line">    let len = nums.length;</div><div class="line">    for(var i = 0; i &lt; len; i++) &#123;</div><div class="line">        if(nums[i] === 1) &#123;</div><div class="line">            num.other ++</div><div class="line">        &#125; else if (nums[i] === 0) &#123;</div><div class="line">            num.other = 0</div><div class="line">        &#125;</div><div class="line">        num.max = Math.max(num.max, num.other)</div><div class="line">    &#125;</div><div class="line">    return num.max</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="leetcode-695-Max-Area-of-Island"><a href="#leetcode-695-Max-Area-of-Island" class="headerlink" title="leetcode 695. Max Area of Island"></a>leetcode 695. Max Area of Island</h2><h3 id="题目详情-1"><a href="#题目详情-1" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p></blockquote><p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)<br>&gt;</p><blockquote><p>给一个二维数组只有数组中0和1元素，求1的最大面积</p></blockquote><p>Example:</p><p>Input: [<br>    [1,1,0,0,0],<br>    [1,1,0,0,0],<br>    [0,0,0,1,1],<br>    [0,0,0,1,1]<br>]</p><p>Output: 4</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>DFS（深度优先搜索）</li><li>遍历2d array，遇到1的时候，就利用dfs把这个岛的区域大小找全。</li><li>在递归dfs之前，要把当前元素设为0，是为了避免dfs又往回走</li></ul><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[][]&#125; grid</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line"></div><div class="line">var maxAreaOfIsland = function(grid) &#123;</div><div class="line">    var h = grid.length;</div><div class="line">    var w = grid[0].length;</div><div class="line">    var max = 0;</div><div class="line">    </div><div class="line">    function dfs(i, j) &#123;</div><div class="line">        if(i &gt;= 0 &amp;&amp; i &lt; h &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; w) &#123;</div><div class="line">            if(grid[i][j] === 1) &#123;</div><div class="line">                grid[i][j] = 0</div><div class="line">                return</div><div class="line">                1 + </div><div class="line">                dfs( i + 1, j) + </div><div class="line">                dfs( i, j + 1) + </div><div class="line">                dfs( i - 1, j) + </div><div class="line">                dfs( i, j - 1)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return 0</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    for(var i = 0; i &lt; h; i++) &#123;</div><div class="line">        for(var j = 0; j &lt; w; j++) &#123;</div><div class="line">            if(grid[i][j] === 1) &#123;</div><div class="line">                max = Math.max(max, dfs(i, j))</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return max</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="leetCode-448-Find-All-Numbers-Disappeared-in-an-Array"><a href="#leetCode-448-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="leetCode 448. Find All Numbers Disappeared in an Array"></a>leetCode 448. Find All Numbers Disappeared in an Array</h2><h3 id="题目详情-2"><a href="#题目详情-2" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.<br>Find all the elements of [1, n] inclusive that do not appear in this array.<br>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p><p>用标志位的方法去做，把原数组中出现的数其应该所在的位置上置为负值，然后重新遍历如果大于0，则表示从未出现过</p></blockquote><p>Example:</p><p>Input:<br>[4,3,2,7,8,2,3,1]</p><p>Output:<br>[5,6]</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>首先第一次遍历，把出现了的元素对应的索引位置设为负值</li><li>第一遍历完之后数组是这样的[-4,-3,-2,-7,8,2,-3,-1]</li><li>只有第5个和第6个是正数，第二次遍历把大于0的下标+1添加进返回出去的数组</li></ul><h3 id="具体代码-2"><a href="#具体代码-2" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param &#123;number[]&#125; nums</div><div class="line"> * @return &#123;number[]&#125;</div><div class="line"> */</div><div class="line">var findDisappearedNumbers = function(nums) &#123;</div><div class="line">    let ret = []</div><div class="line">    let len = nums.length</div><div class="line">    for(let i = 0; i &lt; len; i++) &#123;</div><div class="line">        let val = Math.abs(nums[i]) - 1</div><div class="line">        if(nums[val] &gt; 0) &#123;</div><div class="line">            nums[val] = -nums[val]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    for(let i = 0; i &lt; len; i++) &#123;</div><div class="line">        if(nums[i] &gt; 0) &#123;</div><div class="line">            ret.push(i + 1)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return ret</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>2018.4.18 - End</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2018-4-18&quot;&gt;&lt;a href=&quot;#2018-4-18&quot; class=&quot;headerlink&quot; title=&quot;2018.4.18&quot;&gt;&lt;/a&gt;2018.4.18&lt;/h1&gt;&lt;h2 id=&quot;leetcode-485-Max-Consecutive-Ones&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="算法" scheme="http://akira.wang/categories/algorithm/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2018.4.17 元气满满的一天，适合刷题</title>
    <link href="http://akira.wang/2018.4.17%20%E5%85%83%E6%B0%94%E6%BB%A1%E6%BB%A1%E7%9A%84%E4%B8%80%E5%A4%A9%EF%BC%8C%E9%80%82%E5%90%88%E5%88%B7%E9%A2%98/"/>
    <id>http://akira.wang/2018.4.17 元气满满的一天，适合刷题/</id>
    <published>2018-04-18T14:23:38.698Z</published>
    <updated>2018-04-19T13:35:26.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018-4-17"><a href="#2018-4-17" class="headerlink" title="2018.4.17"></a>2018.4.17</h1><h2 id="leetcode-283-Move-Zeroes"><a href="#leetcode-283-Move-Zeroes" class="headerlink" title="leetcode 283. Move Zeroes"></a>leetcode 283. Move Zeroes</h2><h3 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p><p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p><p>大概意思就是，给你一个数组nums，操作数组变为 ‘0’ &gt; 都在数组最后。</p></blockquote><p>Example:</p><p>Input: matrix = [0, 1, 0, 3, 12]</p><p>Output: [1, 3, 12, 0, 0]</p><p>Explanation: [0,1,0,3,12] –&gt; [1,3,12,…] –&gt; [1,3,12,0,0,0]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>把非0项从后往前放，用个常量记录非0个数，遍历完在list后补0</li></ul><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var moveZeroes = function(nums) &#123;</div><div class="line">    let pos = 0;</div><div class="line">    for(let i = 0; i &lt; nums.length ; i++) &#123;</div><div class="line">        if(nums[i] !== 0) &#123;</div><div class="line">            nums[pos] = nums[i]</div><div class="line">            pos++</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    for(; pos &lt; nums.length; pos++) &#123;</div><div class="line">        nums[pos] = 0</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="leetcode-268-Missing-Number"><a href="#leetcode-268-Missing-Number" class="headerlink" title="leetcode 268. Missing Number"></a>leetcode 268. Missing Number</h2><h3 id="题目详情-1"><a href="#题目详情-1" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p><p>他会给一个缺一个数的等差数列为1的顺序数组，求缺少的元素</p></blockquote><p>Example 1:</p><p>Input: [1,0,3]</p><p>Output: 2</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>最直观的一个方法是用等差数列的求和公式求出0到n之间所有的数字之和</li><li>然后再遍历数组算出给定数字的累积和</li><li>然后做减法，差值就是丢失的那个数字</li></ul><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var missingNumber = function(nums) &#123;</div><div class="line">    let len = nums.length</div><div class="line">    let sum = 0</div><div class="line">    for(let i = 0; i &lt; len; i++) &#123;</div><div class="line">        sum += nums[i]</div><div class="line">    &#125;</div><div class="line">    return 0.5 * len * (len + 1) - sum</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="leetcode-766-Toeplitz-Matrix"><a href="#leetcode-766-Toeplitz-Matrix" class="headerlink" title="leetcode 766. Toeplitz Matrix"></a>leetcode 766. Toeplitz Matrix</h2><h3 id="题目详情-2"><a href="#题目详情-2" class="headerlink" title="题目详情"></a>题目详情</h3><blockquote><p>A matrix is Toeplitz if every diagonal from top-left to &gt;bottom-right has the same element.</p><p>Now given an M x N matrix, return True if and only if the matrix is Toeplitz.</p><p>如果一个矩阵的每一条斜对角线（左上到右下）上的元素都相等，则我们称它为托普利兹矩阵。现在输入一个M*N大小的矩阵，如果它是一个托普利兹矩阵，则返回true，如果不是，返回false。</p></blockquote><p>Example 1:</p><p>Input: matrix = [</p><pre><code>[3,2,1,5],[7,3,2,1],[4,7,3,2]</code></pre><p>]</p><p>Output: True</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>遍历每一个元素，比较这个元素和它右下角元素的值是否相等，如果不相等，直接返回false，停止遍历。</li></ul><h3 id="具体代码-2"><a href="#具体代码-2" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var isToeplitzMatrix = function(arr) &#123;</div><div class="line">    var m = arr[0].length -1;</div><div class="line">    var n = arr.length-1;</div><div class="line">    for(var i = 0; i &lt; n; i++) &#123;</div><div class="line">        for(var j = 0; j &lt;m; j++) &#123;</div><div class="line">            if(arr[i][j] != arr[i+1][j+1]) &#123;</div><div class="line">                return false</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return true</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>2018.4.17 – End</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2018-4-17&quot;&gt;&lt;a href=&quot;#2018-4-17&quot; class=&quot;headerlink&quot; title=&quot;2018.4.17&quot;&gt;&lt;/a&gt;2018.4.17&lt;/h1&gt;&lt;h2 id=&quot;leetcode-283-Move-Zeroes&quot;&gt;&lt;a href=&quot;#l
      
    
    </summary>
    
      <category term="算法" scheme="http://akira.wang/categories/algorithm/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>老生常谈 输入url到页面加载显示完成，中间都经历了什么 &amp;&amp; 浏览器缓存解析</title>
    <link href="http://akira.wang/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88%20%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E5%AE%8C%E6%88%90%EF%BC%8C%E4%B8%AD%E9%97%B4%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%20&amp;&amp;%20%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%A7%A3%E6%9E%90/"/>
    <id>http://akira.wang/老生常谈 输入url到页面加载显示完成，中间都经历了什么 &amp;&amp; 浏览器缓存解析/</id>
    <published>2018-03-05T15:00:34.682Z</published>
    <updated>2018-03-05T15:03:28.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h2><ol><li>输入url  -Enter</li><li>浏览器先查看 浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示内容。若没有则跳到第三步操作</li><li>DNS解析，获取相应的IP地址</li><li>浏览器向服务器发起TCP连接，与浏览器建立TCP三次握手。</li><li>握手成功后，浏览器向服务器发送http请求，请求数据</li><li>服务器收到请求，将数据发送至浏览器</li><li>浏览器接受响应</li><li>读取页面内容，浏览器渲染，解析html源码</li><li>生成dom树，css树，js解析</li><li>客户端和服务器交互</li><li>ajax请求</li></ol><h2 id="过程2解析（彻底理解浏览器缓存机制）"><a href="#过程2解析（彻底理解浏览器缓存机制）" class="headerlink" title="过程2解析（彻底理解浏览器缓存机制）"></a>过程2解析（彻底理解浏览器缓存机制）</h2><p><img src="https://images2017.cnblogs.com/blog/621603/201709/621603-20170926102324948-838899513.png" alt="image"></p><h3 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h3><ul><li>强缓存</li></ul><p>用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。</p><ul><li>协商缓存</li></ul><p>用户发送的请求，发送到服务器后，由浏览器判断是否从缓存中获取资源。</p><h3 id="图中四个过程浅析"><a href="#图中四个过程浅析" class="headerlink" title="图中四个过程浅析"></a>图中四个过程浅析</h3><h4 id="（a）浏览器判定是否有缓存"><a href="#（a）浏览器判定是否有缓存" class="headerlink" title="（a）浏览器判定是否有缓存"></a>（a）浏览器判定是否有缓存</h4><p>所谓“客户端缓存”就是指用户本地资源。不同浏览器缓存文件的地址也不尽相同。</p><p>进入chrome://cache页面，里面的每一项都是缓存</p><p>随便点一个资源，可以看到：<br><img src="https://images2017.cnblogs.com/blog/621603/201709/621603-20170925142617870-47312521.png" alt="image"></p><p>回到问题，浏览器怎么判定是否有缓存，就可以转化为浏览器去读取本地放缓存的地方（注：不同浏览器不同系统都会不同）是否有该对应的请求啦。</p><blockquote><p>总结来说就是个查找文件是否存在的问题。</p></blockquote><h4 id="（b）缓存是否过期"><a href="#（b）缓存是否过期" class="headerlink" title="（b）缓存是否过期"></a>（b）缓存是否过期</h4><p><img src="https://images2017.cnblogs.com/blog/621603/201709/621603-20170925143850526-746597755.png" alt="image"></p><p>我们再以这张图为例，这张图中表明，客户端保留了一个服务器端的response header。<br>里面的Date字段表明此次缓存时服务器的时间。<br>里面有两个字段：expires 、Cache-Control</p><ul><li>expires</li></ul><p>Http1.0 中的标准，表明过期时间，注意此处的时间都是指的是服务器的时间。<br>可以看到过期时间被设定为了：Thu, 28 Sep 2017 06:38:37 GMT</p><p>存在的问题：服务器时间与客户端时间的不一致，就会导致缓存跟期待效果出现偏差。</p><ul><li>Cache-Control</li></ul><p>Http1.1 中的标准，可以看成是 expires 的补充。使用的是相对时间的概念。<br>简单介绍下Cache-Control的属性设置。</p><ol><li><p>max-age: 设置缓存的最大的有效时间，单位为秒（s）。max-age会覆盖掉Expires</p></li><li><p>s-maxage: 只用于共享缓存，比如CDN缓存（s -&gt; share）。与max-age的区别是：max-age用于普通缓存，而s-maxage用于代理缓存。如果存在s-maxage,则会覆盖max-age 和 Expires.</p></li><li><p>public：响应会被缓存，并且在多用户间共享。默认是public。</p></li><li>private: 响应只作为私有的缓存，不能在用户间共享。如果要求HTTP认证，响应会自动设置为private。</li><li>no-cache: 指定不缓存响应，表明资源不进行缓存。但是设置了no-cache之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间。</li><li>no-store: 绝对禁止缓存。</li><li>must-revalidate: 如果页面过期，则去服务器进行获取。</li></ol><p>所以判断缓存是否过期步骤是：</p><ol><li><p>查看是否有cache-control 的max-age / s-maxage , 如果有，则用服务器时间date值 + max-age/s-maxage的秒数计算出新的过期时间，将当前时间与过期时间进行比较，判断是否过期</p></li><li><p>查看是否有cache-control 的max-age / s-maxage，则用expires 作为过期时间比较</p></li></ol><blockquote><p>总结：（b）过程执行完后，如果判定为未过期，则使用客户端缓存。那么就是属于“强缓存”。</p></blockquote><h4 id="（c）跟服务器协商是否使用缓存"><a href="#（c）跟服务器协商是否使用缓存" class="headerlink" title="（c）跟服务器协商是否使用缓存"></a>（c）跟服务器协商是否使用缓存</h4><p><img src="https://images2017.cnblogs.com/blog/621603/201709/621603-20170925160222510-1108792969.png" alt="image"></p><p>到这一步的时候，浏览器会向服务器发送请求，同时如果上一次的缓存中有Last-modified 和 Etag 字段，<br>浏览器将在request header 中加入If-Modified-Since（对应于Last-modified）， 和If-None-Match（对应于Etag）。</p><ul><li>Last-modified: 表明请求的资源上次的修改时间。</li><li>If-Modified-Since：客户端保留的资源上次的修改时间。</li><li>Etag：资源的内容标识。（不唯一，通常为文件的md5或者一段hash值，只要保证写入和验证时的方法一致即可）</li><li>If-None-Match： 客户端保留的资源内容标识。</li></ul><blockquote><p>通常情况下，如果同时发送 If-None-Match 、If-Modified-Since字段，服务器只要比较etag 的内容即可，当然具体处理方式，看服务器的约定规则。</p></blockquote><h4 id="（d）协商缓存"><a href="#（d）协商缓存" class="headerlink" title="（d）协商缓存"></a>（d）协商缓存</h4><p>在这个阶段，服务器一般会将Cache-control、expires 、last-modified、date、etag 等字段在response header 中返回，便于下次缓存。当然具体的场景，也是看服务器的约定规则设定。</p><h4 id="用户行为"><a href="#用户行为" class="headerlink" title="用户行为"></a>用户行为</h4><p>最后附上一张，用户行为影响浏览器的缓存行为。</p><p><img src="https://images2017.cnblogs.com/blog/621603/201709/621603-20170925162600417-90375901.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本过程&quot;&gt;&lt;a href=&quot;#基本过程&quot; class=&quot;headerlink&quot; title=&quot;基本过程&quot;&gt;&lt;/a&gt;基本过程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;输入url  -Enter&lt;/li&gt;
&lt;li&gt;浏览器先查看 浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直
      
    
    </summary>
    
      <category term="前端" scheme="http://akira.wang/categories/web/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Re0：从零开始的JavaScript - 函数式编程之柯里化</title>
    <link href="http://akira.wang/Re0%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84JavaScript%20-%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>http://akira.wang/Re0：从零开始的JavaScript - 函数式编程之柯里化/</id>
    <published>2018-03-05T15:00:33.025Z</published>
    <updated>2018-03-05T15:03:08.445Z</updated>
    
    <content type="html"><![CDATA[<p>之前也有了解过柯里化。可是，在实际开发中，对柯里化的运用不是太多，因为不太清楚应该在哪些情况下应该使用它们。</p><p>看了ES6入门，看到了函数式编程，现在又再回来复习一下柯里化</p><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2776707119,3878134448&amp;fm=27&amp;gp=0.jpg" alt="image"></p><h1 id="柯里化-Curry"><a href="#柯里化-Curry" class="headerlink" title="柯里化 Curry"></a>柯里化 Curry</h1><p>柯里化就是在特定的作用域中执行指定的函数,并只传递函数的一部分参数来调用它，返回一个函数去处理剩下的参数。</p><h2 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h2><p>先来看个例子，创建一个 say 函数，打印出带有名字，前缀和问候语的一句话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const say = (name, prefix, greeting) =&gt; `$&#123;greeting&#125;, $&#123;prefix&#125; $&#123;name&#125;!`;</div><div class="line"></div><div class="line">say(&apos;Tom&apos;, &apos;Mr&apos;, &apos;Hello&apos;); // &quot;Hello, Mr Tom&quot;</div><div class="line">say(&apos;James&apos;, &apos;Mr&apos;, &apos;Hello&apos;); // &quot;Hello, Mr James&quot;</div></pre></td></tr></table></figure><p>在上面的例子中，我们每一次调用 say 函数都必须传入完整的三个参数，才能保证正确的运行结果，否则，虽然程序还是会正常运行，可是未传入的部分会变成 undefined。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const say = greeting =&gt; prefix =&gt; name =&gt; `$&#123;greeting&#125;, $&#123;prefix&#125; $&#123;name&#125;!`;</div></pre></td></tr></table></figure><blockquote><p>Tip：上面say函数相当于ES5写法的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function say(greeting) &#123;</div><div class="line">  return function (prefix) &#123;</div><div class="line">    return function (name) &#123;</div><div class="line">      return greeting + &apos;, &apos; + prefix + &apos; &apos; + name + &apos;!&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></blockquote><p>然后就可以随意组合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const greet = say(&apos;Hello&apos;);</div><div class="line">const greetMeiNv = greet(&apos;美女&apos;);</div><div class="line">const greetShuaiGe = greet(&apos;帅哥&apos;);</div><div class="line"></div><div class="line">greetShuaiGe(&apos;Tom&apos;); // &quot;Hello, 帅哥 Tom!&quot;</div><div class="line">greetMeiNv(&apos;Cindy&apos;); // &quot;Hello, 美女 Cindy!&quot;</div></pre></td></tr></table></figure><blockquote><p>Tip： 在使用柯里化的时候，参数的顺序很重要，可以考虑根据易变化的程度来排列参数，把不容易变化的参数通过柯里化固定起来，将需要处理的参数放到最后一位。</p></blockquote><h2 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h2><p>上面例子我们每次调用函数都只传入了一个参数</p><p>如果我想固定Hello 帅哥 ，前两个参数，那么第一行的函数就显得有点多余。</p><p>如果有100个参数，那不就要创建100个函数一个参数一个参数的传进去调用？这样不仅麻烦，而且每个函数产生的闭包都会占用内存，那么如果我想让函数这样传参能够执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const curriedSay = curry(say); // 把函数柯里化</div><div class="line">curriedSay(&apos;Tom&apos;, &apos;帅哥&apos;, &apos;Hello&apos;); // &quot;Hello, 帅哥 Tom!&quot;</div><div class="line"></div><div class="line">const curriedSay2 = curry(say,&apos;Tom&apos;,&apos;帅哥&apos;)</div><div class="line">curriedSay2(&apos;Hey&apos;);  // &quot;Hey, 帅哥 Tom!&quot;</div></pre></td></tr></table></figure><p>这样纸，就可以让你养成拆分函数，并给函数良好命名的习惯，以及更好的处理和抽象代码的逻辑。</p><p>那么curry函数是怎么实现的呢？</p><p>首先要修改say函数 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const say = (name, prefix, greeting) =&gt; `$&#123;greeting&#125;, $&#123;prefix&#125; $&#123;name&#125;!`;</div></pre></td></tr></table></figure><p>那么curry函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function curry(fn) &#123;</div><div class="line">  let outerArgs = Array.prototype.slice.call(arguments, 1);</div><div class="line">  </div><div class="line">  return function() &#123;</div><div class="line">    let innerArgs = Array.prototype.slice.call(arguments),</div><div class="line">      finalArgs = [...outerArgs,...innerArgs];</div><div class="line">    return fn.apply(null, finalArgs);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li><p>首先第一个参数是传入的函数。并获取函数后面，想要固定参数，转换成数组赋值到变量outerArgs。</p></li><li><p>返回的函数中，获取非固定参数赋值给变量innerArgs，并把转换成数组赋值到变量outerArgs和innerArgs合并起来，一起传入到被柯里化的函数执行</p></li><li><p>返回的函数中有对outerArgs的引用，所以后面使用curry，也不会改变outerArgs的值，</p></li></ol><h1 id="参与者模式"><a href="#参与者模式" class="headerlink" title="参与者模式"></a>参与者模式</h1><p>参与者模式说白了，也就是给被柯里化的函数绑定this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function curryBind(fn,context) &#123;</div><div class="line">  var outerArgs = Array.prototype.slice.call(arguments, 2);</div><div class="line">  </div><div class="line">  return function() &#123;</div><div class="line">    var innerArgs = Array.prototype.slice.call(arguments),</div><div class="line">      finalArgs = [...outerArgs,...innerArgs]</div><div class="line">    return fn.apply(context, finalArgs);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为，函数最少要接受两个参数  被柯里化的函数 和 绑定对象</p><p>所以，outerArgs要从第三个参数开始截取</p><p>把apply中第一个参数的null改成context即可</p><h2 id="Ramda-Lodash"><a href="#Ramda-Lodash" class="headerlink" title="Ramda / Lodash"></a>Ramda / Lodash</h2><p>查阅资料发现还有专门柯里化函数的库，Ramda / Lodash</p><p><a href="http://ramda.cn/docs/" target="_blank" rel="noopener">Ramda中文文档</a></p><p><a href="http://www.css88.com/doc/lodash/" target="_blank" rel="noopener">Lodash中文文档</a></p><p>有兴趣的童鞋，可以前去阅读</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1520271908743&amp;di=c89623d4474514f028fef119d229c1a9&amp;imgtype=0&amp;src=http%3A%2F%2Fimg3.duitang.com%2Fuploads%2Fblog%2F201608%2F17%2F20160817202606_hftyG.jpeg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前也有了解过柯里化。可是，在实际开发中，对柯里化的运用不是太多，因为不太清楚应该在哪些情况下应该使用它们。&lt;/p&gt;
&lt;p&gt;看了ES6入门，看到了函数式编程，现在又再回来复习一下柯里化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ss3.bdstatic.com/70
      
    
    </summary>
    
      <category term="前端" scheme="http://akira.wang/categories/web/"/>
    
    
      <category term="JavaScript" scheme="http://akira.wang/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>小明同学的 二〇一七 总结 &amp;&amp; 二〇一八 展望（FLAG）</title>
    <link href="http://akira.wang/%E5%B0%8F%E6%98%8E%E5%90%8C%E5%AD%A6%E7%9A%84%20%E4%BA%8C%E3%80%87%E4%B8%80%E4%B8%83%20%E6%80%BB%E7%BB%93%20&amp;&amp;%20%E4%BA%8C%E3%80%87%E4%B8%80%E5%85%AB%20%E5%B1%95%E6%9C%9B%EF%BC%88FLAG%EF%BC%89/"/>
    <id>http://akira.wang/小明同学的 二〇一七 总结 &amp;&amp; 二〇一八 展望（FLAG）/</id>
    <published>2018-02-15T03:31:59.018Z</published>
    <updated>2018-02-15T06:30:53.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二零一七小总结"><a href="#二零一七小总结" class="headerlink" title="二零一七小总结"></a>二零一七小总结</h1><p><img src="/images/2017summary/fengmian.jpg" alt="image"></p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h3><p>2017的一年是个人成长的最快的一年，各种事情都尝试了，尽量不给自己留下遗憾。时不时会迷茫，但很清楚的自己想要的事物，并在为之付诸努力。</p><p>这一年过的都很充实，上半年基本上都在宿舍coding（这就是所谓的充实）。下半年吃鸡火了，偶尔会跟朋友去网吧通个宵什么的。开黑吗？我正义之枪从不失手。</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1519267964&amp;di=cc78e4867ee5d04a8326b8e54e6c140d&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fpic.962.net%2Fup%2F2017-9%2F15059580304024915.jpg" alt="image"></p><h3 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h3><p>年初经历了所谓的大起大落。对真物依旧热切与渴望，可是不再像以前一样冲动，而是多了几分理性。</p><p>刚看了《神秘巨星》，仔细想想还是老妈子好。</p><h3 id="毕业季"><a href="#毕业季" class="headerlink" title="毕业季"></a>毕业季</h3><p><img src="/images/2017summary/people.jpg" alt="image"></p><h2 id="足迹"><a href="#足迹" class="headerlink" title="足迹"></a>足迹</h2><ul><li>韶关 - 丹霞山</li></ul><p>离学校挺近的，就去了这儿玩一下。不过出门游玩什么的，还是太累了</p><p><img src="http://pic.k73.com/up/soft/2016/0901/112612_96424399.jpg" alt="image"></p><ul><li>北京</li></ul><p>从零开始的帝都实习生活</p><p><img src="/images/2017summary/dalao.jpg" alt="image"><br>（两位大佬）</p><p>找工作还算顺利，好吧，只是被内推的。所以说，机会是给有准备的人的，而且刚好是我姐也在北京这，生活上也算有个照应。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>由于coding要大量时间学习，MAD也基本上挤不出时间做。</p><p><a href="https://www.bilibili.com/video/av12029223/" target="_blank" rel="noopener">【ASMV / 再忆四月】- 落樱薰香，惘然一梦 -</a></p><p>一年就做了一个，hahaha…</p><p><img src="https://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/ae51f3deb48f8c54dbacb21338292df5e0fe7f8a.jpg" alt="image"></p><p>2018年尽量产多点视频，做不了大牛没关系，做好自己最重要嘛~</p><p>（来个收藏+关注呗）</p><h1 id="展望二〇一八"><a href="#展望二〇一八" class="headerlink" title="展望二〇一八"></a>展望二〇一八</h1><p>最后列出一下2018年的目标：</p><ul><li>提升coding质量，学习技术，学会造轮子</li><li>毕业后能主要从事Node方面工作</li><li>带着老妈在国内有名的景点游玩一次</li><li>尽量做视频</li><li>去漫展撩小姐姐</li><li>入手 PS4 Pro 玩 怪物猎人世界</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二零一七小总结&quot;&gt;&lt;a href=&quot;#二零一七小总结&quot; class=&quot;headerlink&quot; title=&quot;二零一七小总结&quot;&gt;&lt;/a&gt;二零一七小总结&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/2017summary/fengmian.jpg&quot; alt=&quot;i
      
    
    </summary>
    
      <category term="生活" scheme="http://akira.wang/categories/life/"/>
    
    
      <category term="日常" scheme="http://akira.wang/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
</feed>
