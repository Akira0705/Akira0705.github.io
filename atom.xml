<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Akira</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-15T03:37:44.611Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Akira</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小明同学的 二〇一七 总结 &amp;&amp; 二〇一八 展望（FLAG）</title>
    <link href="http://yoursite.com/2018/02/15/%E5%B0%8F%E6%98%8E%E5%90%8C%E5%AD%A6%E7%9A%84%20%E4%BA%8C%E3%80%87%E4%B8%80%E4%B8%83%20%E6%80%BB%E7%BB%93%20&amp;&amp;%20%E4%BA%8C%E3%80%87%E4%B8%80%E5%85%AB%20%E5%B1%95%E6%9C%9B%EF%BC%88FLAG%EF%BC%89/"/>
    <id>http://yoursite.com/2018/02/15/小明同学的 二〇一七 总结 &amp;&amp; 二〇一八 展望（FLAG）/</id>
    <published>2018-02-15T03:31:59.018Z</published>
    <updated>2018-02-15T03:37:44.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二零一七小总结"><a href="#二零一七小总结" class="headerlink" title="二零一七小总结"></a>二零一七小总结</h1><p><img src="/images/2017summary/fengmian.jpg" alt="image"></p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h3><p>2017的一年是个人成长的最快的一年，各种事情都尝试了，尽量不给自己留下遗憾。时不时会迷茫，但很清楚的自己想要的事物，并在为之付诸努力。</p><p>这一年过的都很充实，上半年基本上都在宿舍coding（这就是所谓的充实）。下半年吃鸡火了，偶尔会跟朋友去网吧通个宵什么的。开黑吗？我正义之枪从不失手。</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1519267964&amp;di=cc78e4867ee5d04a8326b8e54e6c140d&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fpic.962.net%2Fup%2F2017-9%2F15059580304024915.jpg" alt="image"></p><h3 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h3><p>经历了所谓的大起大落。对真物依旧热切与渴望，可是不再像以前一样冲动。</p><p>刚看了《神秘巨星》，仔细想想还是老妈子好。</p><h3 id="毕业季"><a href="#毕业季" class="headerlink" title="毕业季"></a>毕业季</h3><p><img src="/images/2017summary/people.jpg" alt="image"></p><h2 id="足迹"><a href="#足迹" class="headerlink" title="足迹"></a>足迹</h2><ul><li>韶关 - 丹霞山</li></ul><p>离学校挺近的，就去了这儿玩一下。不过出门游玩什么的，还是太累了</p><p><img src="http://pic.k73.com/up/soft/2016/0901/112612_96424399.jpg" alt="image"></p><ul><li>北京</li></ul><p>从零开始的帝都实习生活</p><p><img src="/images/2017summary/dalao.jpg" alt="image"><br>（两位大佬）</p><p>找工作还算顺利，好吧，只是被内推的。所以说，机会是给有准备的人的，而且刚好是我姐也在北京这，生活上也算有个照应。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>由于coding要大量时间学习，MAD也基本上挤不出时间做。</p><p><a href="https://www.bilibili.com/video/av12029223/" target="_blank" rel="external">【ASMV / 再忆四月】- 落樱薰香，惘然一梦 -</a></p><p>一年就做了一个，hahaha…</p><p><img src="https://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/ae51f3deb48f8c54dbacb21338292df5e0fe7f8a.jpg" alt="image"></p><p>（来个收藏+关注呗）</p><h1 id="展望二〇一八"><a href="#展望二〇一八" class="headerlink" title="展望二〇一八"></a>展望二〇一八</h1><p>最后列出一下2018年的目标：</p><ul><li>提升coding质量，学习技术，学会造轮子</li><li>毕业后能主要从事Node方面工作</li><li>带着老妈在国内有名的景点游玩一次</li><li>能做两个 MAD</li><li>入手 PS4 Pro</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二零一七小总结&quot;&gt;&lt;a href=&quot;#二零一七小总结&quot; class=&quot;headerlink&quot; title=&quot;二零一七小总结&quot;&gt;&lt;/a&gt;二零一七小总结&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/2017summary/fengmian.jpg&quot; alt=&quot;i
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日常" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Re0：从零开始的JavaScript - 浅谈 Promise 实现</title>
    <link href="http://yoursite.com/2018/02/08/%E6%B5%85%E8%B0%88%20Promise%20%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/02/08/浅谈 Promise 实现/</id>
    <published>2018-02-08T13:08:18.214Z</published>
    <updated>2018-02-08T13:07:41.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不知道Promise是啥的，请看上一篇《异步流程控制》</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1518104916999&amp;di=94b7d10517a6ca51f49b11685b9e72ae&amp;imgtype=0&amp;src=http%3A%2F%2F0.pic.9ht.com%2Fthumb%2Fup%2F2016-7%2F14691557622361722_600_566.jpg" alt="image"></p><p>看了不少Prmose实现的资料，目前的理解就是Promise也就是回调的一种优雅实现。</p><p>现在Javascript的重心都放在了async-await，而async-await是建立在Promise之上的，所以深入一下Promise，还是很有必要的。</p><h1 id="实现功能分析"><a href="#实现功能分析" class="headerlink" title="实现功能分析"></a>实现功能分析</h1><p>原生Promise<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">new Promise(function (resolve,reject)&#123;</div><div class="line">    </div><div class="line">    setTimeout(function ()&#123;</div><div class="line">        console.log(1)</div><div class="line">        resolve(2)</div><div class="line">    &#125;,1000)</div><div class="line"></div><div class="line">&#125;).then(function (val)&#123;</div><div class="line"></div><div class="line">    setTimeout(function ()&#123;</div><div class="line">        console.log(&apos;2:&apos;+val)</div><div class="line">    &#125;,1000)</div><div class="line"></div><div class="line">&#125;).then(function (val)&#123;</div><div class="line"></div><div class="line">    setTimeout(function ()&#123;</div><div class="line">        console.log(&apos;3:&apos;+val)</div><div class="line">    &#125;,1000)</div><div class="line"></div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 1</div><div class="line">// 2:2</div><div class="line">// 3:und</div></pre></td></tr></table></figure></p><h1 id="开始实现"><a href="#开始实现" class="headerlink" title="开始实现"></a>开始实现</h1><p><img src="http://img2.biaoqingjia.com/biaoqing/201607/3f2690479687e671fcc2b2a70c185e8c.gif" alt="image"></p><p>创建一个_promise函数，由简到繁</p><h2 id="简单功能"><a href="#简单功能" class="headerlink" title="简单功能"></a>简单功能</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码:"></a>源码:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function _promise(fn)&#123;</div><div class="line">  //resolve时的回调</div><div class="line">  var callback;</div><div class="line">  </div><div class="line">  //一个实例的方法，用来注册异步事件</div><div class="line">  this.then = function(done)&#123;</div><div class="line">    callback = done;</div><div class="line">  &#125;</div><div class="line">  function resolve(val)&#123;</div><div class="line">    callback(val);</div><div class="line">  &#125;</div><div class="line">  fn(resolve);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">new _promise(function (resolve)&#123;</div><div class="line"></div><div class="line">    setTimeout(function ()&#123;</div><div class="line">        console.log(1)</div><div class="line">        resolve(2)</div><div class="line">    &#125;,1000)</div><div class="line"></div><div class="line">&#125;).then(function (val)&#123;</div><div class="line"></div><div class="line">    setTimeout(function ()&#123;</div><div class="line">        console.log(&apos;2:&apos;+val)</div><div class="line">    &#125;,1000)</div><div class="line"></div><div class="line">&#125;)</div><div class="line">// 1</div><div class="line">// 2:2</div></pre></td></tr></table></figure><h3 id="步骤分析："><a href="#步骤分析：" class="headerlink" title="步骤分析："></a>步骤分析：</h3><ol><li>传入fn执行，并调用then方法传入异步执行完毕后的函数赋值给Promise内部的callback</li><li>Promise内部fn执行并将resolve函数作为参数传入</li><li>fn执行到成功位置，执行resolve函数并传入成功值(val)</li><li>resolve函数执行回调callback并传入成功值</li></ol><hr><h2 id="链式支持"><a href="#链式支持" class="headerlink" title="链式支持"></a>链式支持</h2><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><p>在then中返回this，并把then的回调存放到$resolve数组中，执行resolve使用forEach依次调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function _promise(fn)&#123;</div><div class="line">    // resolve时的回调</div><div class="line">    var promise = this,</div><div class="line">        value = null,</div><div class="line">        promise.$resolve = [] // 存放需要调用的函数</div><div class="line"></div><div class="line">    //  返回this，支持链式调用</div><div class="line">    this.then = function (onFulfilled)&#123;</div><div class="line">        promise.$resolve.push(onFulfilled)</div><div class="line">        return this</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 成功回调，把$resolve存放的函数依次执行</div><div class="line">    function resolve(value)&#123;</div><div class="line">        promise.$resolve.forEach(function (callback)&#123;</div><div class="line">            callback(value)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fn(resolve)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可是如果then中的传入函数是同步的话，就无法控制回调执行顺序</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">new _promise(function (resolve)&#123;</div><div class="line">    </div><div class="line">    for(var i = 0,num; i &lt; 1000;i++)&#123;</div><div class="line">        num=Math.random()*100</div><div class="line">    &#125;</div><div class="line">    console.log(1)</div><div class="line">    resolve(2)</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;).then(function (val)&#123;</div><div class="line"></div><div class="line">    setTimeout(function ()&#123;</div><div class="line">        console.log(&apos;2:&apos;+val)</div><div class="line">    &#125;,1000)</div><div class="line">        </div><div class="line"></div><div class="line">&#125;).then(function (val)&#123;</div><div class="line"></div><div class="line">    setTimeout(function ()&#123;</div><div class="line">        console.log(&apos;3:&apos;+val)</div><div class="line">    &#125;,1000)</div><div class="line"></div><div class="line">&#125;)</div><div class="line">// 1</div></pre></td></tr></table></figure><p>只会执行fn，回调都没有执行,因为这时在resolve比then先执行,这时候promise.$resolve数组是空数组，所以上面代码只打印了一个1。我们需要把resolve放到下一个任务队列末尾执行，也就是then的回调都添加到了数组中之后</p><p>修改resolve函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function resolve(value)&#123;</div><div class="line">    setTimeout(function ()&#123;</div><div class="line">        promise.$resolve.forEach(function (callback)&#123;</div><div class="line">            callback(value)</div><div class="line">        &#125;)</div><div class="line">    &#125;,0)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="引入状态"><a href="#引入状态" class="headerlink" title="引入状态"></a>引入状态</h2><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>每个 Promise 存在三个互斥状态：pending、fulfilled、rejected。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。</p><h3 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h3><p>promise.value保存之后调用该对象回调的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">function _promise(fn)&#123;</div><div class="line">    // 成功的回调</div><div class="line">    var promise = this</div><div class="line">        promise.value = null</div><div class="line">        promise.$resolve = [],</div><div class="line">        promise.$status = &apos;PENDING&apos;</div><div class="line"></div><div class="line">    this.then = function (onFulfilled)&#123;</div><div class="line">        if(promise.$status === &apos;PENDING&apos;)&#123;</div><div class="line">            promise.$resolve.push(onFulfilled)</div><div class="line">            return this</div><div class="line">        &#125;</div><div class="line">        onFulfilled(promise.value)</div><div class="line">        return this</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function resolve(value)&#123;</div><div class="line">        setTimeout(function ()&#123;</div><div class="line">            promise.$status = &quot;FULFILLED&quot;;</div><div class="line">            promise.$resolve.forEach(function (callback)&#123;</div><div class="line">                callback(value)</div><div class="line">                promise.value = value</div><div class="line">            &#125;)</div><div class="line">        &#125;,0)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fn(resolve)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let a = new _promise(function (resolve)&#123;</div><div class="line"></div><div class="line">    setTimeout(function ()&#123;</div><div class="line">        console.log(&apos;1:&apos;)</div><div class="line">        resolve(2)</div><div class="line">    &#125;,1000)</div><div class="line"></div><div class="line">&#125;)</div><div class="line"></div><div class="line">a.then(function (val)&#123;</div><div class="line">    console.log(&apos;2:&apos;+val)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 1</div><div class="line">// 2:2</div></pre></td></tr></table></figure><hr><h2 id="异步回调返回的结果传递到下一个回调"><a href="#异步回调返回的结果传递到下一个回调" class="headerlink" title="异步回调返回的结果传递到下一个回调"></a>异步回调返回的结果传递到下一个回调</h2><p>修改resolve函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function resolve(value)&#123;</div><div class="line">    setTimeout(function ()&#123;</div><div class="line">        promise.$status = &quot;FULFILLED&quot;;</div><div class="line">        promise.$resolve.forEach(function (callback)&#123;</div><div class="line">            value = callback(value)</div><div class="line">            promise.value = value</div><div class="line">        &#125;)</div><div class="line">    &#125;,0)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>即可</p><h2 id="失败处理"><a href="#失败处理" class="headerlink" title="失败处理"></a>失败处理</h2><p>异步操作不可能都成功，在异步操作失败时，标记其状态为 rejected，并执行注册的失败回调。</p><p>有了之前处理 fulfilled 状态的经验，支持错误处理变得很容易。毫无疑问的是，在注册回调、处理状态变更上都要加入新的逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">this.then = function (onFulfilled, onRejected)&#123;</div><div class="line">    return new _promise(function (resolve)&#123;</div><div class="line">        function handle(value)&#123;</div><div class="line">            var ret = typeof onFulfilled === &apos;function&apos; &amp;&amp; onFulfilled(value) || value;</div><div class="line">            resolve(ret)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        function errback(reason)&#123;</div><div class="line">            reason =  typeof onRejected === &apos;function&apos; &amp;&amp; onRejected(reason) || reason;</div><div class="line">            reject(reason)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if(promise.$status === &apos;PENDING&apos;)&#123;</div><div class="line">            promise.$resolves.push(handle)</div><div class="line">            promise.$rejects.push(errback)</div><div class="line">        &#125; else if (promise.$status === &apos;FULFILLED&apos;) &#123;</div><div class="line">            handle(promise.$value)</div><div class="line">        &#125; else if (promise.$status === &apos;REJECTED&apos;) &#123;</div><div class="line">            errback(promise.$reason)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;不知道Promise是啥的，请看上一篇《异步流程控制》&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Re0：从零开始的JavaScript - 异步流程控制</title>
    <link href="http://yoursite.com/2018/02/08/Re0%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84JavaScript%20-%20%E5%BC%82%E6%AD%A5%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2018/02/08/Re0：从零开始的JavaScript - 异步流程控制/</id>
    <published>2018-02-08T13:08:07.788Z</published>
    <updated>2018-02-08T13:07:13.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>在异步编程中，一直在使用Promise。期间一直想做个深入的研究，无奈一直比较忙（懒），今天总算是抽出时间（上班偷懒）来总结一下：<br><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2786325316,2806414041&amp;fm=27&amp;gp=0.jpg" alt="image"></p><blockquote><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul><li>《你不知道的JavaScript》 - 中卷 </li><li>《体验异步的终极解决方案-ES7的Async/Await》(<a href="https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6" target="_blank" rel="external">https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6</a>)</li><li>《ES6入门》 (<a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="external">http://es6.ruanyifeng.com/#docs/async</a>)</li><li>《如何正确学习Node.js》 - 知乎Live 狼叔(i5ting)</li></ul></blockquote><p>从JavaScript程序执行说起，JavaScript程序总是至少分为两块：一块是同步，一块是异步，尽管程序是一块一块执行的，但是所有这些块共享对程序作用域和状态的访问，所以对状态的修改都是在之前累积的修改之上的进行的。</p><p>一旦有事件需要运行，事件循环（Event Loop）就会运行，直到队列清空，异步总是在同步之后执行，这里不细谈。</p><p>JavaScript是单线程的，多个事件，执行速度快的话，看起来就像是并发运行。实际上是多个事件在线程上交替执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var a = 1, b = 2;</div><div class="line">/* 块1</div><div class="line">function foo() &#123;</div><div class="line">    a++;</div><div class="line">    b = b * a;</div><div class="line">    a = b + 3;</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"></div><div class="line">/* 块2</div><div class="line">function bar() &#123;</div><div class="line">    b--;</div><div class="line">    a = 8 + b;</div><div class="line">    b = a * 2;</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"></div><div class="line">// ajax()为某个库提供的某个Ajax函数</div><div class="line">ajax(&quot;http://...&quot;, foo);</div><div class="line">ajax(&quot;http://...&quot;, bar);</div></pre></td></tr></table></figure><p>块1和块2哪个先运行都有可能，JavaScript特性中，这种函数顺序不确定性就是通常所说的竞态条件（race condition）。</p><h1 id="一、回调（callback）"><a href="#一、回调（callback）" class="headerlink" title="一、回调（callback）"></a>一、回调（callback）</h1><p> 简单说回调方法就是将一个方法func2作为参数传入另一个方法func1。</p><p> 当func1执行到某一步或者满足某种条件的时候才执行传入的参数func2，</p><p> 如果我要让上面代码请求相应后先执行 块2 再执行 块1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/* 块1</div><div class="line">function foo(func) &#123;</div><div class="line">    a++;</div><div class="line">    b = b * a;</div><div class="line">    a = b + 3;</div><div class="line">    func();</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"></div><div class="line">/* 块2</div><div class="line">function bar() &#123;</div><div class="line">    b--;</div><div class="line">    a = 8 + b;</div><div class="line">    b = a * 2;</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"></div><div class="line">// ajax(&quot;http://...&quot;, bar(ajax1));</div><div class="line">function ajax1() &#123;</div><div class="line">    ajax(&quot;http://...&quot;, foo);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当我们业务逻辑越来越多的时候，闻名JS界的回调地狱（callback hell）来了 ↓↓↓</p><p>回调地狱图片:<img src="https://upload-images.jianshu.io/upload_images/147516-3bb56611ec38dcce.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="image"></p><p>这只是一部分问题，还有其他的一些，比如控制反转，BUG追踪…</p><p>随着JavaScript越来越多成熟，对于异步编程领域的发展，回调已经不够用了。我们需要比回调更高级，功能更强大的异步模式。</p><h1 id="二、Promise"><a href="#二、Promise" class="headerlink" title="二、Promise"></a>二、Promise</h1><p><img src="http://pic.qqtn.com/up/2016-5/2016050509212091713.jpg" alt="image"></p><p>Promise是异步编程的一种解决方案，它有三种状态，分别是pending-进行中、resolved-已完成、rejected-已失败</p><h2 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">new Promise((resolve, reject) =&gt; &#123;</div><div class="line">    // do something</div><div class="line">    setTimeout(function () &#123;</div><div class="line">        resolve(1);</div><div class="line">    &#125;, 500);</div><div class="line">&#125;).then((data) =&gt; &#123;</div><div class="line">    console.log(&apos;data:&apos; + data); // data:1</div><div class="line">&#125;)</div></pre></td></tr></table></figure><blockquote><p>注意：实例化的Promise对象会立即执行</p></blockquote><p>这时候你应该有所领悟了，原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。</p><p>这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。</p><p>回调太多的时候，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p><p>此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。<br>链式写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function async_1(data) &#123;</div><div class="line">    return new Promise((resolve, reject) =&gt; &#123; </div><div class="line">        // do something...</div><div class="line">        console.time(&apos;异步_1执行 完成&apos;);</div><div class="line">        setTimeout(function () &#123;</div><div class="line">            resolve(data);</div><div class="line">        &#125;, 500);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">async_1(1)</div><div class="line">.then((data) =&gt; &#123;</div><div class="line">    console.timeEnd(&apos;数据：&apos;+　++data);</div><div class="line">    return async_1(data);</div><div class="line">&#125;)</div><div class="line">.then((data) &#123;</div><div class="line">    console.timeEnd(&apos;数据：&apos;+　++data);</div><div class="line">    return &apos;执行完毕&apos;;</div><div class="line">&#125;)</div><div class="line">.then((msg)=&gt; &#123;</div><div class="line"> console.timeEnd(msg); </div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>如果Promise链中的某个步骤出错了怎么办？</p><h2 id="catch"><a href="#catch" class="headerlink" title=".catch()"></a>.catch()</h2><p>错误和异常是基于每个Promise的，这意味着可能在链的任意位置捕捉到这样的错误，而这个捕捉动作在某种程度上就相当于在这个位置将整条链 “重置” 回了正常运作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">function async_2() &#123;</div><div class="line">    return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">        // do something...</div><div class="line">        var data = Math.random() * 10 | 0;</div><div class="line">        setTimeout(function () &#123;</div><div class="line">            if (data &lt;= 5) &#123;</div><div class="line">                resolve(data);</div><div class="line">            &#125; else &#123;</div><div class="line">                reject(data);</div><div class="line">            &#125;</div><div class="line">        &#125;, 500);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">async_2()</div><div class="line">.then(function (data) &#123;</div><div class="line">    console.log(&apos;数字刚好：&apos;+data); //数字刚好：5</div><div class="line">    return async_2();</div><div class="line">&#125;)</div><div class="line">.then(function (data) &#123;</div><div class="line">    console.log(&apos;数字刚好：&apos;+data); // 数字刚好：1</div><div class="line">&#125;)</div><div class="line">.then(function (data) &#123;</div><div class="line">    console.log(&apos;执行完毕 - &apos;+data); //执行完毕 - undefined</div><div class="line">&#125;)</div><div class="line">.catch(function (err) &#123;</div><div class="line">    console.log(&apos;数字太大了：&apos; + err); // 数字太大了： 6</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>.catch()的作用是捕获Promise的错误，与then()的rejected回调作用几乎一致。但是由于Promise的抛错具有冒泡性质，能够不断传递，这样就能够在下一个catch()中统一处理这些错误。</p><p>同时catch()也能够捕获then()中抛出的错误，所以建议不要使用then()的rejected回调，而是统一使用catch()来处理错误。</p><p>上面代码可能会出错，进到catch方法里面去，而且把错误原因传到了err参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能。</p><h2 id="Promise-模式"><a href="#Promise-模式" class="headerlink" title="Promise 模式"></a>Promise 模式</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all([..])"></a>Promise.all([..])</h3><p>在Promise链中，任意时刻都只能有一个异步任务正在执行 —— 步骤2只能在步骤1之后，步骤3只能在步骤2之后。</p><p>如果想要同时执行两个或更多步骤呢？</p><p>门（gate）是这样一种机制要等待两个或更多并行任务都完成才继续。顺序不重要，但必须都要完成，门才能打开并让流程控制继续</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">function async_3() &#123;</div><div class="line">    return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">        // do something...</div><div class="line">        var data = Math.random() * 10 | 0;</div><div class="line">        console.time(data);</div><div class="line">        setTimeout(function () &#123;</div><div class="line">            resolve(data);</div><div class="line">        &#125;, 500);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">function async_4() &#123;</div><div class="line">    return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">        // do something...</div><div class="line">        var data = Math.random() * 10 | 0;</div><div class="line">        // console.time(data);</div><div class="line">        setTimeout(function () &#123;</div><div class="line">            reject(data);</div><div class="line">        &#125;, 1500);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Promise.all([async_3(),async_4()])</div><div class="line">.then((datas) =&gt; &#123;</div><div class="line">    console.timeEnd(datas[1]);</div><div class="line">&#125;).catch((err) =&gt; &#123;</div><div class="line">    console.log(err);</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>从Promise.all 返回的主promise在且仅在所有的成员promise都完成后才会完成。如果这些promise中有任何一个被拒绝的话，主Promise.all就会立即被拒绝，并丢弃来自其他所有promise的全部结果。</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race([])"></a>Promise.race([])</h3><p>和all类似，race是第一个执行完后此时then里面就执行了。可是，其他函数仍旧会执行完毕。</p><blockquote><p>笔者推荐windows用户网速是小水管的情况下使⽤ <a href="https://devdocs.io/" target="_blank" rel="external">https://devdocs.io/</a> 查看离线⽂档，经常查看离线⽂档，对Api理解会深⼊很多，⽐IDE<br>辅助要好，可以有效避免离开IDE就不会写代码的窘境。</p></blockquote><h2 id="Promise-缺点"><a href="#Promise-缺点" class="headerlink" title="Promise 缺点"></a>Promise 缺点</h2><p>首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。</p><p>其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</p><p>第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><h2 id="Promise-性能"><a href="#Promise-性能" class="headerlink" title="Promise 性能"></a>Promise 性能</h2><p>不得不说，Promise给我们提供了保护的同时，相比基本的基于回调的异步任务链要慢一点。但是耿耿于微小的性能损失而无视它提供的所有优点，合适吗？</p><h2 id="Promise总结"><a href="#Promise总结" class="headerlink" title="Promise总结"></a>Promise总结</h2><p>Promise 并没有摈弃回调，只是把回调的安排转交给了一个位于我们和其他工具之间的可信任性的中介机制。</p><h1 id="再来介绍-ES7-Async-Await"><a href="#再来介绍-ES7-Async-Await" class="headerlink" title="再来介绍 ES7 - Async/Await"></a>再来介绍 ES7 - Async/Await</h1><p><img src="http://pic.qqtn.com/up/2016-5/2016050509212011462.jpg" alt="image"></p><p>该新特性就如名字一样 “异步”/“等待” ，处理异步最简单粗暴的方法</p><p>看了下面的栗子就能知道个大概：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var sleep = function (time) &#123;</div><div class="line">    return new Promise(function (resolve, reject) &#123;</div><div class="line">        setTimeout(function () &#123;</div><div class="line">            resolve(&apos;up&apos;);</div><div class="line">        &#125;, time);</div><div class="line">    &#125;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var start = async function () &#123;</div><div class="line">    // 在这里使用起来就像同步代码那样直观</div><div class="line">    console.log(&apos;start&apos;);</div><div class="line">    // await等待的虽然是promise对象，但不必写.then(..)，直接可以得到返回值</div><div class="line">    let status = await sleep(3000);</div><div class="line">    console.log(&apos;end. I &apos; + status); // &apos;end. I up&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">start();</div></pre></td></tr></table></figure><p>其实async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p><p>那我们为什么要去使用它呢？</p><ul><li>更好的语义</li><li>不需要执行器，它本身具备执行能力，不像Generator需要co模块</li><li>Await接Promise， Promise⾃身就⾜够应对所有流程了，包括async函数没有纯并⾏处理机制，也可以采⽤Promise⾥的all和race来补⻬</li><li>更广的适用性(async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。)</li></ul><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">async function f() &#123;</div><div class="line">    await new Promise(function (resolve, reject) &#123;</div><div class="line">        throw new Error(&apos;出错了&apos;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f()</div><div class="line">.then(v =&gt; console.log(v))</div><div class="line">.catch(e =&gt; console.log(e))</div><div class="line"></div><div class="line">Error：出错了</div></pre></td></tr></table></figure><p>上面代码中，async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。</p><p>一般防止出错的方法，也是将其放在try…catch代码块之中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">async function f() &#123;</div><div class="line">  try &#123;</div><div class="line">    await new Promise(function (resolve, reject) &#123;</div><div class="line">      throw new Error(&apos;出错了&apos;);</div><div class="line">    &#125;);</div><div class="line">  &#125; catch(e) &#123;</div><div class="line">  &#125;</div><div class="line">  return await(&apos;hello world&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果有多个await命令，可以统一放在try…catch结构中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">async function main() &#123;</div><div class="line">    try &#123;</div><div class="line">      const val1 = await firstStep();</div><div class="line">      const val2 = await secondStep(val1);</div><div class="line">      const val3 = await thirdStep(val1, val2);</div><div class="line">  </div><div class="line">      console.log(&apos;Final: &apos;, val3);</div><div class="line">    &#125;</div><div class="line">    catch (err) &#123;</div><div class="line">      console.error(err);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h2><p>多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let foo = await getFoo();</div><div class="line">let bar = await getBar();</div></pre></td></tr></table></figure><p>上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">写法一</div><div class="line">let [foo, bar] = await Promise.all([getFoo(), getBar()]);</div><div class="line"></div><div class="line">写法二</div><div class="line">let fooPromise = getFoo();</div><div class="line">let barPromise = getBar();</div><div class="line">let foo = await fooPromise;</div><div class="line">let bar = await barPromise;</div></pre></td></tr></table></figure><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">async function logInOrder(urls) &#123;</div><div class="line">    for (const url of urls) &#123;</div><div class="line">      const response = await fetch(url);</div><div class="line">      console.log(await response.text());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面代码问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">async function logInOrder(urls) &#123;</div><div class="line">    // 并发读取远程URL</div><div class="line">    const textPromises = urls.map(async url =&gt; &#123;</div><div class="line">      const response = await fetch(url);</div><div class="line">      return response.text();</div><div class="line">    &#125;);</div><div class="line">  </div><div class="line">    // 按次序输出</div><div class="line">    for (const textPromise of textPromises) &#123;</div><div class="line">      console.log(await textPromise);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。</p><h2 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h2><p>await命令只能用在async函数之中，如果用在普通函数，就会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">async function dbFuc(db) &#123;</div><div class="line">    let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</div><div class="line">  </div><div class="line">    // 报错</div><div class="line">    docs.forEach(function (doc) &#123;</div><div class="line">      await db.post(doc);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">async function dbFuc(db) &#123;</div><div class="line">    let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</div><div class="line">  </div><div class="line">    for (let doc of docs) &#123;</div><div class="line">      await db.post(doc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>　首先Promise是基础，对于初学者来说，先够⽤，再去深究细节，其次async/await + Promise 可解决大部分场景。</p><h2 id="吐槽一下"><a href="#吐槽一下" class="headerlink" title="吐槽一下"></a>吐槽一下</h2><p>JavaScript技术发展真的是指数爆炸般的增长，真心学不过来。</p><p><img src="http://uploads.5068.com/allimg/170417/1-1F41G60100.gif" alt="image"></p><p>… 啊啊啊啊，说到底还是得掌握好原理　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;在异步编程中，一直在使用Promise。期间一直想做个深入的研究，无奈一直比较忙（懒），今天总算是抽出时间（上班偷懒）来总结一下：&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Re0：从零开始的JavaScript - 观察者模式的理解</title>
    <link href="http://yoursite.com/2018/02/08/Re0%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84JavaScript%20-%20%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/02/08/Re0：从零开始的JavaScript - 观察者模式的理解/</id>
    <published>2018-02-08T13:08:05.088Z</published>
    <updated>2018-02-08T13:07:28.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><blockquote><p>在这里先讲一下面向对象设计的一个重要原则——单一职责原则。因此系统的每个对象应该将重点放在问题域中的离散抽象上。因此理想的情况下，一个对象只做一件事情。这样在开发中也就带来了诸多的好处：提供了重用性和维护性，也是进行重构的良好的基础。几乎所有的设计模式都是基于这个基本的设计原则来的。</p></blockquote><p>观察者模式（又被称为发布-订阅（Publish/Subscribe）模式。说到发布订阅，最熟悉的就是我们的微信公众号了，那就用这个来举例子：<br><img src="http://uploads.5068.com/allimg/170417/1-1F41G60059.gif" alt="image"></p><h1 id="观察者模式的简单实现"><a href="#观察者模式的简单实现" class="headerlink" title="观察者模式的简单实现"></a>观察者模式的简单实现</h1><p>假设微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号，当这个公众号更新时就会通知这些订阅的微信用户。</p><h2 id="先实现微信公众号的类"><a href="#先实现微信公众号的类" class="headerlink" title="先实现微信公众号的类"></a>先实现微信公众号的类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">/* 所有公众号 */</div><div class="line">class Pubsub &#123;</div><div class="line">    /*</div><div class="line">        follows 保存公众号下的用户和用户的操作，数据结构如下：</div><div class="line">        &#123;</div><div class="line">            [&quot;Github最新开源项目&quot;]: [ &#123;id: 0, fn: fn&#125; , &#123;id: 1, fn: fn&#125; , &#123;fn: fn&#125; ],</div><div class="line">            [&quot;CNode社区新闻&quot;]: [ &#123;id: 0, fn: fn&#125; , &#123;id: 1, fn: fn&#125; , &#123;fn: fn&#125; ],</div><div class="line">        &#125;</div><div class="line">    * */</div><div class="line">    constructor ()&#123;</div><div class="line">        this.follows = &#123;&#125;</div><div class="line">        this.id = -1</div><div class="line">    &#125;</div><div class="line">    /* 订阅方法</div><div class="line">     * @param &#123;string&#125; userName 公众号名</div><div class="line">     * @param &#123;function&#125; fn 公众号发布文章后用户会采取的操作</div><div class="line">     * @return &#123;string&#125; id 每个用户在公众号中的唯一标识</div><div class="line">     * */</div><div class="line">    subscrilb(pubsubName, fn) &#123;</div><div class="line">        this.follows[pubsubName] || (this.follows[pubsubName] = [])</div><div class="line">        let id = &apos;&apos; + (++this.id)</div><div class="line">        this.follows[pubsubName].push(&#123; id, fn &#125;)</div><div class="line">        return id</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* 发布方法</div><div class="line">     * @param &#123;string&#125; userName 公众号名</div><div class="line">     * */</div><div class="line">    publish (pubsubName) &#123;</div><div class="line">        let len = this.follows[pubsubName].length;</div><div class="line">        for (let i = 0; i &lt; len; i++) &#123;</div><div class="line">            console.log(this.follows)</div><div class="line">            this.follows[pubsubName][i].fn()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* 取消订阅方法</div><div class="line">     * @param &#123;string&#125; userName 公众号名</div><div class="line">     * @return &#123;string&#125; id 每个用户在公众号中的唯一标识</div><div class="line">     * */</div><div class="line">    unsubscribe(pubsubName, id) &#123;</div><div class="line">        for (let key of this.follows) &#123;</div><div class="line">            if(key == pubsubName) &#123;</div><div class="line">                for (let i = 0,len = this.follows[pubsubName].length; i&lt; len; i++) &#123;</div><div class="line">                    if (this.follows[pubsubName][i].id === id) &#123;</div><div class="line">                        this.follows[pubsubName].splice(i, 1)</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let pubsub = new Pubsub();</div></pre></td></tr></table></figure><h2 id="接下来设置用户类"><a href="#接下来设置用户类" class="headerlink" title="接下来设置用户类"></a>接下来设置用户类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class User &#123;</div><div class="line">    constructor(name)&#123;</div><div class="line">        this.name = name</div><div class="line">    &#125;</div><div class="line">    /* </div><div class="line">    * 用户订阅方法</div><div class="line">    **/</div><div class="line">    follow(pubsubName, fn) &#123;</div><div class="line">        pubsub.subscrilb(pubsubName, fn)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let user1 = new User(&apos;user-1&apos;)</div><div class="line">let user2 = new User(&apos;user-2&apos;)</div></pre></td></tr></table></figure><p>然后进行订阅发布</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">user1.follow(&apos;CNode社区新闻&apos;,function() &#123;</div><div class="line">    console.log(&apos;user 1 关注此社区！&apos;)</div><div class="line">&#125;)</div><div class="line">user2.follow(&apos;CNode社区新闻&apos;,function() &#123;</div><div class="line">    console.log(&apos;user 2 关注此社区！&apos;)</div><div class="line">&#125;)</div><div class="line">pubsub.publish(&apos;CNode社区新闻&apos;)</div><div class="line"></div><div class="line"></div><div class="line">user1.follow(&apos;Github最新咨询&apos;,function() &#123;</div><div class="line">    console.log(&apos;user 1 关注此社区！&apos;)</div><div class="line">&#125;)</div><div class="line">user2.follow(&apos;Github最新咨询&apos;,function() &#123;</div><div class="line">    console.log(&apos;user 2 关注此社区！&apos;)</div><div class="line">&#125;)</div><div class="line">pubsub.publish(&apos;Github最新咨询&apos;)</div></pre></td></tr></table></figure><h1 id="观察者模式优缺点"><a href="#观察者模式优缺点" class="headerlink" title="观察者模式优缺点"></a>观察者模式优缺点</h1><p>优点：</p><ul><li><p>我们作为订阅者不必每次都去查看这个公众号有没有新文章发布， 公众号作为发布者会在合适时间通知我们</p></li><li><p>我们与公众号之间不再强耦合在一起。公众号不关心谁订阅了它，<br>不管你是男是女还是宠物狗，它只需要定时向所有订阅者发布消息即可</p></li><li><p>可以广泛应用于异步编程，它可以代替我们传统的回调函数<br>我们不需要关注对象在异步执行阶段的内部状态，我们只关心事件完成的时间点</p></li></ul><p>缺点：</p><ul><li>在应用观察者模式时需要考虑一下开发效率和运行效率的问题，程序中包括一个被观察者、多个观察者，开发、调试等内容会比较复杂</li><li>由于JavaScript单线程异步机制，即使一个观察者卡顿了，也不会影响整体的执行效率。(多线程同步便会阻塞)</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>观察者模式有两个明显的优点</p><ul><li>时间上解耦</li><li>对象上解耦</li></ul><p><img src="http://pic.qqtn.com/up/2015-12/2015122111044929803.jpg" alt="image"></p><p>关于观察者模式，在浏览器和Node都有良好的事件机制支持，不必自己实现，本文只是简单了解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、定义&quot;&gt;&lt;a href=&quot;#一、定义&quot; class=&quot;headerlink&quot; title=&quot;一、定义&quot;&gt;&lt;/a&gt;一、定义&lt;/h1&gt;&lt;p&gt;定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。&lt;/p&gt;
&lt;bloc
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>视音频编解码技术简单概述</title>
    <link href="http://yoursite.com/2018/02/08/%E8%A7%86%E9%9F%B3%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E6%8A%80%E6%9C%AF%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2018/02/08/视音频编解码技术简单概述/</id>
    <published>2018-02-08T12:50:14.572Z</published>
    <updated>2018-02-08T12:53:16.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近公司要做类似直播的功能，丢给了我一个rtmp地址。<br>我…（<img src="https://imgsa.baidu.com/forum/w%3D580/sign=f11f287c0dd162d985ee621421dea950/0e78f70f4bfbfbed587350c77ff0f736aec31fb3.jpg" alt="image">）</p><h1 id="视音频编解码技术简单概述"><a href="#视音频编解码技术简单概述" class="headerlink" title="视音频编解码技术简单概述"></a>视音频编解码技术简单概述</h1><p>视频文件有不同的格式，用不同的后缀表示：avi，rmvb，mp4，flv，mkv等等（当然也使用不同的图标）。在这里需要注意的是，这些格式代表的是“封装格式”。何为封装格式？就是把视频数据和音频数据打包成一个文件的规范。仅仅靠看文件的后缀，很难能看出具体使用了什么“视音频编码标准”。总的来说，不同的封装格式之间差距不大，各有优劣。</p><p><img src="http://img.blog.csdn.net/20140201115933359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p>在弹出的“属性”对话框的“MediaInfo”选项卡中，就可以查看该视频文件采用的视音频技术了。如下图所示，“变形金刚预告片_h1080p.mov”采用MPEG4的QuickTime封装格式（MOV），采用了H.264（AVC）的压缩编码标准。</p><h1 id="视频播放器原理"><a href="#视频播放器原理" class="headerlink" title="视频播放器原理"></a>视频播放器原理</h1><p>视音频技术主要包含以下几点：封装技术，视频压缩编码技术以及音频压缩编码技术。如果考虑到网络传输的话，还包括流媒体协议技术。</p><p>在这里不细说了，仅简要说明一下视频播放器的原理。</p><p>视频播放器播放一个互联网上的视频文件，需要经过以下几个步骤：解协议，解封装，解码视音频，视音频同步。如果播放本地文件则不需要解协议，为以下几个步骤：解封装，解码视音频，视音频同步。他们的过程如图所示。</p><p><img src="http://img.blog.csdn.net/20140201120523046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p>解协议的作用，就是将流媒体协议的数据，解析为标准的相应的封装格式数据。视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。</p><p>解封装的作用，就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。</p><p>解码的作用，就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。</p><p>视音频同步的作用，就是根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。</p><h1 id="流媒体协议"><a href="#流媒体协议" class="headerlink" title="流媒体协议"></a>流媒体协议</h1><p>流媒体协议是服务器与客户端之间通信遵循的规定。当前网络上主要的流媒体协议如表所示。</p><p><img src="images/live/streamProtocol.png" alt="image"></p><p>RTSP+RTP经常用于IPTV领域。因为其采用UDP传输视音频，支持组播，效率较高。但其缺点是网络不好的情况下可能会丢包，影响视频观看质量。因而围绕IPTV的视频质量的研究还是挺多的。</p><p>因为互联网网络环境的不稳定性，RTSP+RTP较少用于互联网视音频传输。互联网视频服务通常采用TCP作为其流媒体的传输层协议，因而像RTMP，MMS，HTTP这类的协议广泛用于互联网视音频服务之中。这类协议不会发生丢包，因而保证了视频的质量，但是传输的效率会相对低一些。</p><p>此外RTMFP是一种比较新的流媒体协议，特点是支持P2P。</p><h1 id="封装格式"><a href="#封装格式" class="headerlink" title="封装格式"></a>封装格式</h1><p>封装格式的主要作用是把视频码流和音频码流按照一定的格式存储在一个文件中。现如今流行的封装格式如下表所示：</p><p><img src="images/live/packageFormat.png" alt="image"></p><p>由表可见，除了AVI之外，其他封装格式都支持流媒体，即可以“边下边播”。有些格式更“万能”一些，支持的视音频编码标准多一些，比如MKV。而有些格式则支持的相对比较少，比如说RMVB。</p><h1 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h1><p>视频编码的主要作用是将视频像素数据（RGB，YUV等）压缩成为视频码流，从而降低视频的数据量。如果视频不经过压缩编码的话，体积通常是非常大的，一部电影可能就要上百G的空间。视频编码是视音频技术中最重要的技术之一。视频码流的数据量占了视音频总数据量的绝大部分。高效率的视频编码在同等的码率下，可以获得更高的视频质量。</p><p><img src="images/live/videoCode.png" alt="image"></p><p>由表可见，有两种视频编码方案是最新推出的：VP9和HEVC。目前这两种方案都处于研发阶段，还没有到达实用的程度。当前使用最多的视频编码方案就是H.264。</p><h1 id="音频编码"><a href="#音频编码" class="headerlink" title="音频编码"></a>音频编码</h1><p>音频编码的主要作用是将音频采样数据（PCM等）压缩成为音频码流，从而降低音频的数据量。音频编码也是互联网视音频技术中一个重要的技术。但是一般情况下音频的数据量要远小于视频的数据量，因而即使使用稍微落后的音频编码标准，而导致音频数据量有所增加，也不会对视音频的总数据量产生太大的影响。高效率的音频编码在同等的码率下，可以获得更高的音质。</p><p><img src="images/live/audioCode.png" alt="image"></p><p>由表可见，近年来并未推出全新的音频编码方案，可见音频编码技术已经基本可以满足人们的需要。音频编码技术近期绝大部分的改动都是在MP3的继任者——AAC的基础上完成的。</p><h1 id="目前主流常见直播协议"><a href="#目前主流常见直播协议" class="headerlink" title="目前主流常见直播协议"></a>目前主流常见直播协议</h1><p>RTMP: 底层基于TCP，在浏览器端依赖Flash。<br>HTTP-FLV: 基于HTTP流式IO传输FLV，依赖浏览器支持播放FLV。<br>WebSocket-FLV: 基于WebSocket传输FLV，依赖浏览器支持播放FLV。WebSocket建立在HTTP之上，建立WebSocket连接前还要先建立HTTP连接。<br>HLS: Http Live Streaming，苹果提出基于HTTP的流媒体传输协议。HTML5可以直接打开播放。<br>RTP: 基于UDP，延迟1秒，浏览器不支持。</p><p>在支持浏览器的协议里，延迟排序是：<br>RTMP = HTTP-FLV = WebSocket-FLV &lt; HLS<br>而性能排序恰好相反：<br>RTMP &gt; HTTP-FLV = WebSocket-FLV &gt; HLS<br>也就是说延迟小的性能不好。</p><p>可以看出在浏览器里做直播，使用HTTP-FLV协议是不错的，性能优于RTMP+Flash，延迟可以做到和RTMP+Flash一样甚至更好。</p><p>#最后 </p><p><img src="https://imgsa.baidu.com/forum/w%3D580/sign=af530e2520381f309e198da199004c67/ca865cb30f2442a7e84fc1b8d943ad4bd0130244.jpg" alt="image"></p><p>既然是rtmp，我最后直接用ckplayer，把官方demo替换下url。完事儿</p><p>不过依赖flash…，就有点尴尬了。</p><p>目前想法是看能不能用Node做流媒体服务器做H5直播，让我再研究一番。</p><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2566083351,3335343839&amp;fm=27&amp;gp=0.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近公司要做类似直播的功能，丢给了我一个rtmp地址。&lt;br&gt;我…（&lt;img src=&quot;https://imgsa.baidu.com/fo
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>区区一个死宅</title>
    <link href="http://yoursite.com/2017/10/22/%E5%8C%BA%E5%8C%BA%E4%B8%80%E4%B8%AA%E6%AD%BB%E5%AE%85/"/>
    <id>http://yoursite.com/2017/10/22/区区一个死宅/</id>
    <published>2017-10-22T15:29:46.490Z</published>
    <updated>2017-10-22T15:41:23.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10-23"><a href="#10-23" class="headerlink" title="10.23"></a>10.23</h1><p>风和日丽，日月乾坤。走向毕业的脚步，温扰了我写代码的思路。纵然有bug寻百度，踏平脚下路，蓦然回首细环顾，依旧bug无数。索性关掉编辑器，还我一份清静。<br><img src="/images/bir/ai.png" alt="image"></p><p>突然一个闹钟响起来。上面写着<br>”今晚请友人j，友人s去吃宵夜。”<br>内心本是不住的抽搐。</p><p>……看了视频，拍了毕业照，晚上就到了。</p><p>微信一call，结果友人A、B竟然在学校外面，索性把我也叫出去，吃我一顿大的。<br><img src="/images/bir/ku.png" alt="image"></p><p>然后我们就去吃鸡了，是真的鸡。。众人（啪叽啪叽地吃完）<br><img src="/images/bir/chiji.jpg" alt="image"></p><p>吃完心想回去看两视频就好好睡觉。然后友人叫我去走操场，那走吧~ ~ 十几个G的框架视频也不差这会儿看。<br><img src="/images/bir/ai.png" alt="image"></p><p>还没走完一圈，刚掉队的去买水喝的两人回来了，手还提着个蛋糕，没错，今天是我农历生日（滑稽）。<br><img src="/images/bir/dangao.jpg" alt="image"></p><p>讲道理，我本是就把那餐饭当做庆生的。结果还有个蛋糕（内心美滋滋，表面害怕.gif）。 然后我们就去操场一个角落里围起来坐着手起刀落切好蛋糕，众人（啪叽啪叽地吃完）</p><p>总之，很感谢两位友人JS给我庆生的。这大概是即将变为社畜的我前，在大学里最好的memory了。<br><img src="/images/bir/wo.jpg" alt="image"></p><p><img src="/images/bir/youren.jpg" alt="image"><br>( 中间 J   右边 S )<br>还有个很纠结的问题，就是友人J问我有没把J S当女的看。”那肯定啊，还是小仙女，如果要加上个期限，那么仅限今晚”<br><img src="/images/bir/heihei.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;10-23&quot;&gt;&lt;a href=&quot;#10-23&quot; class=&quot;headerlink&quot; title=&quot;10.23&quot;&gt;&lt;/a&gt;10.23&lt;/h1&gt;&lt;p&gt;风和日丽，日月乾坤。走向毕业的脚步，温扰了我写代码的思路。纵然有bug寻百度，踏平脚下路，蓦然回首细环顾，依旧bug
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日常" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript — 动态规划&amp;&amp;贪心算法</title>
    <link href="http://yoursite.com/2017/10/17/JavaScript%20%E2%80%94%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&amp;&amp;%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/10/17/JavaScript — 动态规划&amp;&amp;贪心算法/</id>
    <published>2017-10-17T10:14:30.210Z</published>
    <updated>2017-10-17T10:19:05.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>是一种将复杂问题分解成更小的子问题来解决的优化技术。</p><p>用动态规划解决问题时，要遵循三个重要步骤：</p><blockquote><p>（1）、定义子问题</p><p>（2）、实现要反复执行来解决子问题的部分</p><p>（3）、识别并求解出边界条件\</p></blockquote><hr><h2 id="1、最少硬币找零问题"><a href="#1、最少硬币找零问题" class="headerlink" title="1、最少硬币找零问题"></a>1、最少硬币找零问题</h2><p> 最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额d1…dn及其数量，找到所需最少的硬币个数。</p><p> 例如：有以下面额（硬币）：d1=1,d2=5,d3=10,d4=25</p><p> 如果要找36美分的零钱，我们可以用1个25、1个10、1个1美分。</p><p> 下面将这个解答转化成算法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">function MinCoinChange(coins_) &#123;</div><div class="line">    let coins = coins_;</div><div class="line">    let cache = &#123;&#125;;</div><div class="line"></div><div class="line">    this.makeChange = function(amount) &#123;</div><div class="line">        let me = this;</div><div class="line">        if(!amount) &#123;</div><div class="line">            return [];</div><div class="line">        &#125;</div><div class="line">        if(cache[amount]) &#123;</div><div class="line">            return cache[amount];</div><div class="line">        &#125;</div><div class="line">        let min = [], newMin, newAmount;</div><div class="line">        for(let i = 0; i&lt;coins.length; i++) &#123;</div><div class="line">            let coin = coins[i];</div><div class="line">            newAmount = amount - coin;</div><div class="line">            if(newAmount &gt;= 0) &#123;</div><div class="line">                newMin = me.makeChange(newAmount);</div><div class="line">            &#125;</div><div class="line">            if(newAmount &gt;= 0 &amp;&amp; </div><div class="line">                (newMin.length &lt; min.length - 1 || !min.length ) &amp;&amp;</div><div class="line">                (newMin.length || !newAmount) </div><div class="line">            ) &#123;</div><div class="line">                min = [coin].concat(newMin);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return cache[amount] = min;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var minCoinChange = new MinCoinChange([1,5,10,25]);</div><div class="line">console.log(minCoinChange.makeChange(36));</div></pre></td></tr></table></figure><hr><h2 id="2、背包问题"><a href="#2、背包问题" class="headerlink" title="2、背包问题"></a>2、背包问题</h2><p> 背包问题是一个组合优化问题。描述如下：给定一个固定大小、能够携重W的背包，以及一组有价值和重量的物品。</p><p> 在物品不重复情况下，找出一个最佳解决方案，使得装入背包的物品总重量不超过W，且总价值最大。</p><p> 比如：<br> 糖果：重量2 价值3，饼干：重量3 价值4，牛奶：重量4 价值5。</p><p> 考虑背包只能携带重量只有5。对于这个例子，最佳方案是往背包里装糖果和饼干，这样，总重量为5，总价值为7。<br> 转化为算法如下（返回的是价值量）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">function knapSack(capacity, weights, values, n) &#123;</div><div class="line">    let i, w, a, b, kS = [];</div><div class="line">    for(i = 0; i &lt;= n; i++) &#123;</div><div class="line">        kS[i] = [];</div><div class="line">    &#125;</div><div class="line">    for(i = 0; i &lt;= n; i++) &#123;</div><div class="line">        for(w = 0; w &lt;= capacity; w++) &#123;</div><div class="line">            if(i == 0 || w == 0) &#123;</div><div class="line">                kS[i][w] = 0;</div><div class="line">            &#125; else if (weights[i-1] &lt;= w) &#123;</div><div class="line">                a = values[i-1] + kS[i-1][w-weights[i-1]];</div><div class="line">                b = kS[i-1][w];</div><div class="line">                kS[i][w] = (a &gt; b) ? a : b;</div><div class="line">            &#125; else &#123;</div><div class="line">                kS[i][w] = kS[i-1][w];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    findValues(n, capacity, kS, weights, values);</div><div class="line">    return kS[n][capacity];</div><div class="line">&#125;</div><div class="line">let findValues = (n, capacity, kS, weights, values) =&gt; &#123;</div><div class="line">    let i = n, k = capacity;</div><div class="line">    console.log(&apos;解决方案包含以下物品&apos;);</div><div class="line">    while(i &gt; 0 &amp;&amp; k &gt; 0) &#123;</div><div class="line">        if(kS[i][k] !== kS[i-1][k]) &#123;</div><div class="line">            console.log(&apos;物品&apos; + i + &apos;，重量:&apos; + weights[i-1] + &apos;,价值:&apos; + values[i-1]);</div><div class="line">            i--;</div><div class="line">            k = k - kS[i][k];</div><div class="line">        &#125; else &#123;</div><div class="line">            i--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let values = [3,4,5],</div><div class="line">    weights = [2,3,4],</div><div class="line">    capacity = 6,</div><div class="line">    n = values.length;</div><div class="line">console.log(knapSack(capacity, weights, values, n));</div></pre></td></tr></table></figure><hr><h1 id="二、贪心算法"><a href="#二、贪心算法" class="headerlink" title="二、贪心算法"></a>二、贪心算法</h1><p> 贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解）。从而达到全局最优。它不像DP（动态规划）那样计算更大的格局。</p><p> 我们来看看如何用贪心算法解决“最少硬币找零问题”和“背包问题”。</p><p> 1、最少硬币找零问题</p><p> 用贪心算法解决。大部分情况下的结果是最优的，不过对有些面额而言，结果不会是最优的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function MinCoinChange(coins_) &#123;</div><div class="line">    let coins = coins_;</div><div class="line">    this.makeChange = function(amount) &#123;</div><div class="line">        let change = [],</div><div class="line">            total = 0;</div><div class="line">        for(let i = coins.length; i &gt;= 0; i--) &#123;</div><div class="line">            let coin =coins[i];</div><div class="line">            while (total + coin &lt;= amount) &#123;</div><div class="line">                change.push(coin);</div><div class="line">                total += coin;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return change;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不得不说贪心版本比DP简单多了。</p><p>这个解法很简单，从最大面额的硬币开始，拿尽可能多的这种硬币找零。当无法再拿更多这种价值的硬币时，开始拿第二大价值的硬币，依次继续.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let minCoinChange = new MinCoinChange([1,5,18,25]);</div><div class="line">console.log(minCoinChange.makeChange(36)); // [25,10,1]</div></pre></td></tr></table></figure><p>然而，因为是从最大面额开始，如果上面面额改为[1,5,18,25]。会得到结果[25,5,5,1]，如果用DP的解法，会得到最优结果[18,18]</p><hr><h2 id="2、分数背包问题"><a href="#2、分数背包问题" class="headerlink" title="2、分数背包问题"></a>2、分数背包问题</h2><p>分数背包问题和DP的稍有不同。分数背包问题中，我们可以装入分散的物品。</p><p> 比如：我们考虑的容量为6的情况下，DP返回的是8，分数背包返回的是8.25。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function knapSack(capacity, weights, values, n_) &#123;</div><div class="line">    let n  = n_,</div><div class="line">    load = 0, i = 0, val = 0;</div><div class="line"></div><div class="line">    for(i = 0; i &lt; n &amp;&amp; load &lt;= capacity; i++) &#123;</div><div class="line">        if(weights[i] &lt;= (capacity - load)) &#123;</div><div class="line">            val += values[i];</div><div class="line">            load += weights[i];</div><div class="line">            console.log(i, val);</div><div class="line">        &#125; else &#123;</div><div class="line">            let r = (capacity - load) / weights[i];</div><div class="line">            val += r * values[i];</div><div class="line">            load += weights[i];</div><div class="line">            console.log(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return val;</div><div class="line">&#125;</div><div class="line">let values = [3,4,5],</div><div class="line">    weights = [2,3,4],</div><div class="line">    capacity = 6,</div><div class="line">    n = values.length;</div><div class="line">console.log(knapSack(capacity, weights, values, n));</div></pre></td></tr></table></figure><p> 主要就是如果物品不能完整装入背包，计算能够装入部分的比例。</p><hr><h1 id="结语：一个程序猿还是需要掌握一点算法知识，这是不会错的。"><a href="#结语：一个程序猿还是需要掌握一点算法知识，这是不会错的。" class="headerlink" title="结语：一个程序猿还是需要掌握一点算法知识，这是不会错的。"></a>结语：一个程序猿还是需要掌握一点算法知识，这是不会错的。</h1><p><img src="/images/DP/end.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;p&gt;是一种将复杂问题分解成更小的子问题来解决的优化技术。&lt;/p&gt;
&lt;p&gt;用动态规划解决问题时，要遵循三个重要步骤：&lt;/p&gt;
&lt;b
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>addEventListener中事件用bind指向this后,无法移除事件问题.</title>
    <link href="http://yoursite.com/2017/10/17/addEventListener%20%E4%B8%AD%20%E4%BA%8B%E4%BB%B6%E7%94%A8bind%E6%8C%87%E5%90%91this%20%E5%90%8E%EF%BC%8C%E6%97%A0%E6%B3%95%E7%A7%BB%E9%99%A4%E4%BA%8B%E4%BB%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/10/17/addEventListener 中 事件用bind指向this 后，无法移除事件问题/</id>
    <published>2017-10-17T10:14:28.263Z</published>
    <updated>2017-10-17T10:13:06.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="addEventListener-中-事件用bind指向this-后，无法移除事件问题"><a href="#addEventListener-中-事件用bind指向this-后，无法移除事件问题" class="headerlink" title="addEventListener 中 事件用bind指向this 后，无法移除事件问题"></a>addEventListener 中 事件用bind指向this 后，无法移除事件问题</h1><p>今天写BUG的时候，要在一个touchstart事件内添加 touchmove和touchend的事件注册。</p><p>然后，在touchend的时候再把2个事件给移除了。</p><p>之前一直不是很在意bind，apply，call一些细节的的我就在这里吃了亏，果然出来混的迟早要还的。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dom.addEventListener(&apos;touchstart&apos;, fTouchstart.bind(this));</div><div class="line">function fTouchstart(e) &#123;</div><div class="line">    console.log(&apos;start:&apos; + e, this); // TouchEvent对象，实例对象</div><div class="line">    dom.addEventListener(&apos;touchmove&apos;, fTouchmove.bind(this));</div><div class="line">    dom.addEventListener(&apos;touchend&apos;, fTouchend.bind(this));</div><div class="line">&#125;</div><div class="line"></div><div class="line">function fTouchmove(e) &#123;</div><div class="line">    console.log(‘move:’ + e, this); // TouchEvent对象，实例对象</div><div class="line">    dom.removeEventListener(&apos;touchmove&apos;, fTouchmove);</div><div class="line">    dom.removeEventListener(&apos;touchend&apos;, fTouchend);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后在浏览器上换成移动端在dom上点击几次，你会发现end事件执行次数之后每次会递增1。</p><hr><h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>bind方法返回了一个新的函数。在removeEventListener中移除的事件并没有绑定在TouchEvnent上，绑定上去的是bind()方法每次返回的函数。</p><hr><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>在外面保存bind()返回函数的引用。</p><p>修改上面代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 保存引用</div><div class="line">var fTouchstart_ = fTouchstart.bind(this),</div><div class="line">    fTouchmove_ = fTouchmove.bind(this),</div><div class="line">fTouchend_ = fTouchend.bind(this);</div><div class="line"></div><div class="line">dom.addEventListener(&apos;touchstart&apos;, fTouchstart_);</div><div class="line">function fTouchstart(e) &#123;</div><div class="line">    console.log(&apos;start:&apos; + e, this); // TouchEvent对象，实例对象</div><div class="line">    dom.addEventListener(&apos;touchmove&apos;, fTouchmove_);</div><div class="line">    dom.addEventListener(&apos;touchend&apos;, fTouchend_);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function fTouchmove(e) &#123;</div><div class="line">    console.log(‘move:’ + e, this); // TouchEvent对象，实例对象</div><div class="line">    dom.removeEventListener(&apos;touchmove&apos;, fTouchmove_);</div><div class="line">    dom.removeEventListener(&apos;touchend&apos;, fTouchend_);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;addEventListener-中-事件用bind指向this-后，无法移除事件问题&quot;&gt;&lt;a href=&quot;#addEventListener-中-事件用bind指向this-后，无法移除事件问题&quot; class=&quot;headerlink&quot; title=&quot;addEve
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript — 搜索算法</title>
    <link href="http://yoursite.com/2017/10/17/JavaScript%20%E2%80%94%20%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/10/17/JavaScript — 搜索算法/</id>
    <published>2017-10-17T10:14:21.482Z</published>
    <updated>2017-10-17T10:13:45.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-—-搜索算法"><a href="#JavaScript-—-搜索算法" class="headerlink" title="JavaScript — 搜索算法"></a>JavaScript — 搜索算法</h1><hr><h1 id="1、顺序搜索"><a href="#1、顺序搜索" class="headerlink" title="1、顺序搜索"></a>1、顺序搜索</h1><p>顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。</p><p>顺序搜索也是最低效的一种搜索算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let sequentialSearch = (arr, item) =&gt; &#123; // 传入数组和要找到的元素</div><div class="line">for(let i = 0, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">if(item === arr[i]) &#123;</div><div class="line">return i;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>顺序搜索迭代整个数组，将每个数组元素和搜索项作比较，如果搜索到了，将返回特定值（索引，值，布尔值）。</p><hr><h1 id="2、二分搜索"><a href="#2、二分搜索" class="headerlink" title="2、二分搜索"></a>2、二分搜索</h1><p>这个算法要求被搜索的数据结构已排序。</p><p>分为四个步骤：</p><blockquote><p>（1）、选择数组的中间值。</p><p>（2）、如果选中值是待搜索值，那么算法执行完毕。</p><p>（3）、如果待搜索值比选中值小，则返回步骤1并在选中值的左边的子数组中寻找。</p><p>（4）、如果待搜索值比选中值大，则返回步骤1并在选中值的右边的子数组中寻找。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let binarySearch = (arr, item) =&gt; &#123;</div><div class="line">arr.quickSort(); // 先从小到大排序</div><div class="line">let low = 0,</div><div class="line">high = arr.length - 1;</div><div class="line">mid, element;</div><div class="line">while(low &lt;= high) &#123;</div><div class="line">mid = ((low + high) / 2);</div><div class="line">element = arr[mid];</div><div class="line">if(element &lt; item) &#123;</div><div class="line">low = mid + 1;</div><div class="line">&#125; else if(element &gt; item) &#123;</div><div class="line">high = mid - 1;</div><div class="line">&#125; else &#123;</div><div class="line">return mid;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript-—-搜索算法&quot;&gt;&lt;a href=&quot;#JavaScript-—-搜索算法&quot; class=&quot;headerlink&quot; title=&quot;JavaScript — 搜索算法&quot;&gt;&lt;/a&gt;JavaScript — 搜索算法&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript — 基本算法学习</title>
    <link href="http://yoursite.com/2017/10/17/JavaScript%20%E2%80%94%20%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2017/10/17/JavaScript — 基本算法学习/</id>
    <published>2017-10-17T10:14:19.207Z</published>
    <updated>2017-10-17T10:13:26.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-—-基本算法学习"><a href="#JavaScript-—-基本算法学习" class="headerlink" title="JavaScript — 基本算法学习"></a>JavaScript — 基本算法学习</h1><blockquote><p>学JS也挺久了也很少接触算法，最近看到《学习JavaScript数据结构与算法》出了第二版，还是很新的一门教材。就买来拜读了一下，然后整理下学习到的知识，方便日后温习。</p></blockquote><p><em>PS:下面所有算法，我们都最多用push方法向数据结构添加元素，这样刻意简单，这是为了能够专注排序和搜索算法，语法为ES6。</em></p><hr><h1 id="1、冒泡排序-—-O-n²"><a href="#1、冒泡排序-—-O-n²" class="headerlink" title="1、冒泡排序 — O(n²)"></a>1、冒泡排序 — O(n²)</h1><p>说明：冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素向上移动至正确的顺序，就好像气泡升至表面一样。</p><p>tips：冒泡排序是性能最差的一个算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let bubbleSort = (arr) &gt;= &#123;</div><div class="line">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">        for (let j = 0; j &lt; len - 1; j++) &#123;</div><div class="line">if(arr[j] &gt; arr[j + 1]) &#123;</div><div class="line">[ arr[i], arr[j + 1] ] = [ arr[j + 1], arr[i] ];</div><div class="line">&#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">let arr = [5,4,3,2,1];</div><div class="line">bubbleSort(arr);</div><div class="line">console.log(arr); // [1,2,3,4,5]</div></pre></td></tr></table></figure><p>注意当函数执行到 i=1 的时候，数字4和5已经是正确的排序了。尽管如此，后续比较中，它们还一直在进行着比较，即使这是不必要的。<br>如果从内循环减去外循环中已跑过的轮数，就可以避免内循环中所有不必要的比较了。改进后的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let modBubbleSort = (arr) &gt;= &#123;</div><div class="line">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">        for (let j = 0; j &lt; len - 1 - i; j++) &#123;</div><div class="line">if(arr[j] &gt; arr[j + 1]) &#123;</div><div class="line">[ arr[i], arr[j + 1] ] = [ arr[j + 1], arr[i] ];</div><div class="line">&#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">let arr = [5,4,3,2,1];</div><div class="line">modBubbleSort(arr);</div><div class="line">console.log(arr); // [1,2,3,4,5]</div></pre></td></tr></table></figure><hr><h1 id="2、选择排序-—-O-n²"><a href="#2、选择排序-—-O-n²" class="headerlink" title="2、选择排序 — O(n²)"></a>2、选择排序 — O(n²)</h1><p>说明：选择排序大概思路是找到数据结构中最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let selectionSort = (arr) &gt;= &#123;</div><div class="line">let len = arr.length,</div><div class="line">indexMin;</div><div class="line">for(let i = 0; i &lt; len -1; i++) &#123;</div><div class="line">indexMin = i;</div><div class="line">for(let j = i; j &lt; len; j++) &#123; // 找到最小值的索引</div><div class="line">if(arr[indexMin] &gt; arr[j]) &#123;</div><div class="line">indexMin = j;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">[ arr[i], arr[indexMin] ] = [ arr[indexMin], arr[i] ];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">let arr = [5,4,3,2,1];</div><div class="line">selectionSort(arr);</div><div class="line">console.log(arr); // [1,2,3,4,5]</div></pre></td></tr></table></figure><hr><h1 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h1><p>从第二项开始和第一项比较，如果第一项大于第二项则换位。</p><p>然后比较第三项和前面两项，如果第二比第三大则换位，再比较第一和第二，如果第一比第二大则换位，否则不动。</p><p>tip:排序小型数组时，此算法比选择排序和冒泡性能要好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let insertionSort = (arr) &gt;= &#123;</div><div class="line">let len = arr.length,</div><div class="line">j, temp;</div><div class="line">for(let i = 1; i &lt; len; i++) &#123; // 从arr[i]开始循环</div><div class="line">j = i; // 比较j次</div><div class="line">temp = arr[i];</div><div class="line">while(j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp) &#123;</div><div class="line">arr[j] = arr[j-1];</div><div class="line">j--;</div><div class="line">&#125;</div><div class="line">arr[j] = temp;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">let arr = [5,4,3,2,1];</div><div class="line">insertionSort(arr);</div><div class="line">console.log(arr); // [1,2,3,4,5]</div></pre></td></tr></table></figure><hr><h1 id="4、归并排序-—-O-nlog-n"><a href="#4、归并排序-—-O-nlog-n" class="headerlink" title="4、归并排序 — O(nlog^n)"></a>4、归并排序 — O(nlog^n)</h1><p>JavaScript的Arry类定义了一个sort函数用以排序数组。ECMAScript没有定义哪个排序算法，所以浏览器厂商可以自行去实现算法。</p><p>Fierfox使用归并排序作为sort的实现，Chrome使用了快速排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">let mergeSort = (arr) &gt;= &#123;</div><div class="line">arr = mergeSortRec(arr);</div><div class="line">&#125;</div><div class="line">let mergeSortRec = (arr) &gt;= &#123;</div><div class="line">let len = arr.length;</div><div class="line">if(len === 1) &#123;</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line">let mid = (len / 2) | 0;</div><div class="line">left = arr.slice(0, mid);</div><div class="line">right = arr.slice(mid, len);</div><div class="line"></div><div class="line">return merge(mergeSortRec(left), mergeSortRec(right));</div><div class="line">&#125;</div><div class="line">let merge = (left, right) &gt;= &#123;</div><div class="line">let result = [],</div><div class="line">il = 0,</div><div class="line">ir = 0;</div><div class="line">while(il &lt; left.length &amp;&amp; ir &lt; right.length) &#123;</div><div class="line">if(left[il] &lt; right[ir]) &#123;</div><div class="line">result.push(left[il++]);</div><div class="line">&#125; else &#123;</div><div class="line">result.push(right[ir++]);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">while(il &lt; left.length) &#123;</div><div class="line">result.push(left[il++]);</div><div class="line">&#125;</div><div class="line">while(ir &lt; right.length) &#123;</div><div class="line">result.push(right[ir++]);</div><div class="line">&#125;</div><div class="line">return result;</div><div class="line">&#125;</div><div class="line">let arr = [5,4,3,2,1];</div><div class="line">mergeSort(arr);</div><div class="line">console.log(arr); // [1,2,3,4,5]</div></pre></td></tr></table></figure><hr><h1 id="5、快速排序-—-O-nlog-n"><a href="#5、快速排序-—-O-nlog-n" class="headerlink" title="5、快速排序 — O(nlog^n)"></a>5、快速排序 — O(nlog^n)</h1><p>快速排序复杂度比一般的 O(nlog^n) 要好。</p><p>和归并排序一样，快速排序也使用分治方法，将原始数组分为较小的数组。（但没有像归并那样将它们分隔开）</p><p>分为三个步骤：</p><blockquote><p>（1）、从数组中选择中间一项作为主元（不推荐从数组第一项作为主元，最好是随机选择一个数组项或是中间项）。</p><p>（2）、创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指针直到我们找到比主元大的元素，<br>    接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这步叫划分操作。</p><p>（3）、接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前两个步骤，直至数组完全排序</p></blockquote><p> 参考：<a href="http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html" target="_blank" rel="external">快速排序（Quicksort）的Javascript实现 - 阮一峰</a> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function quickSort(arr) &#123;</div><div class="line">    if (arr.length &lt;= 1) return arr;</div><div class="line">    var mid = ~~(arr.length / 2),</div><div class="line">        midItem = arr.splice(mid, 1)[0],</div><div class="line">        left = [],</div><div class="line">        right = [];</div><div class="line"></div><div class="line">    arr.forEach(function(item) &#123;</div><div class="line">        if (item &lt;= midItem) left.push(item);</div><div class="line">        else right.push(item);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    var _left = quickSort(left),</div><div class="line">        _right = quickSort(right);</div><div class="line"></div><div class="line">    return _left.concat(midItem, _right);</div><div class="line">&#125;</div><div class="line">let arr = [5, 4, 3, 2, 1];</div><div class="line">console.log(quickSort(arr)); // [1,2,3,4,5]</div></pre></td></tr></table></figure><p>参考：<a href="http://www.cnblogs.com/zichi/p/4788953.html" target="_blank" rel="external">【前端也要学点算法】快速排序的JavaScript实现 - 韩子迟 - 博客园 </a> </p><p>如果需要排序的数组有大量重复元素，可以用基于三向切分的快速排序大幅度提高效率。<br>基础的快排，每一次递归，我们将数组拆分为两个，递归出口是数组长度为 &lt;=1。思考这样一个场景，递归过程中某个数组为 [1, 1, 1, 1, 1, 1, 1, 1]，如果是原始的快排，还需要继续递归下去，实际上已经不需要。所以我们可以用三向切分，简单地说就是将数组切分为三部分，大于基准元素，等于基准元素，小于基准元素。</p><p>我们可以设置一个 mid 数组用来保存等于基准元素的元素集合，以前取的基准元素是数组中间位置的元素，其实任意一个即可，这里选了最后一个，比较方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function quickSort3Way(a) &#123;</div><div class="line">    if (a.length &lt;= 1) return a;</div><div class="line">  </div><div class="line">    var last = a.pop()</div><div class="line">      , left = []</div><div class="line">      , right = []</div><div class="line">      , mid = [last];</div><div class="line">  </div><div class="line">    a.forEach(function(item) &#123;</div><div class="line">      if (item &lt; last)</div><div class="line">        left.push(item);</div><div class="line">      else if (item &gt; last)</div><div class="line">        right.push(item);</div><div class="line">      else</div><div class="line">        mid.push(item);</div><div class="line">    &#125;);</div><div class="line">  </div><div class="line">    var _left = quickSort3Way(left)</div><div class="line">      , _right = quickSort3Way(right);</div><div class="line">  </div><div class="line">    return _left.concat(mid, _right);</div><div class="line">&#125;</div><div class="line">let arr = [5, 4, 3, 2, 1];</div><div class="line">console.log(quickSort3Way(arr)); // [1,2,3,4,5]</div></pre></td></tr></table></figure><p>一行代码写快排</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function quickSort(a) &#123;</div><div class="line">    return a.length &lt;= 1 ? a : quickSort(a.slice(1).filter(item =&gt; item &lt;= a[0])).concat(a[0], quickSort(a.slice(1).filter(item =&gt; item &gt; a[0])));</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h1 id="6、堆排序"><a href="#6、堆排序" class="headerlink" title="6、堆排序"></a>6、堆排序</h1><p>堆排序是一种把数组当做二叉树来排序的算法。</p><p>分为四个步骤：</p><blockquote><pre><code>（1）、索引0是树的根节点。（2）、除根节点外，任意节点N的父节点是N/2（3）、节点L的左子节点是2*L（4）、节点L的右子节点是2*R+1</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let heapSort = (arr) =&gt; &#123;</div><div class="line">let heapSize = arr.length;</div><div class="line">build(arr);</div><div class="line">while(heapSize &gt; 1) &#123;</div><div class="line">heapSize--;</div><div class="line">[ arr[0], arr[heapSize] ] = [ arr[heapSize], arr[0] ];</div><div class="line">heapify(arr, heapSize, 0);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第一步，构造一个满足arr[parent(i)] &gt;= arr[i]的堆结构。</p><p>第二步，交换堆里的第一个元素和最后一个元素的位置交换，这样，最大的值就会出现在它已排序的位置。</p><p>第二步可能会丢掉堆的属性。因此我们还需要执行一个heapify函数，再次将数组转换成堆，也就是说，它会找到当前堆的根节点，重新放到树的底部。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">let build = (arr) =&gt; &#123;</div><div class="line">let heapSize = arr.length;</div><div class="line">for(let i = (arr.length / 2) | 0; i &gt;= 0; i--) &#123;</div><div class="line">heapify(arr, heapSize, i);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">let heapify = (arr, heapSize, i) =&gt; &#123;</div><div class="line">let left = i * 2 + 1,</div><div class="line">right = i * 2 + 2,</div><div class="line">largest = i;</div><div class="line">if(left &lt; heapSize &amp;&amp; arr[left] &gt; arr[largest]) &#123;</div><div class="line">largest = left;</div><div class="line">&#125;</div><div class="line">if(right &lt; heapSize &amp;&amp; arr[right] &gt; arr[largest]) &#123;</div><div class="line">largest = right;</div><div class="line">&#125;</div><div class="line">if(largest !== i) &#123;</div><div class="line">[ arr[i], arr[largest] ] = [ arr[largest], arr[i] ];</div><div class="line">heapify(arr, heapSize, largest)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">let arr = [5,4,3,2,1];</div><div class="line">heapSort(arr);</div><div class="line">console.log(arr); // [1,2,3,4,5]</div></pre></td></tr></table></figure><hr><h1 id="7、计数排序-—-Ο-n-k"><a href="#7、计数排序-—-Ο-n-k" class="headerlink" title="7、计数排序 — Ο(n+k)"></a>7、计数排序 — Ο(n+k)</h1><p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组Count_arr，其中第i个元素是待排序数组arr中值等于i的元素的个数。然后根据数组Count_arr来将arr中的元素排到正确的位置。</p><p>分为四个步骤：</p><p>（1）、找出待排序的数组中最大和最小的元素。</p><p>（2）、统计数组中每个值为i的元素出现的次数，存入数组Count_arr的第i项。</p><p>（3）、对所有的计数累加（从Count_arr中的第一个元素开始，每一项和前一项相加）。</p><p>（4）、反向遍历原数组：将每个元素i放在新数组的第Count_arr(i)项，每放一个元素就将Count_arr(i)减去1。</p><p>tip：计数排序是一个非基于比较的排序算法，快于任何比较排序算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function countSort(arr, min, max) &#123;</div><div class="line">    let i, z = 0, count = [];</div><div class="line"></div><div class="line">    for (i = min; i &lt;= max; i++) &#123;</div><div class="line">        count[i] = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (i=0; i &lt; arr.length; i++) &#123;</div><div class="line">        count[arr[i]]++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (i = min; i &lt;= max; i++) &#123;</div><div class="line">        while (count[i]-- &gt; 0) &#123;</div><div class="line">            arr[z++] = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;</div><div class="line">let arr = [5,4,3,2,1];</div><div class="line">countSort(arr, 0, 5);</div><div class="line">console.log(arr); // [1,2,3,4,5]</div></pre></td></tr></table></figure><hr><h1 id="8、桶排序"><a href="#8、桶排序" class="headerlink" title="8、桶排序"></a>8、桶排序</h1><p>桶排序是一种基于计数的排序算法，工作原理是将数据分到有限数量的桶子里，然后每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。</p><p>当要被排序的数据内的数值是均匀分配的时候（每个桶下的数量相等），桶排序时间复杂度为 O(n)。</p><p>分为四个步骤：</p><blockquote><p>（1）设置固定数量的空桶。</p><p>（2）把数据放到对应的桶中。</p><p>（3）对每个不为空的桶中数据进行排序。</p><p>（4）拼接从不为空的桶中数据，得到结果。</p></blockquote><p>参考: <a href="http://blog.csdn.net/u013063153/article/details/52667542" target="_blank" rel="external">JavaScript十大经典排序算法 - CSDN博客</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">let bucketSort = (arr, num) =&gt; &#123; // arr为数组，num为桶的数量</div><div class="line">    if (arr.length &lt;= 1) &#123;</div><div class="line">        returnarray;</div><div class="line">    &#125;</div><div class="line">    let len = arr.length,</div><div class="line">        buckets = [],</div><div class="line">        result = [],</div><div class="line">        min = (max = arr[0]),</div><div class="line">        regex = &quot;/^[1-9]+[0-9]*$/&quot;,</div><div class="line">        space,</div><div class="line">        n = 0;</div><div class="line">    num = num || (num &gt; 1 &amp;&amp; regex.test(num) ? num : 10);</div><div class="line">    console.time(&quot;桶排序耗时:&quot;);</div><div class="line">    for (let i = 1; i &lt; len; i++) &#123;</div><div class="line">        min = min &lt;= arr[i] ? min : arr[i];</div><div class="line">        max = max &gt;= arr[i] ? max : arr[i];</div><div class="line">    &#125;</div><div class="line">    space = (max - min + 1) / num;</div><div class="line">    for (let j = 0; j &lt; len; j++) &#123;</div><div class="line">        let index = Math.floor((arr[j] - min) / space);</div><div class="line">        if (buckets[index]) &#123;</div><div class="line">            //  非空桶，插入排序</div><div class="line">            let k = buckets[index].length - 1;</div><div class="line">            while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; arr[j]) &#123;</div><div class="line">                buckets[index][k + 1] = buckets[index][k];</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">            buckets[index][k + 1] = arr[j];</div><div class="line">        &#125; else &#123;</div><div class="line">            //空桶，初始化</div><div class="line">            buckets[index] = [];</div><div class="line">            buckets[index].push(arr[j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    while (n &lt; num) &#123;</div><div class="line">        result = result.concat(buckets[n]);</div><div class="line">        n++;</div><div class="line">    &#125;</div><div class="line">    console.timeEnd(&quot;桶排序耗时:&quot;); // 0.06ms</div><div class="line">    return result;</div><div class="line">&#125;;</div><div class="line">let arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</div><div class="line">console.log(bucketSort(arr, 4)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</div><div class="line"></div><div class="line">let arr1 = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</div><div class="line">console.time(&quot;快速排序耗时:&quot;);</div><div class="line">quickSort(arr1); // 用上面所实现的快速排序方法</div><div class="line">console.timeEnd(&quot;快速排序耗时:&quot;);</div></pre></td></tr></table></figure><p>可以看出桶排序比快速排序快了不少。</p><p>参考：<a href="http://www.jb51.net/article/88072.htm" target="_blank" rel="external">深入解析桶排序及Node.js上JavaScript代码的实现</a> </p><p>算法分析：</p><blockquote><p>（1）如果使用基于比较的排序，快速排序，平均时间复杂度为O(nlogn) = O(9000000*log9000000)=144114616=1.44亿次比较。</p><p>（2）如果使用基于计数的排序，桶排序，平均的时候复杂度，可以控制在线性复杂度，当创建700桶时从200分到900分各一个桶，O(N)=O(9000000)，就相当于扫描一次900W条数据。</p><p>然后我对桶排序代价分析直接做一下通俗的总结吧。如果我们把一个数组分成N桶，N桶里面有M个元素，那么M个元素还是要用到比较排序，为了提高速度我们应该尽量避免使用“比较”排序，极限情况下每个桶只能得到一个数据，也就是函数中第二个参数为1，这时桶排序效率能够达到O(n)。</p></blockquote><p>当然，做到这一点很不容易，数据量巨大的情况下，函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。</p><hr><h1 id="9、基数排序（分布式排序）—-O-d-n-r"><a href="#9、基数排序（分布式排序）—-O-d-n-r" class="headerlink" title="9、基数排序（分布式排序）— O(d*(n+r))"></a>9、基数排序（分布式排序）— O(d*(n+r))</h1><p>参考：<a href="http://blog.csdn.net/lemon_tree12138/article/details/51695211" target="_blank" rel="external">排序算法系列 - 基数排序</a></p><p>该参考下的基数排序过程图很形象的说明了排序的原理。</p><p>tip：该函数只适合用于都为整数的无序数组，还要求得最大位数（最大的整数的位数maxValue.toString().length）。</p><p>如果要考虑浮点数，我认为先把元素都映射为整数，再用排序，再映射回来即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">let counter = [];</div><div class="line">let radixSort = (arr, maxDigit) =&gt; &#123; // maxDigit为最大位数</div><div class="line">    let mod = 10;</div><div class="line">    let dev = 1;</div><div class="line">    for (let i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;</div><div class="line">        for(let j = 0; j &lt; arr.length; j++) &#123;</div><div class="line">            let bucket = parseInt((arr[j] % mod) / dev);</div><div class="line">            if(counter[bucket]==null) &#123;</div><div class="line">                counter[bucket] = [];</div><div class="line">            &#125;</div><div class="line">            counter[bucket].push(arr[j]);</div><div class="line">        &#125;</div><div class="line">        let pos = 0;</div><div class="line">        for(let j = 0; j &lt; counter.length; j++) &#123;</div><div class="line">            let value = null;</div><div class="line">            if(counter[j]!=null) &#123;</div><div class="line">                while ((value = counter[j].shift()) != null) &#123;</div><div class="line">                      arr[pos++] = value;</div><div class="line">                &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;</div><div class="line">let arr2 = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</div><div class="line">quickSort(arr2, 2); // [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</div></pre></td></tr></table></figure><hr><h1 id="10、希尔排序"><a href="#10、希尔排序" class="headerlink" title="10、希尔排序"></a>10、希尔排序</h1><p>希尔排序关键在于增量的设置,根据增量分割数组并逐步进行直接插入排序,增量逐趟减少,并最后使得整个数组基本有序,再对整体进行直接插入排序.</p><p>基本的思路就是根据增量分割数组,如var arr = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</p><p>我们增量为5,则分割为</p><blockquote><p>[3,15,46]</p><p> [44,36,4]</p><p> [38,26,19]</p><p> [5,27,50]</p><p> [47,2,48]</p></blockquote><p> 并对每一组进行直接插入排序<br> 再把增量变为2(减半),再进行分割,直到增量为1,再对全体进行一次直接插入排序就可以了.</p><p> 参考：<a href="https://segmentfault.com/a/1190000006950201" target="_blank" rel="external">基本算法学习(一)之希尔排序(JS) - 渣途 - SegmentFault</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let shellSort = arr =&gt; &#123;</div><div class="line">    var len = arr.length;</div><div class="line">    gap = Math.floor(len / 2);</div><div class="line">    while (gap !== 0) &#123;</div><div class="line">        for (var i = gap; i &lt; len; i++) &#123;</div><div class="line">            var temp = arr[i];</div><div class="line">            var j;</div><div class="line">            for (j = i - gap; j &gt;= 0 &amp;&amp; temp &lt; arr[j]; j -= gap) &#123;</div><div class="line">                arr[j + gap] = arr[j];</div><div class="line">            &#125;</div><div class="line">            arr[j + gap] = temp;</div><div class="line">        &#125;</div><div class="line">        gap = Math.floor(gap / 2);</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;;</div><div class="line">let arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</div><div class="line">console.log(shellSort(arr)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</div></pre></td></tr></table></figure><hr><h1 id="结束，以上为JavaScript实现十大经典排序方法。"><a href="#结束，以上为JavaScript实现十大经典排序方法。" class="headerlink" title="结束，以上为JavaScript实现十大经典排序方法。"></a>结束，以上为JavaScript实现十大经典排序方法。</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript-—-基本算法学习&quot;&gt;&lt;a href=&quot;#JavaScript-—-基本算法学习&quot; class=&quot;headerlink&quot; title=&quot;JavaScript — 基本算法学习&quot;&gt;&lt;/a&gt;JavaScript — 基本算法学习&lt;/h1&gt;&lt;bloc
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》—— 高级技巧</title>
    <link href="http://yoursite.com/2017/09/30/JavaScript%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2017/09/30/JavaScript高级技巧/</id>
    <published>2017-09-30T05:30:38.537Z</published>
    <updated>2017-09-30T05:57:13.098Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h1><p>博客开了几个月了也没写什么，想着还是随手写一点吧，也有助于自己的加深理解。最近又在看《JavaScript高级程序设计》，刚好看到第22章的高级技巧，就随手码下来吧。</p><p>本文内容由《JavaScript高级程序设计》书上的P596 - P625 和 本人对这些技巧的理解提供。</p><p>适合人群：如果你刚好在看这本书，或者想特高JS代码的性能优化，减少代码耦合，都可以看本文章。当然，你还需要有一定的JS语法基础。那么，开始吧：</p></blockquote><hr><h1 id="一、高级函数"><a href="#一、高级函数" class="headerlink" title="一、高级函数"></a>一、高级函数</h1><h2 id="1、安全的类型检测"><a href="#1、安全的类型检测" class="headerlink" title="1、安全的类型检测"></a>1、安全的类型检测</h2><p>JavaScript内置的类型检测机制并非完全可靠。比如Safari(直至第4版)在对正则表达式应用typeof操作符时会返回function，instanceof操作符在存在多个全局作用域(像一个页面包含多个frame)的情况下，也是问题多多，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var isArray = arr instanceof Array;</div></pre></td></tr></table></figure><p>如果arr是在另一个frame中定义的数组。那么这里就会返回false。在检测某个对象到底是原生对象还是开发人员自定义的对象的时候。也会有问题。上述问题解决方法都一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(Object.prototype.toString.call(arr));  // &quot;[Object Array]&quot;</div></pre></td></tr></table></figure><p>由于原生数组的构造函数名与全局作用域无关，因此使用toString就能保证返回一致的值，利用这点可以创建如下函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function isArray(value) &#123;</div><div class="line">return Object.prototype.toString.call(value) == &quot;[Object Array]&quot;;</div><div class="line">&#125;</div><div class="line">// 或者</div><div class="line">function isFunction(value) &#123;</div><div class="line">return Object.prototype.toString.call(value) == &quot;[Object Function]&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function isRegExp(value) &#123;</div><div class="line">return Object.prototype.toString.call(value) == &quot;[Object RegExp]&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function isNativeJSON(value) &#123;</div><div class="line">return Object.prototype.toString.call(value) == &quot;[Object JSON]&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>在开发中能够区分原生与非原生对象非常重要。只有这样才能确切知道某个对象到底有哪些功能。</p></blockquote><h2 id="2、作用域安全的构造函数"><a href="#2、作用域安全的构造函数" class="headerlink" title="2、作用域安全的构造函数"></a>2、作用域安全的构造函数</h2><p>直接来看看作用域不安全的构造函数吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">this.name = name;</div><div class="line">&#125;</div><div class="line">var person = Person(&apos;Tom&apos;);</div><div class="line">console.log(window.name);  // &quot;Tom&quot;</div></pre></td></tr></table></figure><p>上面问题出在当没有使用new操作符来调用该构造函数的情况上。由于该this对象是在运行时绑定的，所以直接调用Person()，this会映射到全局对象window上，导致错误对象属性的意外增加。</p><p>解决的思路是 作用域安全的构造函数在进行任何更改前，首先确认this对象是正确类型的实例。如果不是那么会创建新的实例并返回。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">if(this instanceof Person) &#123;</div><div class="line">this.name = name;</div><div class="line">&#125; else &#123;</div><div class="line">return new Person(name);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">var person1 = Person(&quot;Tom&quot;);</div><div class="line">console.log(window.name);// &quot;&quot;</div><div class="line">console.log(person1.name);// &quot;Tom&quot;</div></pre></td></tr></table></figure><p>这段代码中添加了一个检查并确保this对象是Person实例。最后的结果是，调用Person构造函数无论是否使用new操作符，都会返回一个Person的新实例。</p><p>这样处理也有坏处，就是构造函数窃取模式的继承该实例是无效的。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function People(sex) &#123;</div><div class="line">Person.call(this,&apos;Tom&apos;);// 构造函数窃取模式  —— 继承Polygon的name属性  不过在这种作用域安全情况下不可用</div><div class="line">this.sex = sex;</div><div class="line">&#125;</div><div class="line">var people1 = new People(&apos;boy&apos;);</div><div class="line">console.log(people1.name);  //undefined</div></pre></td></tr></table></figure><p>在这里由于Person构造函数作用域是安全的，this对象并非Person实例，所以会创建并返回一个新的Person对象，所以People构造函数中的this对象并没有得到增长，也就不会有name属性。</p><p>解决上面的问题，使用原型链继承即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function People(sex) &#123;</div><div class="line">this.sex = sex;</div><div class="line">&#125;</div><div class="line">People.prototype = new Person(&apos;Tom&apos;);</div><div class="line">var people1 = new People(&apos;boy&apos;);</div><div class="line">console.log(people1.name); //&quot;Tom&quot;</div></pre></td></tr></table></figure></p><blockquote><p>多个程序猿在同一个页面上写JavaScript代码的环境中，作用域安全构造函数就很有用了。推荐作用域安全的构造函数作为最佳实践。</p></blockquote><h2 id="3、惰性载入函数"><a href="#3、惰性载入函数" class="headerlink" title="3、惰性载入函数"></a>3、惰性载入函数</h2><p>因为浏览器之间行为的差异，多数JavaScript代码包含了大量的if语句，将执行引导到正确的代码中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function createXHR() &#123;</div><div class="line">if(typeof XMLHttpRequest != &quot;undefined&quot;) &#123;</div><div class="line">return new XMLHttpRequest();</div><div class="line">&#125; else if(typeof ActiveXObject != &quot;undefined&quot;) &#123;</div><div class="line">if(typeof arguments.callee.activeXString != &quot;string&quot;) &#123;</div><div class="line">var version = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;, &quot;MSXML2.XMLHttp&quot;],</div><div class="line">i,</div><div class="line">len;</div><div class="line">for(i = 0, len = version.length; i &lt; len; i++) &#123;</div><div class="line">try &#123;</div><div class="line">new ActiveXObject(version[i]);</div><div class="line">arguments.callee.activeXString = version[i];</div><div class="line">break;</div><div class="line">&#125; catch(ex) &#123;</div><div class="line">//  跳过</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return new ActiveXObject(arguments.callee.activeXString);</div><div class="line">&#125; else &#123;</div><div class="line">throw new Error(&quot;No XHR object available&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>每次调用createXHR()，它都要对浏览器所支持的能力进行仔细检查。每次调用该函数都是这样，即使调用时分支的结果都不变，如果浏览器内置XHR，那么它就一直支持了，那么这种测试就变得没必要。即使只有一个if语句的代码，也肯定要比没有if语句的慢。</p><p>解决方案就是称为惰性载入的技巧。书上写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function createXHR() &#123; //函数声明写法</div><div class="line">if(typeof XMLHttpRequest != &quot;undefined&quot;) &#123;</div><div class="line">createXHR = function() &#123;</div><div class="line">return new XMLHttpRequest();</div><div class="line">&#125;</div><div class="line">&#125; else if(typeof ActiveXObject != &quot;undefined&quot;) &#123;</div><div class="line">createXHR = function() &#123;</div><div class="line">if(typeof arguments.callee.activeXString != &quot;string&quot;) &#123;</div><div class="line">var version = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;, &quot;MSXML2.XMLHttp&quot;],</div><div class="line">i,</div><div class="line">len;</div><div class="line">for(i = 0, len = version.length; i &lt; len; i++) &#123;</div><div class="line">try &#123;</div><div class="line">new ActiveXObject(version[i]);</div><div class="line">arguments.callee.activeXString = version[i];</div><div class="line">break;</div><div class="line">&#125; catch(ex) &#123;</div><div class="line">//  跳过</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return new ActiveXObject(arguments.callee.activeXString);</div><div class="line">&#125;</div><div class="line">&#125; else &#123;</div><div class="line">createXHR = function() &#123;</div><div class="line">throw new Error(&quot;No XHR object available&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是是把函数表达式写在函数内部，我认为把函数表达式写在外部即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">createXHR = function() &#123; //  这是函数表达式写法</div><div class="line">if(typeof XMLHttpRequest != &quot;undefined&quot;) &#123;</div><div class="line">return new XMLHttpRequest();</div><div class="line">&#125; else if(typeof ActiveXObject != &quot;undefined&quot;) &#123;</div><div class="line">if(typeof arguments.callee.activeXString != &quot;string&quot;) &#123;</div><div class="line">var version = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;, &quot;MSXML2.XMLHttp&quot;],</div><div class="line">i,</div><div class="line">len;</div><div class="line">for(i = 0, len = version.length; i &lt; len; i++) &#123;</div><div class="line">try &#123;</div><div class="line">new ActiveXObject(version[i]);</div><div class="line">arguments.callee.activeXString = version[i];</div><div class="line">break;</div><div class="line">&#125; catch(ex) &#123;</div><div class="line">//  跳过</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return new ActiveXObject(arguments.callee.activeXString);</div><div class="line">&#125; else &#123;</div><div class="line">throw new Error(&quot;No XHR object available&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这两种写法都可以在执行createXHR方法的时候执行第一遍后，后面执行就不会再进行if判断。如果有需要函数第一次执行也不产生if判断，那么就在函数声明的时候执行。</p><blockquote><p>惰性载入函数的优点是只在执行分支代码的时候牺牲一点儿性能。至于那种方式更合适，就要看你的具体需求而定了。</p></blockquote><h2 id="4、函数绑定"><a href="#4、函数绑定" class="headerlink" title="4、函数绑定"></a>4、函数绑定</h2><p>函数绑定要创建一个函数，可以在特定的this环境中以指定参数调用另一个函数。该技巧常常和回调函数与事件处理程序一起使用，以便在将函数作为变量传递的同时保留代码执行环境，看下面栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">name: &quot;Tom&quot;,</div><div class="line">talk: function() &#123;</div><div class="line">con(&apos;I am &apos; + this.name);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">var btn = document.getElementById(&quot;bindBtn&quot;);</div><div class="line">btn.addEventListener(&apos;click&apos;, person.talk);</div></pre></td></tr></table></figure><p>上面代码问题看似点击按钮的时候会打印 “I am Tom”, 实际显示的是 “I am “。</p><p>这个问题在于没有保存person.talk()的环境，所以this对象最后是指向了Dom按钮(在IE8中，this指向window)。</p><p>解决这个问题，可以使用一个闭包来解决，看下面代码（以下代码只显示修改的部分）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">btn.addEventListener(&apos;click&apos;, function() &#123;</div><div class="line">person.talk();</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这个解决方案在click事件处理程序内使用了一个闭包直接调用person.talk(); 这只是这段代码的解决方案，创建多个闭包可能会令代码变得难于理解和调试。</p><p>因此，很多JS库实现了一个可以将函数绑定到指定环境的函数。这个函数一般都叫bind()。</p><p>实现一个比较基本的bind()函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function bind(fn, context) &#123;</div><div class="line">return function() &#123;</div><div class="line">return fn.apply(context, arguments); //  这里使用的arguments对象是内部函数的，并非bind()的。</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>bind()中创建了一个必报，闭包使用apply()调用传入的函数，并给apply()传递context对象和参数。</p><p>结合上面的代码结合使用自定义bind(方法):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">btn.addEventListener(&apos;click&apos;, bind(person.talk, person));</div></pre></td></tr></table></figure><p>其实在ES5已经为所有函数定义了一个原生bind()方法，使用方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">btn.addEventListener(&apos;click&apos;, person.talk.bind(person));</div></pre></td></tr></table></figure><p>只要是将某个函数指针(环境)以值的形式进行传递，同时该函数必须在特定环境中执行，被绑定函数的效用就突显出来了。</p><blockquote><p>主要用于事件处理程序以及setTimeout()和setInterval()。</p><p>然而，被绑定函数与普通函数相比有更多的开销，需要更多的内存，同时也因为多重函数调用稍微慢一点，所以最好只在必要时使用。</p></blockquote><h2 id="5、函数柯里化"><a href="#5、函数柯里化" class="headerlink" title="5、函数柯里化"></a>5、函数柯里化</h2><p>与函数绑定紧密相关的主题是函数柯里化，它用于创建已经设置好了一个或多个参数的函数。</p><p>函数柯里化的基本方法和函数绑定是一样的：使用一个闭包返回一个函数。两者区别在于，当函数被调用时，返回的函数还需要设置一些传入的参数，看栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function curry(fn) &#123;</div><div class="line">var args = Array.prototype.slice.call(arguments, 1);//  这里截取函数之后的参数</div><div class="line">return function() &#123;</div><div class="line">var varArgs = Array.prototype.slice.call(arguments);//  这里接受curryAdd的参数</div><div class="line">var finalArgs = args.concat(varArgs);</div><div class="line">return fn.apply(null, finalArgs);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">function add(num1, num2) &#123;</div><div class="line">return num1 + num2;</div><div class="line">&#125;</div><div class="line">var curryAdd = curry(add, 5);</div><div class="line">console.log(curryAdd(1));//  6</div></pre></td></tr></table></figure><p>这里创建第一个参数绑定为5的add()柯里化版本。你也可以像下面这样给出所有的函数参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var curryAdd = curry(add, 5, 1);</div><div class="line">console.log(curryAdd(1));//  6因为add()没有接受第三个参数，所以还是6</div></pre></td></tr></table></figure><p>函数柯里化还常常作为函数绑定的一部分包含在其中，构造出更为复杂的bind()函数。以ES5的bind()方法举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function bind(fn, context) &#123;</div><div class="line">var args = Array.prototype.slice.call(arguments, 2);//这里需要改为2，获取函数和环境后面的参数</div><div class="line">return function() &#123;</div><div class="line">var varArgs = Array.prototype.slice.call(arguments);//这里从第三个参数开始接受</div><div class="line">var finalArgs = args.concat(varArgs);</div><div class="line">return fn.apply(context, finalArgs);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">var person = &#123;</div><div class="line">name: &quot;Tom&quot;,</div><div class="line">talk: function(message1, message2) &#123;</div><div class="line">console.log(&apos;I am &apos; + this.name + &apos;,&apos; + message1 + &apos;,&apos; + message2 );</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">var talking = person.talk.bind(person, &quot; I am talking &quot;) // 这里创建一个第一个参数绑定为“ I am talking ”的函数</div><div class="line">var btn = document.getElementById(&quot;bindBtn&quot;);</div><div class="line">btn.addEventListener(&apos;click&apos;, function() &#123;</div><div class="line">talking(&apos;I am running&apos;);//这里就任意添加talking后面的参数</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这样每次单机按钮就会弹出相应参数的字符串。</p><blockquote><p>PS:这里有个坑呀。btn.addEventListener(‘click’, talking(‘I am running’));  这样点击按钮是不会有反应的。</p><p>总的来说，柯里化的作用可以使代码模块化，减少耦合增强其可维护性。柯里化函数和绑定函数提供了强大的动态函数创建功能，两者不应滥用，只在必要的时候用。</p></blockquote><h1 id="二、防篡改对象"><a href="#二、防篡改对象" class="headerlink" title="二、防篡改对象"></a>二、防篡改对象</h1><p>在编写JavaScript库中，因为JS共享的特性，开发人员很可能会意外地修改别人代码。</p><p>ES5新增了几个方法，通过它们可以指定对象的行为。</p><h2 id="1、不可拓展对象-Object-preventExtensions"><a href="#1、不可拓展对象-Object-preventExtensions" class="headerlink" title="1、不可拓展对象 Object.preventExtensions()"></a>1、不可拓展对象 Object.preventExtensions()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person1 = &#123; name: &quot;Tom&quot; &#125;;</div><div class="line">person1.age = 20;</div><div class="line">Object.preventExtensions(person1);</div><div class="line">person1.age = 30;</div><div class="line">person1.sex = &quot;boy&quot;</div><div class="line">console.log(person1.age, person1.sex);  // 30, undefined</div><div class="line">delete person1.age;</div><div class="line">console.log(person1.age) // undefined</div></pre></td></tr></table></figure><p>可以看出调用 Object.preventExtensions() 方法后，就不能给person1对象添加新的属性和方法。但是仍然可以修改和删除已有的成员。</p><h2 id="2、密封的对象-Oject-seal"><a href="#2、密封的对象-Oject-seal" class="headerlink" title="2、密封的对象 Oject.seal()"></a>2、密封的对象 Oject.seal()</h2><p>密封对象不可拓展，而且已有的成员[[configurable]]特性将被设置为false。具体功能还是直接看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var person1 = &#123; name: &quot;Tom&quot; &#125;;</div><div class="line">person1.age = 20;</div><div class="line">Object.seal(person1);</div><div class="line">person1.sex = &quot;boy&quot;;</div><div class="line">console.log(person1.boy);  // undefined</div><div class="line">delete person1.name;</div><div class="line">console.log(person1.name);  // &quot;Tom&quot;</div><div class="line">person1.age = 23;</div><div class="line">console.log(person1.age);  // 23</div></pre></td></tr></table></figure><p>除了不能增删外，只有修改操作是可以进行的。</p><h2 id="3、冻结的对象-Object-freeze"><a href="#3、冻结的对象-Object-freeze" class="headerlink" title="3、冻结的对象 Object.freeze()"></a>3、冻结的对象 Object.freeze()</h2><p>最严格的防篡改级别是冻结对象。冻结对象既不可拓展，又是密封的。而且每个对象数据属性[[Writable]]特性会被设置为false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var person1 = &#123;</div><div class="line">name: &quot;Tom&quot;</div><div class="line">&#125;;</div><div class="line">person1.age = 20;</div><div class="line">Object.freeze(person1);</div><div class="line">person1.sex = &quot;boy&quot;;</div><div class="line">console.log(person1.boy); // undefined</div><div class="line">delete person1.name;</div><div class="line">console.log(person1.name); // &quot;Tom&quot;</div><div class="line">person1.age = 23;</div><div class="line">console.log(person1.age); // 20</div></pre></td></tr></table></figure><blockquote><p>可以看出冻结的对象什么也无法修改删除，这样冻结（或密封）主要的库就能够防止这些问题的发生。</p></blockquote><h2 id="三、高级定时器"><a href="#三、高级定时器" class="headerlink" title="三、高级定时器"></a>三、高级定时器</h2><h2 id="1、setTimeout"><a href="#1、setTimeout" class="headerlink" title="1、setTimeout()"></a>1、setTimeout()</h2><p>首先，JavaScript是运行在单线程环境中，而定时器只是表示指定间隔多少时间把代码添加到队列内。</p><p>JS队列执行代码方式还是用代码体验一下吧:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var btn = document.getElementById(&quot;bindBtn&quot;);</div><div class="line">btn.onclick = function() &#123;</div><div class="line">timer1 = setTimeout(function() &#123;</div><div class="line">console.log(&apos;执行第一个定时器&apos;); // 第一个执行</div><div class="line">&#125;, 1000);</div><div class="line">timer2 = setTimeout(function() &#123;</div><div class="line">console.log(&apos;执行第二个定时器&apos;); // 第二个执行</div><div class="line">&#125;, 2000);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>点击按钮后可以发现timer1执行，再过一秒后timer2也执行，一切正常。因为在事件处理程序里面没有其他代码要添加到队列里，效果比较不明显。</p><p>那么我们添加点其他代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var btn = document.getElementById(&quot;bindBtn&quot;);</div><div class="line">btn.onclick = function() &#123;</div><div class="line">console.time(&apos;time:&apos;);</div><div class="line">for (var i=0,a=0;i&lt;99999999;i++) &#123;</div><div class="line">a = Math.floor(Math.random()*10000);</div><div class="line">&#125;;</div><div class="line">a=null;</div><div class="line">console.timeEnd(&apos;time:&apos;);</div><div class="line"></div><div class="line">timer1 = setTimeout(function() &#123;</div><div class="line">console.log(&apos;执行第一个定时器&apos;); // 第一个执行</div><div class="line">&#125;, 1000);</div><div class="line">timer2 = setTimeout(function() &#123;</div><div class="line">console.log(&apos;执行第二个定时器&apos;); // 第二个执行</div><div class="line">&#125;, 2000);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>现在明显感受到定时器输出的晚了几秒。<br>解析一下:点击后，队列中执行for循环，等待for循环结束后，再把timer1和timer2的代码放入队列相隔设置好的时间后执行。这样一来，就好理解多了。</p><h2 id="2、setInterval"><a href="#2、setInterval" class="headerlink" title="2、setInterval()"></a>2、setInterval()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var btn = document.getElementById(&quot;bindBtn&quot;);</div><div class="line">btn.onclick = function() &#123;</div><div class="line">var b = 0;</div><div class="line">timer1 = setInterval(function() &#123;</div><div class="line">console.time(&apos;time:&apos;);</div><div class="line">for(var i = 0, a = 0; i &lt; 99999999; i++) &#123;</div><div class="line">a = Math.floor(Math.random() * 10000);</div><div class="line">&#125;;</div><div class="line">a = null;</div><div class="line">console.log(&apos;第&apos; + ++b + &apos;次定时器执行&apos;);</div><div class="line">console.timeEnd(&apos;time:&apos;); // 基本上每次都间隔2.5秒</div><div class="line">&#125;, 2000);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这个例子中第一个定时器是在2000ms处添加到队列中，但是代码块需要2.5s左右时间执行，所以第一个打印记录时间是4.5s。而在4s的时候本来是应该执行第二个定时器的代码，这时候就会没有延迟的立即执行第二个定时器代码在6s的时候显示”第2次定时器执行”。</p><p>书上有说会缺失间隔的代码，不知道是执行的代码时间不够长还是怎样，执行起来并没有。了解详情的还望指教一下。</p><h2 id="3、Yielding-Processes"><a href="#3、Yielding-Processes" class="headerlink" title="3、Yielding Processes"></a>3、Yielding Processes</h2><p>JavaScript在浏览器中有一个限制是长时间运行脚本的制约，会弹出一个浏览器错误的对话框，告诉用户某个脚本会用过长的时间执行，询问是允许其继续执行还是停止它。</p><p>脚本长时间运行问题通常是两个原因之一造成的：过深的嵌套、过长的函数调用或者是进行大量处理的循环。</p><p>其实就是当你发现某个循环占用了大量时间，如果这个数据的处理不会造成其他运行的阻塞。</p><p>那么你就可以用定时器分割这个循环。这是一种叫“数组分块”的技术，小块小块地处理数组。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">for (var i = 0,len = data.length; i &lt; len; i++) &#123;</div><div class="line">process(data[i]);</div><div class="line">&#125;</div><div class="line">这个事件处理执行产生有可能会造成页面卡顿，这非常影响用户体验，使用数组分块来优化：</div><div class="line">setTimeout(function()&#123;</div><div class="line">var item = array.shift();</div><div class="line">process(item); //  执行某操作</div><div class="line"></div><div class="line">if(array.length &gt; 0) &#123;</div><div class="line">setTimeout(arguments.callee, 100);  // 调用同一个匿名函数</div><div class="line">&#125;</div><div class="line">&#125;, 100);</div></pre></td></tr></table></figure><blockquote><p>数组分块的重要性在于它可以将多个项目的处理在执行队列上分开。</p><p>一旦某个函数需要花50ms以上的时间完成，那么最好看看能否将任务分割为一系列可以使用定时器的小任务。</p></blockquote><h2 id="4、函数节流"><a href="#4、函数节流" class="headerlink" title="4、函数节流"></a>4、函数节流</h2><p>函数节流的基本思想是指，某些代码不可以在没有间断的情况连续重复执行。第一次调用函数创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清楚前一次定时器并设置另一个。</p><p>以下是该模式的基本形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">runTime: null,</div><div class="line"></div><div class="line">//实际进行处理的方法</div><div class="line">run: function() &#123;</div><div class="line">//实际执行的代码</div><div class="line">&#125;,</div><div class="line"></div><div class="line">//初始处理调用的方法</div><div class="line">readyRun: function() &#123;</div><div class="line">clearTimeout(this.runTime);</div><div class="line">var that = this;</div><div class="line">this.timeoutId = setTimeout(function() &#123;</div><div class="line">that.run();</div><div class="line">&#125;, 1000);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码中，拟人化的创建了一个人，有两个方法：run()和readyRun()。前者是实际进行的动作，后者是初始化动作所必须调用的。</p><p>当调用readyRun()，第一步是清楚存好的runTime，来阻止之前的调用被执行。然后创建一个新的定时器调用run()。由于setTimeout中用到的函数环境总是window，所以有必要保存this的引用方便使用。</p><p>这样的好处是即使1000ms内调用了readRun(),run()也只会调用一次。（毕竟人不可能一秒跑那么多步的好嘛！）</p><p>节流在resize，scorll事件中是最常用的。如果你基于该事件来改变页面布局的话，最好控制处理的频率，以确保浏览器不会再极短的时间内进行过多的计算。</p><p>这里先设计一个函数封装一下这个方法，方便以后常用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function throttle(fn, delay, context) &#123;</div><div class="line">clearTimeout(fn.throTime); //默认你给需要执行的函数里都有throTime属性</div><div class="line">fn.throTime = setTimeout(function() &#123;</div><div class="line">fn.call(context); //函数在指定环境执行</div><div class="line">&#125;, delay);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>写一个滑动滚轮改变盒子大小的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function changeBg() &#123;</div><div class="line">var div = document.getElementById(&quot;dragTarget&quot;);</div><div class="line">div.style.width = div.offsetWidth + 10 + &apos;px&apos;;</div><div class="line">div.style.height = div.offsetHeight + 10 + &apos;px&apos;;</div><div class="line">&#125;;</div><div class="line">下面使用优化一下onscroll的事件处理程序</div><div class="line">window.onscroll = function() &#123;</div><div class="line">throttle(changeBg, 100);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里多数情况下用户使感觉不到变化的，可是这大大节省了浏览器的计算。<br>只要代码是周期性执行的，都应该使用节流，并且适当控制速率。</p><h1 id="四、自定义事件"><a href="#四、自定义事件" class="headerlink" title="四、自定义事件"></a>四、自定义事件</h1><p>如果每个对象都有对其他所有对象的引用，那么整个代码就会紧密耦合，同时维护也变得很困难，因为对某个对象的修改也会影响到其他对象。使用自定义事件有助于解耦相关对象，保持功能的隔绝。</p><p>实际上，在很多情况下，触发事件的代码和舰艇事件的代码是完全分离的。</p><p>自定义事件背后的概念是创建一个管理事件的对象，让其他对象监听那些事件。实现此功能的基本模式可以如下定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">function EventTarget() &#123;</div><div class="line">this.handlers = &#123;&#125;; //  存放事件名的对象</div><div class="line">&#125;</div><div class="line">EventTarget.prototype = &#123;</div><div class="line">con: function() &#123; //输出当前存放的所有事件名</div><div class="line">console.log(JSON.stringify(this.handlers));</div><div class="line">&#125;,</div><div class="line">addHandler: function(type, handler) &#123; // 添加事件</div><div class="line">if(typeof this.handlers[type] == &quot;undefined&quot;) &#123;</div><div class="line">this.handlers[type] = []; // 如果没有就创建一个新的事件</div><div class="line">&#125;</div><div class="line">this.handlers[type].push(handler); //  把事件处理程序添加到事件的数组里面</div><div class="line">&#125;,</div><div class="line">fire: function(event) &#123; // 触发事件</div><div class="line">if(!event.target) &#123;</div><div class="line">event.target = this;</div><div class="line">&#125;</div><div class="line">if(this.handlers[event.type] instanceof Array) &#123;</div><div class="line">var handlers = this.handlers[event.type];</div><div class="line">for(var i = 0, len = handlers.length; i &lt; len; i++) &#123;</div><div class="line">handlers[i](event);</div><div class="line">&#125;</div><div class="line">&#125; else &#123;</div><div class="line">console.log(&apos;没有注册过该事件&apos;);</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line">removeHandler: function(type, handler) &#123; // 移除指定事件处理程序</div><div class="line">if(this.handlers[event.type] instanceof Array) &#123;</div><div class="line">var handlers = this.handlers[type];</div><div class="line">for(var i = 0, len = handlers.length; i &lt; len; i++) &#123;</div><div class="line">if(handlers[i] === handler) &#123; // 找到事件处理程序的位置，跳出循环</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125; else &#123;</div><div class="line">console.log(&apos;没有注册过该事件&apos;);</div><div class="line">&#125;</div><div class="line">handlers.splice(i, 1); // 删除事件处理程序</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后，使用EventTarget类型的自定义事件可以如下使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function handleMessage(event) &#123;</div><div class="line">console.log(&quot;Message received&quot; + event.message);</div><div class="line">&#125;</div><div class="line">var dom = new EventTarget();</div><div class="line">dom.addHandler(&quot;dianJi&quot;,handleMessage);</div><div class="line">dom.fire(&#123;type:&apos;dianJi&apos;, message: &apos;I am Click&apos;&#125;);// &quot;Message receivedI am Click&quot;</div><div class="line">dom.removeHandler(&quot;dianJi&quot;,handleMessage);</div><div class="line">dom.fire(&#123;type:&apos;dianJi&apos;, message: &apos;I am Click&apos;&#125;);// Error: Cannot read property &apos;type&apos; of undefined&quot;</div><div class="line">其他对象可以继承这种自定义对象</div><div class="line">function Person(name, age) &#123;</div><div class="line">this.name = name;</div><div class="line">this.age = age;</div><div class="line">&#125;</div><div class="line">Person.prototype = new EventTarget();</div><div class="line">var person = new Person(&apos;Tom&apos;, 20);</div><div class="line">function handleMessage(event) &#123;</div><div class="line">console.log(&quot;I talk &quot; + event.message);</div><div class="line">&#125;</div><div class="line">person.addHandler(&quot;say&quot;, handleMessage);</div><div class="line">person.fire(&#123;type:&apos;say&apos;, message:&apos;I am Person&apos;&#125;); // &quot;I talk I am Person&quot;</div></pre></td></tr></table></figure><h1 id="五、拖放"><a href="#五、拖放" class="headerlink" title="五、拖放"></a>五、拖放</h1><p>拖放是一种非常流行的用户界面模式。他的概念很简单：点击某个对象，并按住鼠标按钮不放，将鼠标移动到另一个区域，然后释放鼠标按钮将对象“放”在这里。</p><p>简单的拖放界面可用一下代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">var DragDrop = function() &#123;</div><div class="line">var dragging = null,// 拖放对象</div><div class="line">diffX = 0,</div><div class="line">diffY = 0;</div><div class="line">function handleEvent(event) &#123;</div><div class="line">// 获取事件和目标</div><div class="line">event = event || window.event;</div><div class="line">var target = event.target || window.event.target;</div><div class="line">switch(event.type) &#123;</div><div class="line">case &quot;mousedown&quot;:</div><div class="line">console.log(target)</div><div class="line">if(target.className.indexOf(&quot;draggable&quot;) &gt; -1) &#123;</div><div class="line">dragging = target;</div><div class="line">diffX = event.clientX - target.offsetLeft;</div><div class="line">diffY = event.clientY - target.offsetTop;</div><div class="line">&#125;</div><div class="line">break;</div><div class="line">case &quot;mousemove&quot;:</div><div class="line">if(dragging !== null) &#123;</div><div class="line">dragging.style.left = event.clientX - diffX + &apos;px&apos;;</div><div class="line">dragging.style.top = event.clientY - diffY + &apos;px&apos;;</div><div class="line">&#125;</div><div class="line">break;</div><div class="line">case &quot;mouseup&quot;:</div><div class="line">dragging = null;</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">return &#123;</div><div class="line">enable: function() &#123;</div><div class="line">document.addEventListener(&apos;mousedown&apos;, handleEvent);</div><div class="line">document.addEventListener(&apos;mousemove&apos;, handleEvent);</div><div class="line">document.addEventListener(&apos;mouseup&apos;, handleEvent);</div><div class="line">&#125;,</div><div class="line">disable: function() &#123;</div><div class="line">document.removeEventListener(&apos;mousedown&apos;, handleEvent);</div><div class="line">document.removeEventListener(&apos;mousemove&apos;, handleEvent);</div><div class="line">document.removeEventListener(&apos;mouseup&apos;, handleEvent);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">DragDrop().enable();</div></pre></td></tr></table></figure></p><p>DragDrop对象封装了拖放的所有基本功能。拖放的时候回自动针对所有包含“draggable”类的元素启用。</p><blockquote><p>为了元素能被拖放，它必须是绝对定位的。</p></blockquote><p>结合前面的自定义事件完善该功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">var dragdrop = new EventTarget();</div><div class="line">var DragDrop = function() &#123;</div><div class="line">var dragging = null,</div><div class="line">diffX = 0,</div><div class="line">diffY = 0;</div><div class="line"></div><div class="line">function handleEvent(event) &#123;</div><div class="line">event = event || window.event;</div><div class="line">var target = event.target;</div><div class="line">switch(event.type) &#123;</div><div class="line">case &quot;mousedown&quot;:</div><div class="line">if(target.className.indexOf(&quot;draggable&quot;) &gt; -1) &#123;</div><div class="line">dragging = target;</div><div class="line">diffX = event.clientX - target.offsetLeft;</div><div class="line">diffY = event.clientY - target.offsetTop;</div><div class="line">//  这里触发自定义事件，比如：</div><div class="line">dragdrop.fire(&#123;</div><div class="line">type: &quot;dragStart&quot;,</div><div class="line">target: dragging</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">break;</div><div class="line">case &quot;mousemove&quot;:</div><div class="line">if(dragging !== null) &#123;</div><div class="line">dragging.style.left = event.clientX - diffX + &apos;px&apos;;</div><div class="line">dragging.style.top = event.clientY - diffY + &apos;px&apos;;</div><div class="line">//  这里触发自定义事件，比如：</div><div class="line">dragdrop.fire(&#123;</div><div class="line">type: &quot;dragging&quot;,</div><div class="line">target: dragging</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">break;</div><div class="line">case &quot;mouseup&quot;:</div><div class="line">//  这里触发自定义事件，比如：</div><div class="line">dragdrop.fire(&#123;</div><div class="line">type: &quot;dragend&quot;,</div><div class="line">target: dragging</div><div class="line">&#125;);</div><div class="line">dragging = null;</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">dragdrop.enable = function() &#123;</div><div class="line">document.addEventListener(&apos;mousedown&apos;, handleEvent);</div><div class="line">document.addEventListener(&apos;mousemove&apos;, handleEvent);</div><div class="line">document.addEventListener(&apos;mouseup&apos;, handleEvent);</div><div class="line">&#125;</div><div class="line">dragdrop.disable = function() &#123;</div><div class="line">document.removeEventListener(&apos;mousedown&apos;, handleEvent);</div><div class="line">document.removeEventListener(&apos;mousemove&apos;, handleEvent);</div><div class="line">document.removeEventListener(&apos;mouseup&apos;, handleEvent);</div><div class="line">&#125;</div><div class="line">return dragdrop;</div><div class="line">&#125;</div><div class="line">DragDrop().addHandler(&quot;dragStart&quot;, function(event) &#123;</div><div class="line">event.target.innerHTML = &quot;准备移动！&quot;;</div><div class="line">&#125;);</div><div class="line">DragDrop().addHandler(&quot;dragging&quot;, function(event) &#123;</div><div class="line">event.target.innerHTML = &quot;正在移动ing！&quot;;</div><div class="line">&#125;);</div><div class="line">DragDrop().addHandler(&quot;dragend&quot;, function(event) &#123;</div><div class="line">event.target.innerHTML = &quot;移动结束！&quot;;</div><div class="line">&#125;);</div><div class="line">DragDrop().enable();</div></pre></td></tr></table></figure><p>其实这里有个坑跟书上的不一样，就是new EventTarget()要在外一层new。</p><hr><blockquote><h1 id="以上就是《JavaScript高级程序设计》书上的高级技巧和本人对这些知识点的一些理解，所码的文章。"><a href="#以上就是《JavaScript高级程序设计》书上的高级技巧和本人对这些知识点的一些理解，所码的文章。" class="headerlink" title="以上就是《JavaScript高级程序设计》书上的高级技巧和本人对这些知识点的一些理解，所码的文章。"></a>以上就是《JavaScript高级程序设计》书上的高级技巧和本人对这些知识点的一些理解，所码的文章。</h1><p>本文经常更新知识点以及修正一些错误，因此转载请保留原出处，方便溯源，避免陈旧错误知识的误导，同时有更好的阅读体验。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h1 id=&quot;摘要：&quot;&gt;&lt;a href=&quot;#摘要：&quot; class=&quot;headerlink&quot; title=&quot;摘要：&quot;&gt;&lt;/a&gt;摘要：&lt;/h1&gt;&lt;p&gt;博客开了几个月了也没写什么，想着还是随手写一点吧，也有助于自己的加深理解。最近又在看《JavaScript
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>这是我的第一篇文章</title>
    <link href="http://yoursite.com/2017/07/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E7%AB%A0/"/>
    <id>http://yoursite.com/2017/07/25/我的第一个文章/</id>
    <published>2017-07-25T03:00:58.446Z</published>
    <updated>2017-09-30T05:33:57.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><ul><li>[x]  <strong>npm i hexo –save</strong></li><li>点击<a href="http://note.youdao.com/" target="_blank" rel="external">这里</a>访问我的博客</li><li><img src="http://note.youdao.com/favicon.ico" alt="ddd"></li><li>谢谢</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装hexo&quot;&gt;&lt;a href=&quot;#安装hexo&quot; class=&quot;headerlink&quot; title=&quot;安装hexo&quot;&gt;&lt;/a&gt;安装hexo&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;[x]  &lt;strong&gt;npm i hexo –save&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/07/24/hello-world/"/>
    <id>http://yoursite.com/2017/07/24/hello-world/</id>
    <published>2017-07-24T05:09:23.631Z</published>
    <updated>2017-09-30T05:35:07.453Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
