<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Akira</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-17T10:19:05.649Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Akira</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript — 动态规划&amp;&amp;贪心算法</title>
    <link href="http://yoursite.com/2017/10/17/JavaScript%20%E2%80%94%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&amp;&amp;%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/10/17/JavaScript — 动态规划&amp;&amp;贪心算法/</id>
    <published>2017-10-17T10:14:30.210Z</published>
    <updated>2017-10-17T10:19:05.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>是一种将复杂问题分解成更小的子问题来解决的优化技术。</p><p>用动态规划解决问题时，要遵循三个重要步骤：</p><blockquote><p>（1）、定义子问题</p><p>（2）、实现要反复执行来解决子问题的部分</p><p>（3）、识别并求解出边界条件\</p></blockquote><hr><h2 id="1、最少硬币找零问题"><a href="#1、最少硬币找零问题" class="headerlink" title="1、最少硬币找零问题"></a>1、最少硬币找零问题</h2><p> 最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额d1…dn及其数量，找到所需最少的硬币个数。</p><p> 例如：有以下面额（硬币）：d1=1,d2=5,d3=10,d4=25</p><p> 如果要找36美分的零钱，我们可以用1个25、1个10、1个1美分。</p><p> 下面将这个解答转化成算法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">function MinCoinChange(coins_) &#123;</div><div class="line">    let coins = coins_;</div><div class="line">    let cache = &#123;&#125;;</div><div class="line"></div><div class="line">    this.makeChange = function(amount) &#123;</div><div class="line">        let me = this;</div><div class="line">        if(!amount) &#123;</div><div class="line">            return [];</div><div class="line">        &#125;</div><div class="line">        if(cache[amount]) &#123;</div><div class="line">            return cache[amount];</div><div class="line">        &#125;</div><div class="line">        let min = [], newMin, newAmount;</div><div class="line">        for(let i = 0; i&lt;coins.length; i++) &#123;</div><div class="line">            let coin = coins[i];</div><div class="line">            newAmount = amount - coin;</div><div class="line">            if(newAmount &gt;= 0) &#123;</div><div class="line">                newMin = me.makeChange(newAmount);</div><div class="line">            &#125;</div><div class="line">            if(newAmount &gt;= 0 &amp;&amp; </div><div class="line">                (newMin.length &lt; min.length - 1 || !min.length ) &amp;&amp;</div><div class="line">                (newMin.length || !newAmount) </div><div class="line">            ) &#123;</div><div class="line">                min = [coin].concat(newMin);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return cache[amount] = min;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var minCoinChange = new MinCoinChange([1,5,10,25]);</div><div class="line">console.log(minCoinChange.makeChange(36));</div></pre></td></tr></table></figure><hr><h2 id="2、背包问题"><a href="#2、背包问题" class="headerlink" title="2、背包问题"></a>2、背包问题</h2><p> 背包问题是一个组合优化问题。描述如下：给定一个固定大小、能够携重W的背包，以及一组有价值和重量的物品。</p><p> 在物品不重复情况下，找出一个最佳解决方案，使得装入背包的物品总重量不超过W，且总价值最大。</p><p> 比如：<br> 糖果：重量2 价值3，饼干：重量3 价值4，牛奶：重量4 价值5。</p><p> 考虑背包只能携带重量只有5。对于这个例子，最佳方案是往背包里装糖果和饼干，这样，总重量为5，总价值为7。<br> 转化为算法如下（返回的是价值量）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">function knapSack(capacity, weights, values, n) &#123;</div><div class="line">    let i, w, a, b, kS = [];</div><div class="line">    for(i = 0; i &lt;= n; i++) &#123;</div><div class="line">        kS[i] = [];</div><div class="line">    &#125;</div><div class="line">    for(i = 0; i &lt;= n; i++) &#123;</div><div class="line">        for(w = 0; w &lt;= capacity; w++) &#123;</div><div class="line">            if(i == 0 || w == 0) &#123;</div><div class="line">                kS[i][w] = 0;</div><div class="line">            &#125; else if (weights[i-1] &lt;= w) &#123;</div><div class="line">                a = values[i-1] + kS[i-1][w-weights[i-1]];</div><div class="line">                b = kS[i-1][w];</div><div class="line">                kS[i][w] = (a &gt; b) ? a : b;</div><div class="line">            &#125; else &#123;</div><div class="line">                kS[i][w] = kS[i-1][w];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    findValues(n, capacity, kS, weights, values);</div><div class="line">    return kS[n][capacity];</div><div class="line">&#125;</div><div class="line">let findValues = (n, capacity, kS, weights, values) =&gt; &#123;</div><div class="line">    let i = n, k = capacity;</div><div class="line">    console.log(&apos;解决方案包含以下物品&apos;);</div><div class="line">    while(i &gt; 0 &amp;&amp; k &gt; 0) &#123;</div><div class="line">        if(kS[i][k] !== kS[i-1][k]) &#123;</div><div class="line">            console.log(&apos;物品&apos; + i + &apos;，重量:&apos; + weights[i-1] + &apos;,价值:&apos; + values[i-1]);</div><div class="line">            i--;</div><div class="line">            k = k - kS[i][k];</div><div class="line">        &#125; else &#123;</div><div class="line">            i--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let values = [3,4,5],</div><div class="line">    weights = [2,3,4],</div><div class="line">    capacity = 6,</div><div class="line">    n = values.length;</div><div class="line">console.log(knapSack(capacity, weights, values, n));</div></pre></td></tr></table></figure><hr><h1 id="二、贪心算法"><a href="#二、贪心算法" class="headerlink" title="二、贪心算法"></a>二、贪心算法</h1><p> 贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解）。从而达到全局最优。它不像DP（动态规划）那样计算更大的格局。</p><p> 我们来看看如何用贪心算法解决“最少硬币找零问题”和“背包问题”。</p><p> 1、最少硬币找零问题</p><p> 用贪心算法解决。大部分情况下的结果是最优的，不过对有些面额而言，结果不会是最优的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function MinCoinChange(coins_) &#123;</div><div class="line">    let coins = coins_;</div><div class="line">    this.makeChange = function(amount) &#123;</div><div class="line">        let change = [],</div><div class="line">            total = 0;</div><div class="line">        for(let i = coins.length; i &gt;= 0; i--) &#123;</div><div class="line">            let coin =coins[i];</div><div class="line">            while (total + coin &lt;= amount) &#123;</div><div class="line">                change.push(coin);</div><div class="line">                total += coin;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return change;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不得不说贪心版本比DP简单多了。</p><p>这个解法很简单，从最大面额的硬币开始，拿尽可能多的这种硬币找零。当无法再拿更多这种价值的硬币时，开始拿第二大价值的硬币，依次继续.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let minCoinChange = new MinCoinChange([1,5,18,25]);</div><div class="line">console.log(minCoinChange.makeChange(36)); // [25,10,1]</div></pre></td></tr></table></figure><p>然而，因为是从最大面额开始，如果上面面额改为[1,5,18,25]。会得到结果[25,5,5,1]，如果用DP的解法，会得到最优结果[18,18]</p><hr><h2 id="2、分数背包问题"><a href="#2、分数背包问题" class="headerlink" title="2、分数背包问题"></a>2、分数背包问题</h2><p>分数背包问题和DP的稍有不同。分数背包问题中，我们可以装入分散的物品。</p><p> 比如：我们考虑的容量为6的情况下，DP返回的是8，分数背包返回的是8.25。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function knapSack(capacity, weights, values, n_) &#123;</div><div class="line">    let n  = n_,</div><div class="line">    load = 0, i = 0, val = 0;</div><div class="line"></div><div class="line">    for(i = 0; i &lt; n &amp;&amp; load &lt;= capacity; i++) &#123;</div><div class="line">        if(weights[i] &lt;= (capacity - load)) &#123;</div><div class="line">            val += values[i];</div><div class="line">            load += weights[i];</div><div class="line">            console.log(i, val);</div><div class="line">        &#125; else &#123;</div><div class="line">            let r = (capacity - load) / weights[i];</div><div class="line">            val += r * values[i];</div><div class="line">            load += weights[i];</div><div class="line">            console.log(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return val;</div><div class="line">&#125;</div><div class="line">let values = [3,4,5],</div><div class="line">    weights = [2,3,4],</div><div class="line">    capacity = 6,</div><div class="line">    n = values.length;</div><div class="line">console.log(knapSack(capacity, weights, values, n));</div></pre></td></tr></table></figure><p> 主要就是如果物品不能完整装入背包，计算能够装入部分的比例。</p><hr><h1 id="结语：一个程序猿还是需要掌握一点算法知识，这是不会错的。"><a href="#结语：一个程序猿还是需要掌握一点算法知识，这是不会错的。" class="headerlink" title="结语：一个程序猿还是需要掌握一点算法知识，这是不会错的。"></a>结语：一个程序猿还是需要掌握一点算法知识，这是不会错的。</h1><p><img src="/images/DP/end.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;p&gt;是一种将复杂问题分解成更小的子问题来解决的优化技术。&lt;/p&gt;
&lt;p&gt;用动态规划解决问题时，要遵循三个重要步骤：&lt;/p&gt;
&lt;b
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>addEventListener中事件用bind指向this后,无法移除事件问题.</title>
    <link href="http://yoursite.com/2017/10/17/addEventListener%20%E4%B8%AD%20%E4%BA%8B%E4%BB%B6%E7%94%A8bind%E6%8C%87%E5%90%91this%20%E5%90%8E%EF%BC%8C%E6%97%A0%E6%B3%95%E7%A7%BB%E9%99%A4%E4%BA%8B%E4%BB%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/10/17/addEventListener 中 事件用bind指向this 后，无法移除事件问题/</id>
    <published>2017-10-17T10:14:28.263Z</published>
    <updated>2017-10-17T10:13:06.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="addEventListener-中-事件用bind指向this-后，无法移除事件问题"><a href="#addEventListener-中-事件用bind指向this-后，无法移除事件问题" class="headerlink" title="addEventListener 中 事件用bind指向this 后，无法移除事件问题"></a>addEventListener 中 事件用bind指向this 后，无法移除事件问题</h1><p>今天写BUG的时候，要在一个touchstart事件内添加 touchmove和touchend的事件注册。</p><p>然后，在touchend的时候再把2个事件给移除了。</p><p>之前一直不是很在意bind，apply，call一些细节的的我就在这里吃了亏，果然出来混的迟早要还的。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dom.addEventListener(&apos;touchstart&apos;, fTouchstart.bind(this));</div><div class="line">function fTouchstart(e) &#123;</div><div class="line">    console.log(&apos;start:&apos; + e, this); // TouchEvent对象，实例对象</div><div class="line">    dom.addEventListener(&apos;touchmove&apos;, fTouchmove.bind(this));</div><div class="line">    dom.addEventListener(&apos;touchend&apos;, fTouchend.bind(this));</div><div class="line">&#125;</div><div class="line"></div><div class="line">function fTouchmove(e) &#123;</div><div class="line">    console.log(‘move:’ + e, this); // TouchEvent对象，实例对象</div><div class="line">    dom.removeEventListener(&apos;touchmove&apos;, fTouchmove);</div><div class="line">    dom.removeEventListener(&apos;touchend&apos;, fTouchend);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后在浏览器上换成移动端在dom上点击几次，你会发现end事件执行次数之后每次会递增1。</p><hr><h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>bind方法返回了一个新的函数。在removeEventListener中移除的事件并没有绑定在TouchEvnent上，绑定上去的是bind()方法每次返回的函数。</p><hr><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>在外面保存bind()返回函数的引用。</p><p>修改上面代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 保存引用</div><div class="line">var fTouchstart_ = fTouchstart.bind(this),</div><div class="line">    fTouchmove_ = fTouchmove.bind(this),</div><div class="line">fTouchend_ = fTouchend.bind(this);</div><div class="line"></div><div class="line">dom.addEventListener(&apos;touchstart&apos;, fTouchstart_);</div><div class="line">function fTouchstart(e) &#123;</div><div class="line">    console.log(&apos;start:&apos; + e, this); // TouchEvent对象，实例对象</div><div class="line">    dom.addEventListener(&apos;touchmove&apos;, fTouchmove_);</div><div class="line">    dom.addEventListener(&apos;touchend&apos;, fTouchend_);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function fTouchmove(e) &#123;</div><div class="line">    console.log(‘move:’ + e, this); // TouchEvent对象，实例对象</div><div class="line">    dom.removeEventListener(&apos;touchmove&apos;, fTouchmove_);</div><div class="line">    dom.removeEventListener(&apos;touchend&apos;, fTouchend_);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;addEventListener-中-事件用bind指向this-后，无法移除事件问题&quot;&gt;&lt;a href=&quot;#addEventListener-中-事件用bind指向this-后，无法移除事件问题&quot; class=&quot;headerlink&quot; title=&quot;addEve
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript — 搜索算法</title>
    <link href="http://yoursite.com/2017/10/17/JavaScript%20%E2%80%94%20%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/10/17/JavaScript — 搜索算法/</id>
    <published>2017-10-17T10:14:21.482Z</published>
    <updated>2017-10-17T10:13:45.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-—-搜索算法"><a href="#JavaScript-—-搜索算法" class="headerlink" title="JavaScript — 搜索算法"></a>JavaScript — 搜索算法</h1><hr><h1 id="1、顺序搜索"><a href="#1、顺序搜索" class="headerlink" title="1、顺序搜索"></a>1、顺序搜索</h1><p>顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。</p><p>顺序搜索也是最低效的一种搜索算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let sequentialSearch = (arr, item) =&gt; &#123; // 传入数组和要找到的元素</div><div class="line">for(let i = 0, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">if(item === arr[i]) &#123;</div><div class="line">return i;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>顺序搜索迭代整个数组，将每个数组元素和搜索项作比较，如果搜索到了，将返回特定值（索引，值，布尔值）。</p><hr><h1 id="2、二分搜索"><a href="#2、二分搜索" class="headerlink" title="2、二分搜索"></a>2、二分搜索</h1><p>这个算法要求被搜索的数据结构已排序。</p><p>分为四个步骤：</p><blockquote><p>（1）、选择数组的中间值。</p><p>（2）、如果选中值是待搜索值，那么算法执行完毕。</p><p>（3）、如果待搜索值比选中值小，则返回步骤1并在选中值的左边的子数组中寻找。</p><p>（4）、如果待搜索值比选中值大，则返回步骤1并在选中值的右边的子数组中寻找。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let binarySearch = (arr, item) =&gt; &#123;</div><div class="line">arr.quickSort(); // 先从小到大排序</div><div class="line">let low = 0,</div><div class="line">high = arr.length - 1;</div><div class="line">mid, element;</div><div class="line">while(low &lt;= high) &#123;</div><div class="line">mid = ((low + high) / 2);</div><div class="line">element = arr[mid];</div><div class="line">if(element &lt; item) &#123;</div><div class="line">low = mid + 1;</div><div class="line">&#125; else if(element &gt; item) &#123;</div><div class="line">high = mid - 1;</div><div class="line">&#125; else &#123;</div><div class="line">return mid;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript-—-搜索算法&quot;&gt;&lt;a href=&quot;#JavaScript-—-搜索算法&quot; class=&quot;headerlink&quot; title=&quot;JavaScript — 搜索算法&quot;&gt;&lt;/a&gt;JavaScript — 搜索算法&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript — 基本算法学习</title>
    <link href="http://yoursite.com/2017/10/17/JavaScript%20%E2%80%94%20%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2017/10/17/JavaScript — 基本算法学习/</id>
    <published>2017-10-17T10:14:19.207Z</published>
    <updated>2017-10-17T10:13:26.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-—-基本算法学习"><a href="#JavaScript-—-基本算法学习" class="headerlink" title="JavaScript — 基本算法学习"></a>JavaScript — 基本算法学习</h1><blockquote><p>学JS也挺久了也很少接触算法，最近看到《学习JavaScript数据结构与算法》出了第二版，还是很新的一门教材。就买来拜读了一下，然后整理下学习到的知识，方便日后温习。</p></blockquote><p><em>PS:下面所有算法，我们都最多用push方法向数据结构添加元素，这样刻意简单，这是为了能够专注排序和搜索算法，语法为ES6。</em></p><hr><h1 id="1、冒泡排序-—-O-n²"><a href="#1、冒泡排序-—-O-n²" class="headerlink" title="1、冒泡排序 — O(n²)"></a>1、冒泡排序 — O(n²)</h1><p>说明：冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素向上移动至正确的顺序，就好像气泡升至表面一样。</p><p>tips：冒泡排序是性能最差的一个算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let bubbleSort = (arr) &gt;= &#123;</div><div class="line">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">        for (let j = 0; j &lt; len - 1; j++) &#123;</div><div class="line">if(arr[j] &gt; arr[j + 1]) &#123;</div><div class="line">[ arr[i], arr[j + 1] ] = [ arr[j + 1], arr[i] ];</div><div class="line">&#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">let arr = [5,4,3,2,1];</div><div class="line">bubbleSort(arr);</div><div class="line">console.log(arr); // [1,2,3,4,5]</div></pre></td></tr></table></figure><p>注意当函数执行到 i=1 的时候，数字4和5已经是正确的排序了。尽管如此，后续比较中，它们还一直在进行着比较，即使这是不必要的。<br>如果从内循环减去外循环中已跑过的轮数，就可以避免内循环中所有不必要的比较了。改进后的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let modBubbleSort = (arr) &gt;= &#123;</div><div class="line">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">        for (let j = 0; j &lt; len - 1 - i; j++) &#123;</div><div class="line">if(arr[j] &gt; arr[j + 1]) &#123;</div><div class="line">[ arr[i], arr[j + 1] ] = [ arr[j + 1], arr[i] ];</div><div class="line">&#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">let arr = [5,4,3,2,1];</div><div class="line">modBubbleSort(arr);</div><div class="line">console.log(arr); // [1,2,3,4,5]</div></pre></td></tr></table></figure><hr><h1 id="2、选择排序-—-O-n²"><a href="#2、选择排序-—-O-n²" class="headerlink" title="2、选择排序 — O(n²)"></a>2、选择排序 — O(n²)</h1><p>说明：选择排序大概思路是找到数据结构中最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let selectionSort = (arr) &gt;= &#123;</div><div class="line">let len = arr.length,</div><div class="line">indexMin;</div><div class="line">for(let i = 0; i &lt; len -1; i++) &#123;</div><div class="line">indexMin = i;</div><div class="line">for(let j = i; j &lt; len; j++) &#123; // 找到最小值的索引</div><div class="line">if(arr[indexMin] &gt; arr[j]) &#123;</div><div class="line">indexMin = j;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">[ arr[i], arr[indexMin] ] = [ arr[indexMin], arr[i] ];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">let arr = [5,4,3,2,1];</div><div class="line">selectionSort(arr);</div><div class="line">console.log(arr); // [1,2,3,4,5]</div></pre></td></tr></table></figure><hr><h1 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h1><p>从第二项开始和第一项比较，如果第一项大于第二项则换位。</p><p>然后比较第三项和前面两项，如果第二比第三大则换位，再比较第一和第二，如果第一比第二大则换位，否则不动。</p><p>tip:排序小型数组时，此算法比选择排序和冒泡性能要好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let insertionSort = (arr) &gt;= &#123;</div><div class="line">let len = arr.length,</div><div class="line">j, temp;</div><div class="line">for(let i = 1; i &lt; len; i++) &#123; // 从arr[i]开始循环</div><div class="line">j = i; // 比较j次</div><div class="line">temp = arr[i];</div><div class="line">while(j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp) &#123;</div><div class="line">arr[j] = arr[j-1];</div><div class="line">j--;</div><div class="line">&#125;</div><div class="line">arr[j] = temp;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">let arr = [5,4,3,2,1];</div><div class="line">insertionSort(arr);</div><div class="line">console.log(arr); // [1,2,3,4,5]</div></pre></td></tr></table></figure><hr><h1 id="4、归并排序-—-O-nlog-n"><a href="#4、归并排序-—-O-nlog-n" class="headerlink" title="4、归并排序 — O(nlog^n)"></a>4、归并排序 — O(nlog^n)</h1><p>JavaScript的Arry类定义了一个sort函数用以排序数组。ECMAScript没有定义哪个排序算法，所以浏览器厂商可以自行去实现算法。</p><p>Fierfox使用归并排序作为sort的实现，Chrome使用了快速排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">let mergeSort = (arr) &gt;= &#123;</div><div class="line">arr = mergeSortRec(arr);</div><div class="line">&#125;</div><div class="line">let mergeSortRec = (arr) &gt;= &#123;</div><div class="line">let len = arr.length;</div><div class="line">if(len === 1) &#123;</div><div class="line">return arr;</div><div class="line">&#125;</div><div class="line">let mid = (len / 2) | 0;</div><div class="line">left = arr.slice(0, mid);</div><div class="line">right = arr.slice(mid, len);</div><div class="line"></div><div class="line">return merge(mergeSortRec(left), mergeSortRec(right));</div><div class="line">&#125;</div><div class="line">let merge = (left, right) &gt;= &#123;</div><div class="line">let result = [],</div><div class="line">il = 0,</div><div class="line">ir = 0;</div><div class="line">while(il &lt; left.length &amp;&amp; ir &lt; right.length) &#123;</div><div class="line">if(left[il] &lt; right[ir]) &#123;</div><div class="line">result.push(left[il++]);</div><div class="line">&#125; else &#123;</div><div class="line">result.push(right[ir++]);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">while(il &lt; left.length) &#123;</div><div class="line">result.push(left[il++]);</div><div class="line">&#125;</div><div class="line">while(ir &lt; right.length) &#123;</div><div class="line">result.push(right[ir++]);</div><div class="line">&#125;</div><div class="line">return result;</div><div class="line">&#125;</div><div class="line">let arr = [5,4,3,2,1];</div><div class="line">mergeSort(arr);</div><div class="line">console.log(arr); // [1,2,3,4,5]</div></pre></td></tr></table></figure><hr><h1 id="5、快速排序-—-O-nlog-n"><a href="#5、快速排序-—-O-nlog-n" class="headerlink" title="5、快速排序 — O(nlog^n)"></a>5、快速排序 — O(nlog^n)</h1><p>快速排序复杂度比一般的 O(nlog^n) 要好。</p><p>和归并排序一样，快速排序也使用分治方法，将原始数组分为较小的数组。（但没有像归并那样将它们分隔开）</p><p>分为三个步骤：</p><blockquote><p>（1）、从数组中选择中间一项作为主元（不推荐从数组第一项作为主元，最好是随机选择一个数组项或是中间项）。</p><p>（2）、创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指针直到我们找到比主元大的元素，<br>    接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这步叫划分操作。</p><p>（3）、接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前两个步骤，直至数组完全排序</p></blockquote><p> 参考：<a href="http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html" target="_blank" rel="external">快速排序（Quicksort）的Javascript实现 - 阮一峰</a> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function quickSort(arr) &#123;</div><div class="line">    if (arr.length &lt;= 1) return arr;</div><div class="line">    var mid = ~~(arr.length / 2),</div><div class="line">        midItem = arr.splice(mid, 1)[0],</div><div class="line">        left = [],</div><div class="line">        right = [];</div><div class="line"></div><div class="line">    arr.forEach(function(item) &#123;</div><div class="line">        if (item &lt;= midItem) left.push(item);</div><div class="line">        else right.push(item);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    var _left = quickSort(left),</div><div class="line">        _right = quickSort(right);</div><div class="line"></div><div class="line">    return _left.concat(midItem, _right);</div><div class="line">&#125;</div><div class="line">let arr = [5, 4, 3, 2, 1];</div><div class="line">console.log(quickSort(arr)); // [1,2,3,4,5]</div></pre></td></tr></table></figure><p>参考：<a href="http://www.cnblogs.com/zichi/p/4788953.html" target="_blank" rel="external">【前端也要学点算法】快速排序的JavaScript实现 - 韩子迟 - 博客园 </a> </p><p>如果需要排序的数组有大量重复元素，可以用基于三向切分的快速排序大幅度提高效率。<br>基础的快排，每一次递归，我们将数组拆分为两个，递归出口是数组长度为 &lt;=1。思考这样一个场景，递归过程中某个数组为 [1, 1, 1, 1, 1, 1, 1, 1]，如果是原始的快排，还需要继续递归下去，实际上已经不需要。所以我们可以用三向切分，简单地说就是将数组切分为三部分，大于基准元素，等于基准元素，小于基准元素。</p><p>我们可以设置一个 mid 数组用来保存等于基准元素的元素集合，以前取的基准元素是数组中间位置的元素，其实任意一个即可，这里选了最后一个，比较方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function quickSort3Way(a) &#123;</div><div class="line">    if (a.length &lt;= 1) return a;</div><div class="line">  </div><div class="line">    var last = a.pop()</div><div class="line">      , left = []</div><div class="line">      , right = []</div><div class="line">      , mid = [last];</div><div class="line">  </div><div class="line">    a.forEach(function(item) &#123;</div><div class="line">      if (item &lt; last)</div><div class="line">        left.push(item);</div><div class="line">      else if (item &gt; last)</div><div class="line">        right.push(item);</div><div class="line">      else</div><div class="line">        mid.push(item);</div><div class="line">    &#125;);</div><div class="line">  </div><div class="line">    var _left = quickSort3Way(left)</div><div class="line">      , _right = quickSort3Way(right);</div><div class="line">  </div><div class="line">    return _left.concat(mid, _right);</div><div class="line">&#125;</div><div class="line">let arr = [5, 4, 3, 2, 1];</div><div class="line">console.log(quickSort3Way(arr)); // [1,2,3,4,5]</div></pre></td></tr></table></figure><p>一行代码写快排</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function quickSort(a) &#123;</div><div class="line">    return a.length &lt;= 1 ? a : quickSort(a.slice(1).filter(item =&gt; item &lt;= a[0])).concat(a[0], quickSort(a.slice(1).filter(item =&gt; item &gt; a[0])));</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h1 id="6、堆排序"><a href="#6、堆排序" class="headerlink" title="6、堆排序"></a>6、堆排序</h1><p>堆排序是一种把数组当做二叉树来排序的算法。</p><p>分为四个步骤：</p><blockquote><pre><code>（1）、索引0是树的根节点。（2）、除根节点外，任意节点N的父节点是N/2（3）、节点L的左子节点是2*L（4）、节点L的右子节点是2*R+1</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let heapSort = (arr) =&gt; &#123;</div><div class="line">let heapSize = arr.length;</div><div class="line">build(arr);</div><div class="line">while(heapSize &gt; 1) &#123;</div><div class="line">heapSize--;</div><div class="line">[ arr[0], arr[heapSize] ] = [ arr[heapSize], arr[0] ];</div><div class="line">heapify(arr, heapSize, 0);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第一步，构造一个满足arr[parent(i)] &gt;= arr[i]的堆结构。</p><p>第二步，交换堆里的第一个元素和最后一个元素的位置交换，这样，最大的值就会出现在它已排序的位置。</p><p>第二步可能会丢掉堆的属性。因此我们还需要执行一个heapify函数，再次将数组转换成堆，也就是说，它会找到当前堆的根节点，重新放到树的底部。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">let build = (arr) =&gt; &#123;</div><div class="line">let heapSize = arr.length;</div><div class="line">for(let i = (arr.length / 2) | 0; i &gt;= 0; i--) &#123;</div><div class="line">heapify(arr, heapSize, i);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">let heapify = (arr, heapSize, i) =&gt; &#123;</div><div class="line">let left = i * 2 + 1,</div><div class="line">right = i * 2 + 2,</div><div class="line">largest = i;</div><div class="line">if(left &lt; heapSize &amp;&amp; arr[left] &gt; arr[largest]) &#123;</div><div class="line">largest = left;</div><div class="line">&#125;</div><div class="line">if(right &lt; heapSize &amp;&amp; arr[right] &gt; arr[largest]) &#123;</div><div class="line">largest = right;</div><div class="line">&#125;</div><div class="line">if(largest !== i) &#123;</div><div class="line">[ arr[i], arr[largest] ] = [ arr[largest], arr[i] ];</div><div class="line">heapify(arr, heapSize, largest)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">let arr = [5,4,3,2,1];</div><div class="line">heapSort(arr);</div><div class="line">console.log(arr); // [1,2,3,4,5]</div></pre></td></tr></table></figure><hr><h1 id="7、计数排序-—-Ο-n-k"><a href="#7、计数排序-—-Ο-n-k" class="headerlink" title="7、计数排序 — Ο(n+k)"></a>7、计数排序 — Ο(n+k)</h1><p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组Count_arr，其中第i个元素是待排序数组arr中值等于i的元素的个数。然后根据数组Count_arr来将arr中的元素排到正确的位置。</p><p>分为四个步骤：</p><p>（1）、找出待排序的数组中最大和最小的元素。</p><p>（2）、统计数组中每个值为i的元素出现的次数，存入数组Count_arr的第i项。</p><p>（3）、对所有的计数累加（从Count_arr中的第一个元素开始，每一项和前一项相加）。</p><p>（4）、反向遍历原数组：将每个元素i放在新数组的第Count_arr(i)项，每放一个元素就将Count_arr(i)减去1。</p><p>tip：计数排序是一个非基于比较的排序算法，快于任何比较排序算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function countSort(arr, min, max) &#123;</div><div class="line">    let i, z = 0, count = [];</div><div class="line"></div><div class="line">    for (i = min; i &lt;= max; i++) &#123;</div><div class="line">        count[i] = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (i=0; i &lt; arr.length; i++) &#123;</div><div class="line">        count[arr[i]]++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (i = min; i &lt;= max; i++) &#123;</div><div class="line">        while (count[i]-- &gt; 0) &#123;</div><div class="line">            arr[z++] = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;</div><div class="line">let arr = [5,4,3,2,1];</div><div class="line">countSort(arr, 0, 5);</div><div class="line">console.log(arr); // [1,2,3,4,5]</div></pre></td></tr></table></figure><hr><h1 id="8、桶排序"><a href="#8、桶排序" class="headerlink" title="8、桶排序"></a>8、桶排序</h1><p>桶排序是一种基于计数的排序算法，工作原理是将数据分到有限数量的桶子里，然后每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。</p><p>当要被排序的数据内的数值是均匀分配的时候（每个桶下的数量相等），桶排序时间复杂度为 O(n)。</p><p>分为四个步骤：</p><blockquote><p>（1）设置固定数量的空桶。</p><p>（2）把数据放到对应的桶中。</p><p>（3）对每个不为空的桶中数据进行排序。</p><p>（4）拼接从不为空的桶中数据，得到结果。</p></blockquote><p>参考: <a href="http://blog.csdn.net/u013063153/article/details/52667542" target="_blank" rel="external">JavaScript十大经典排序算法 - CSDN博客</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">let bucketSort = (arr, num) =&gt; &#123; // arr为数组，num为桶的数量</div><div class="line">    if (arr.length &lt;= 1) &#123;</div><div class="line">        returnarray;</div><div class="line">    &#125;</div><div class="line">    let len = arr.length,</div><div class="line">        buckets = [],</div><div class="line">        result = [],</div><div class="line">        min = (max = arr[0]),</div><div class="line">        regex = &quot;/^[1-9]+[0-9]*$/&quot;,</div><div class="line">        space,</div><div class="line">        n = 0;</div><div class="line">    num = num || (num &gt; 1 &amp;&amp; regex.test(num) ? num : 10);</div><div class="line">    console.time(&quot;桶排序耗时:&quot;);</div><div class="line">    for (let i = 1; i &lt; len; i++) &#123;</div><div class="line">        min = min &lt;= arr[i] ? min : arr[i];</div><div class="line">        max = max &gt;= arr[i] ? max : arr[i];</div><div class="line">    &#125;</div><div class="line">    space = (max - min + 1) / num;</div><div class="line">    for (let j = 0; j &lt; len; j++) &#123;</div><div class="line">        let index = Math.floor((arr[j] - min) / space);</div><div class="line">        if (buckets[index]) &#123;</div><div class="line">            //  非空桶，插入排序</div><div class="line">            let k = buckets[index].length - 1;</div><div class="line">            while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; arr[j]) &#123;</div><div class="line">                buckets[index][k + 1] = buckets[index][k];</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">            buckets[index][k + 1] = arr[j];</div><div class="line">        &#125; else &#123;</div><div class="line">            //空桶，初始化</div><div class="line">            buckets[index] = [];</div><div class="line">            buckets[index].push(arr[j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    while (n &lt; num) &#123;</div><div class="line">        result = result.concat(buckets[n]);</div><div class="line">        n++;</div><div class="line">    &#125;</div><div class="line">    console.timeEnd(&quot;桶排序耗时:&quot;); // 0.06ms</div><div class="line">    return result;</div><div class="line">&#125;;</div><div class="line">let arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</div><div class="line">console.log(bucketSort(arr, 4)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</div><div class="line"></div><div class="line">let arr1 = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</div><div class="line">console.time(&quot;快速排序耗时:&quot;);</div><div class="line">quickSort(arr1); // 用上面所实现的快速排序方法</div><div class="line">console.timeEnd(&quot;快速排序耗时:&quot;);</div></pre></td></tr></table></figure><p>可以看出桶排序比快速排序快了不少。</p><p>参考：<a href="http://www.jb51.net/article/88072.htm" target="_blank" rel="external">深入解析桶排序及Node.js上JavaScript代码的实现</a> </p><p>算法分析：</p><blockquote><p>（1）如果使用基于比较的排序，快速排序，平均时间复杂度为O(nlogn) = O(9000000*log9000000)=144114616=1.44亿次比较。</p><p>（2）如果使用基于计数的排序，桶排序，平均的时候复杂度，可以控制在线性复杂度，当创建700桶时从200分到900分各一个桶，O(N)=O(9000000)，就相当于扫描一次900W条数据。</p><p>然后我对桶排序代价分析直接做一下通俗的总结吧。如果我们把一个数组分成N桶，N桶里面有M个元素，那么M个元素还是要用到比较排序，为了提高速度我们应该尽量避免使用“比较”排序，极限情况下每个桶只能得到一个数据，也就是函数中第二个参数为1，这时桶排序效率能够达到O(n)。</p></blockquote><p>当然，做到这一点很不容易，数据量巨大的情况下，函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。</p><hr><h1 id="9、基数排序（分布式排序）—-O-d-n-r"><a href="#9、基数排序（分布式排序）—-O-d-n-r" class="headerlink" title="9、基数排序（分布式排序）— O(d*(n+r))"></a>9、基数排序（分布式排序）— O(d*(n+r))</h1><p>参考：<a href="http://blog.csdn.net/lemon_tree12138/article/details/51695211" target="_blank" rel="external">排序算法系列 - 基数排序</a></p><p>该参考下的基数排序过程图很形象的说明了排序的原理。</p><p>tip：该函数只适合用于都为整数的无序数组，还要求得最大位数（最大的整数的位数maxValue.toString().length）。</p><p>如果要考虑浮点数，我认为先把元素都映射为整数，再用排序，再映射回来即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">let counter = [];</div><div class="line">let radixSort = (arr, maxDigit) =&gt; &#123; // maxDigit为最大位数</div><div class="line">    let mod = 10;</div><div class="line">    let dev = 1;</div><div class="line">    for (let i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;</div><div class="line">        for(let j = 0; j &lt; arr.length; j++) &#123;</div><div class="line">            let bucket = parseInt((arr[j] % mod) / dev);</div><div class="line">            if(counter[bucket]==null) &#123;</div><div class="line">                counter[bucket] = [];</div><div class="line">            &#125;</div><div class="line">            counter[bucket].push(arr[j]);</div><div class="line">        &#125;</div><div class="line">        let pos = 0;</div><div class="line">        for(let j = 0; j &lt; counter.length; j++) &#123;</div><div class="line">            let value = null;</div><div class="line">            if(counter[j]!=null) &#123;</div><div class="line">                while ((value = counter[j].shift()) != null) &#123;</div><div class="line">                      arr[pos++] = value;</div><div class="line">                &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;</div><div class="line">let arr2 = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</div><div class="line">quickSort(arr2, 2); // [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</div></pre></td></tr></table></figure><hr><h1 id="10、希尔排序"><a href="#10、希尔排序" class="headerlink" title="10、希尔排序"></a>10、希尔排序</h1><p>希尔排序关键在于增量的设置,根据增量分割数组并逐步进行直接插入排序,增量逐趟减少,并最后使得整个数组基本有序,再对整体进行直接插入排序.</p><p>基本的思路就是根据增量分割数组,如var arr = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</p><p>我们增量为5,则分割为</p><blockquote><p>[3,15,46]</p><p> [44,36,4]</p><p> [38,26,19]</p><p> [5,27,50]</p><p> [47,2,48]</p></blockquote><p> 并对每一组进行直接插入排序<br> 再把增量变为2(减半),再进行分割,直到增量为1,再对全体进行一次直接插入排序就可以了.</p><p> 参考：<a href="https://segmentfault.com/a/1190000006950201" target="_blank" rel="external">基本算法学习(一)之希尔排序(JS) - 渣途 - SegmentFault</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let shellSort = arr =&gt; &#123;</div><div class="line">    var len = arr.length;</div><div class="line">    gap = Math.floor(len / 2);</div><div class="line">    while (gap !== 0) &#123;</div><div class="line">        for (var i = gap; i &lt; len; i++) &#123;</div><div class="line">            var temp = arr[i];</div><div class="line">            var j;</div><div class="line">            for (j = i - gap; j &gt;= 0 &amp;&amp; temp &lt; arr[j]; j -= gap) &#123;</div><div class="line">                arr[j + gap] = arr[j];</div><div class="line">            &#125;</div><div class="line">            arr[j + gap] = temp;</div><div class="line">        &#125;</div><div class="line">        gap = Math.floor(gap / 2);</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;;</div><div class="line">let arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];</div><div class="line">console.log(shellSort(arr)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</div></pre></td></tr></table></figure><hr><h1 id="结束，以上为JavaScript实现十大经典排序方法。"><a href="#结束，以上为JavaScript实现十大经典排序方法。" class="headerlink" title="结束，以上为JavaScript实现十大经典排序方法。"></a>结束，以上为JavaScript实现十大经典排序方法。</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript-—-基本算法学习&quot;&gt;&lt;a href=&quot;#JavaScript-—-基本算法学习&quot; class=&quot;headerlink&quot; title=&quot;JavaScript — 基本算法学习&quot;&gt;&lt;/a&gt;JavaScript — 基本算法学习&lt;/h1&gt;&lt;bloc
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》—— 高级技巧</title>
    <link href="http://yoursite.com/2017/09/30/JavaScript%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2017/09/30/JavaScript高级技巧/</id>
    <published>2017-09-30T05:30:38.537Z</published>
    <updated>2017-09-30T05:57:13.098Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h1><p>博客开了几个月了也没写什么，想着还是随手写一点吧，也有助于自己的加深理解。最近又在看《JavaScript高级程序设计》，刚好看到第22章的高级技巧，就随手码下来吧。</p><p>本文内容由《JavaScript高级程序设计》书上的P596 - P625 和 本人对这些技巧的理解提供。</p><p>适合人群：如果你刚好在看这本书，或者想特高JS代码的性能优化，减少代码耦合，都可以看本文章。当然，你还需要有一定的JS语法基础。那么，开始吧：</p></blockquote><hr><h1 id="一、高级函数"><a href="#一、高级函数" class="headerlink" title="一、高级函数"></a>一、高级函数</h1><h2 id="1、安全的类型检测"><a href="#1、安全的类型检测" class="headerlink" title="1、安全的类型检测"></a>1、安全的类型检测</h2><p>JavaScript内置的类型检测机制并非完全可靠。比如Safari(直至第4版)在对正则表达式应用typeof操作符时会返回function，instanceof操作符在存在多个全局作用域(像一个页面包含多个frame)的情况下，也是问题多多，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var isArray = arr instanceof Array;</div></pre></td></tr></table></figure><p>如果arr是在另一个frame中定义的数组。那么这里就会返回false。在检测某个对象到底是原生对象还是开发人员自定义的对象的时候。也会有问题。上述问题解决方法都一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(Object.prototype.toString.call(arr));  // &quot;[Object Array]&quot;</div></pre></td></tr></table></figure><p>由于原生数组的构造函数名与全局作用域无关，因此使用toString就能保证返回一致的值，利用这点可以创建如下函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function isArray(value) &#123;</div><div class="line">return Object.prototype.toString.call(value) == &quot;[Object Array]&quot;;</div><div class="line">&#125;</div><div class="line">// 或者</div><div class="line">function isFunction(value) &#123;</div><div class="line">return Object.prototype.toString.call(value) == &quot;[Object Function]&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function isRegExp(value) &#123;</div><div class="line">return Object.prototype.toString.call(value) == &quot;[Object RegExp]&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function isNativeJSON(value) &#123;</div><div class="line">return Object.prototype.toString.call(value) == &quot;[Object JSON]&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>在开发中能够区分原生与非原生对象非常重要。只有这样才能确切知道某个对象到底有哪些功能。</p></blockquote><h2 id="2、作用域安全的构造函数"><a href="#2、作用域安全的构造函数" class="headerlink" title="2、作用域安全的构造函数"></a>2、作用域安全的构造函数</h2><p>直接来看看作用域不安全的构造函数吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">this.name = name;</div><div class="line">&#125;</div><div class="line">var person = Person(&apos;Tom&apos;);</div><div class="line">console.log(window.name);  // &quot;Tom&quot;</div></pre></td></tr></table></figure><p>上面问题出在当没有使用new操作符来调用该构造函数的情况上。由于该this对象是在运行时绑定的，所以直接调用Person()，this会映射到全局对象window上，导致错误对象属性的意外增加。</p><p>解决的思路是 作用域安全的构造函数在进行任何更改前，首先确认this对象是正确类型的实例。如果不是那么会创建新的实例并返回。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">if(this instanceof Person) &#123;</div><div class="line">this.name = name;</div><div class="line">&#125; else &#123;</div><div class="line">return new Person(name);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">var person1 = Person(&quot;Tom&quot;);</div><div class="line">console.log(window.name);// &quot;&quot;</div><div class="line">console.log(person1.name);// &quot;Tom&quot;</div></pre></td></tr></table></figure><p>这段代码中添加了一个检查并确保this对象是Person实例。最后的结果是，调用Person构造函数无论是否使用new操作符，都会返回一个Person的新实例。</p><p>这样处理也有坏处，就是构造函数窃取模式的继承该实例是无效的。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function People(sex) &#123;</div><div class="line">Person.call(this,&apos;Tom&apos;);// 构造函数窃取模式  —— 继承Polygon的name属性  不过在这种作用域安全情况下不可用</div><div class="line">this.sex = sex;</div><div class="line">&#125;</div><div class="line">var people1 = new People(&apos;boy&apos;);</div><div class="line">console.log(people1.name);  //undefined</div></pre></td></tr></table></figure><p>在这里由于Person构造函数作用域是安全的，this对象并非Person实例，所以会创建并返回一个新的Person对象，所以People构造函数中的this对象并没有得到增长，也就不会有name属性。</p><p>解决上面的问题，使用原型链继承即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function People(sex) &#123;</div><div class="line">this.sex = sex;</div><div class="line">&#125;</div><div class="line">People.prototype = new Person(&apos;Tom&apos;);</div><div class="line">var people1 = new People(&apos;boy&apos;);</div><div class="line">console.log(people1.name); //&quot;Tom&quot;</div></pre></td></tr></table></figure></p><blockquote><p>多个程序猿在同一个页面上写JavaScript代码的环境中，作用域安全构造函数就很有用了。推荐作用域安全的构造函数作为最佳实践。</p></blockquote><h2 id="3、惰性载入函数"><a href="#3、惰性载入函数" class="headerlink" title="3、惰性载入函数"></a>3、惰性载入函数</h2><p>因为浏览器之间行为的差异，多数JavaScript代码包含了大量的if语句，将执行引导到正确的代码中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function createXHR() &#123;</div><div class="line">if(typeof XMLHttpRequest != &quot;undefined&quot;) &#123;</div><div class="line">return new XMLHttpRequest();</div><div class="line">&#125; else if(typeof ActiveXObject != &quot;undefined&quot;) &#123;</div><div class="line">if(typeof arguments.callee.activeXString != &quot;string&quot;) &#123;</div><div class="line">var version = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;, &quot;MSXML2.XMLHttp&quot;],</div><div class="line">i,</div><div class="line">len;</div><div class="line">for(i = 0, len = version.length; i &lt; len; i++) &#123;</div><div class="line">try &#123;</div><div class="line">new ActiveXObject(version[i]);</div><div class="line">arguments.callee.activeXString = version[i];</div><div class="line">break;</div><div class="line">&#125; catch(ex) &#123;</div><div class="line">//  跳过</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return new ActiveXObject(arguments.callee.activeXString);</div><div class="line">&#125; else &#123;</div><div class="line">throw new Error(&quot;No XHR object available&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>每次调用createXHR()，它都要对浏览器所支持的能力进行仔细检查。每次调用该函数都是这样，即使调用时分支的结果都不变，如果浏览器内置XHR，那么它就一直支持了，那么这种测试就变得没必要。即使只有一个if语句的代码，也肯定要比没有if语句的慢。</p><p>解决方案就是称为惰性载入的技巧。书上写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function createXHR() &#123; //函数声明写法</div><div class="line">if(typeof XMLHttpRequest != &quot;undefined&quot;) &#123;</div><div class="line">createXHR = function() &#123;</div><div class="line">return new XMLHttpRequest();</div><div class="line">&#125;</div><div class="line">&#125; else if(typeof ActiveXObject != &quot;undefined&quot;) &#123;</div><div class="line">createXHR = function() &#123;</div><div class="line">if(typeof arguments.callee.activeXString != &quot;string&quot;) &#123;</div><div class="line">var version = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;, &quot;MSXML2.XMLHttp&quot;],</div><div class="line">i,</div><div class="line">len;</div><div class="line">for(i = 0, len = version.length; i &lt; len; i++) &#123;</div><div class="line">try &#123;</div><div class="line">new ActiveXObject(version[i]);</div><div class="line">arguments.callee.activeXString = version[i];</div><div class="line">break;</div><div class="line">&#125; catch(ex) &#123;</div><div class="line">//  跳过</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return new ActiveXObject(arguments.callee.activeXString);</div><div class="line">&#125;</div><div class="line">&#125; else &#123;</div><div class="line">createXHR = function() &#123;</div><div class="line">throw new Error(&quot;No XHR object available&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是是把函数表达式写在函数内部，我认为把函数表达式写在外部即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">createXHR = function() &#123; //  这是函数表达式写法</div><div class="line">if(typeof XMLHttpRequest != &quot;undefined&quot;) &#123;</div><div class="line">return new XMLHttpRequest();</div><div class="line">&#125; else if(typeof ActiveXObject != &quot;undefined&quot;) &#123;</div><div class="line">if(typeof arguments.callee.activeXString != &quot;string&quot;) &#123;</div><div class="line">var version = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;, &quot;MSXML2.XMLHttp&quot;],</div><div class="line">i,</div><div class="line">len;</div><div class="line">for(i = 0, len = version.length; i &lt; len; i++) &#123;</div><div class="line">try &#123;</div><div class="line">new ActiveXObject(version[i]);</div><div class="line">arguments.callee.activeXString = version[i];</div><div class="line">break;</div><div class="line">&#125; catch(ex) &#123;</div><div class="line">//  跳过</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return new ActiveXObject(arguments.callee.activeXString);</div><div class="line">&#125; else &#123;</div><div class="line">throw new Error(&quot;No XHR object available&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这两种写法都可以在执行createXHR方法的时候执行第一遍后，后面执行就不会再进行if判断。如果有需要函数第一次执行也不产生if判断，那么就在函数声明的时候执行。</p><blockquote><p>惰性载入函数的优点是只在执行分支代码的时候牺牲一点儿性能。至于那种方式更合适，就要看你的具体需求而定了。</p></blockquote><h2 id="4、函数绑定"><a href="#4、函数绑定" class="headerlink" title="4、函数绑定"></a>4、函数绑定</h2><p>函数绑定要创建一个函数，可以在特定的this环境中以指定参数调用另一个函数。该技巧常常和回调函数与事件处理程序一起使用，以便在将函数作为变量传递的同时保留代码执行环境，看下面栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">name: &quot;Tom&quot;,</div><div class="line">talk: function() &#123;</div><div class="line">con(&apos;I am &apos; + this.name);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">var btn = document.getElementById(&quot;bindBtn&quot;);</div><div class="line">btn.addEventListener(&apos;click&apos;, person.talk);</div></pre></td></tr></table></figure><p>上面代码问题看似点击按钮的时候会打印 “I am Tom”, 实际显示的是 “I am “。</p><p>这个问题在于没有保存person.talk()的环境，所以this对象最后是指向了Dom按钮(在IE8中，this指向window)。</p><p>解决这个问题，可以使用一个闭包来解决，看下面代码（以下代码只显示修改的部分）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">btn.addEventListener(&apos;click&apos;, function() &#123;</div><div class="line">person.talk();</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这个解决方案在click事件处理程序内使用了一个闭包直接调用person.talk(); 这只是这段代码的解决方案，创建多个闭包可能会令代码变得难于理解和调试。</p><p>因此，很多JS库实现了一个可以将函数绑定到指定环境的函数。这个函数一般都叫bind()。</p><p>实现一个比较基本的bind()函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function bind(fn, context) &#123;</div><div class="line">return function() &#123;</div><div class="line">return fn.apply(context, arguments); //  这里使用的arguments对象是内部函数的，并非bind()的。</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>bind()中创建了一个必报，闭包使用apply()调用传入的函数，并给apply()传递context对象和参数。</p><p>结合上面的代码结合使用自定义bind(方法):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">btn.addEventListener(&apos;click&apos;, bind(person.talk, person));</div></pre></td></tr></table></figure><p>其实在ES5已经为所有函数定义了一个原生bind()方法，使用方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">btn.addEventListener(&apos;click&apos;, person.talk.bind(person));</div></pre></td></tr></table></figure><p>只要是将某个函数指针(环境)以值的形式进行传递，同时该函数必须在特定环境中执行，被绑定函数的效用就突显出来了。</p><blockquote><p>主要用于事件处理程序以及setTimeout()和setInterval()。</p><p>然而，被绑定函数与普通函数相比有更多的开销，需要更多的内存，同时也因为多重函数调用稍微慢一点，所以最好只在必要时使用。</p></blockquote><h2 id="5、函数柯里化"><a href="#5、函数柯里化" class="headerlink" title="5、函数柯里化"></a>5、函数柯里化</h2><p>与函数绑定紧密相关的主题是函数柯里化，它用于创建已经设置好了一个或多个参数的函数。</p><p>函数柯里化的基本方法和函数绑定是一样的：使用一个闭包返回一个函数。两者区别在于，当函数被调用时，返回的函数还需要设置一些传入的参数，看栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function curry(fn) &#123;</div><div class="line">var args = Array.prototype.slice.call(arguments, 1);//  这里截取函数之后的参数</div><div class="line">return function() &#123;</div><div class="line">var varArgs = Array.prototype.slice.call(arguments);//  这里接受curryAdd的参数</div><div class="line">var finalArgs = args.concat(varArgs);</div><div class="line">return fn.apply(null, finalArgs);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">function add(num1, num2) &#123;</div><div class="line">return num1 + num2;</div><div class="line">&#125;</div><div class="line">var curryAdd = curry(add, 5);</div><div class="line">console.log(curryAdd(1));//  6</div></pre></td></tr></table></figure><p>这里创建第一个参数绑定为5的add()柯里化版本。你也可以像下面这样给出所有的函数参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var curryAdd = curry(add, 5, 1);</div><div class="line">console.log(curryAdd(1));//  6因为add()没有接受第三个参数，所以还是6</div></pre></td></tr></table></figure><p>函数柯里化还常常作为函数绑定的一部分包含在其中，构造出更为复杂的bind()函数。以ES5的bind()方法举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function bind(fn, context) &#123;</div><div class="line">var args = Array.prototype.slice.call(arguments, 2);//这里需要改为2，获取函数和环境后面的参数</div><div class="line">return function() &#123;</div><div class="line">var varArgs = Array.prototype.slice.call(arguments);//这里从第三个参数开始接受</div><div class="line">var finalArgs = args.concat(varArgs);</div><div class="line">return fn.apply(context, finalArgs);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">var person = &#123;</div><div class="line">name: &quot;Tom&quot;,</div><div class="line">talk: function(message1, message2) &#123;</div><div class="line">console.log(&apos;I am &apos; + this.name + &apos;,&apos; + message1 + &apos;,&apos; + message2 );</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">var talking = person.talk.bind(person, &quot; I am talking &quot;) // 这里创建一个第一个参数绑定为“ I am talking ”的函数</div><div class="line">var btn = document.getElementById(&quot;bindBtn&quot;);</div><div class="line">btn.addEventListener(&apos;click&apos;, function() &#123;</div><div class="line">talking(&apos;I am running&apos;);//这里就任意添加talking后面的参数</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这样每次单机按钮就会弹出相应参数的字符串。</p><blockquote><p>PS:这里有个坑呀。btn.addEventListener(‘click’, talking(‘I am running’));  这样点击按钮是不会有反应的。</p><p>总的来说，柯里化的作用可以使代码模块化，减少耦合增强其可维护性。柯里化函数和绑定函数提供了强大的动态函数创建功能，两者不应滥用，只在必要的时候用。</p></blockquote><h1 id="二、防篡改对象"><a href="#二、防篡改对象" class="headerlink" title="二、防篡改对象"></a>二、防篡改对象</h1><p>在编写JavaScript库中，因为JS共享的特性，开发人员很可能会意外地修改别人代码。</p><p>ES5新增了几个方法，通过它们可以指定对象的行为。</p><h2 id="1、不可拓展对象-Object-preventExtensions"><a href="#1、不可拓展对象-Object-preventExtensions" class="headerlink" title="1、不可拓展对象 Object.preventExtensions()"></a>1、不可拓展对象 Object.preventExtensions()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person1 = &#123; name: &quot;Tom&quot; &#125;;</div><div class="line">person1.age = 20;</div><div class="line">Object.preventExtensions(person1);</div><div class="line">person1.age = 30;</div><div class="line">person1.sex = &quot;boy&quot;</div><div class="line">console.log(person1.age, person1.sex);  // 30, undefined</div><div class="line">delete person1.age;</div><div class="line">console.log(person1.age) // undefined</div></pre></td></tr></table></figure><p>可以看出调用 Object.preventExtensions() 方法后，就不能给person1对象添加新的属性和方法。但是仍然可以修改和删除已有的成员。</p><h2 id="2、密封的对象-Oject-seal"><a href="#2、密封的对象-Oject-seal" class="headerlink" title="2、密封的对象 Oject.seal()"></a>2、密封的对象 Oject.seal()</h2><p>密封对象不可拓展，而且已有的成员[[configurable]]特性将被设置为false。具体功能还是直接看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var person1 = &#123; name: &quot;Tom&quot; &#125;;</div><div class="line">person1.age = 20;</div><div class="line">Object.seal(person1);</div><div class="line">person1.sex = &quot;boy&quot;;</div><div class="line">console.log(person1.boy);  // undefined</div><div class="line">delete person1.name;</div><div class="line">console.log(person1.name);  // &quot;Tom&quot;</div><div class="line">person1.age = 23;</div><div class="line">console.log(person1.age);  // 23</div></pre></td></tr></table></figure><p>除了不能增删外，只有修改操作是可以进行的。</p><h2 id="3、冻结的对象-Object-freeze"><a href="#3、冻结的对象-Object-freeze" class="headerlink" title="3、冻结的对象 Object.freeze()"></a>3、冻结的对象 Object.freeze()</h2><p>最严格的防篡改级别是冻结对象。冻结对象既不可拓展，又是密封的。而且每个对象数据属性[[Writable]]特性会被设置为false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var person1 = &#123;</div><div class="line">name: &quot;Tom&quot;</div><div class="line">&#125;;</div><div class="line">person1.age = 20;</div><div class="line">Object.freeze(person1);</div><div class="line">person1.sex = &quot;boy&quot;;</div><div class="line">console.log(person1.boy); // undefined</div><div class="line">delete person1.name;</div><div class="line">console.log(person1.name); // &quot;Tom&quot;</div><div class="line">person1.age = 23;</div><div class="line">console.log(person1.age); // 20</div></pre></td></tr></table></figure><blockquote><p>可以看出冻结的对象什么也无法修改删除，这样冻结（或密封）主要的库就能够防止这些问题的发生。</p></blockquote><h2 id="三、高级定时器"><a href="#三、高级定时器" class="headerlink" title="三、高级定时器"></a>三、高级定时器</h2><h2 id="1、setTimeout"><a href="#1、setTimeout" class="headerlink" title="1、setTimeout()"></a>1、setTimeout()</h2><p>首先，JavaScript是运行在单线程环境中，而定时器只是表示指定间隔多少时间把代码添加到队列内。</p><p>JS队列执行代码方式还是用代码体验一下吧:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var btn = document.getElementById(&quot;bindBtn&quot;);</div><div class="line">btn.onclick = function() &#123;</div><div class="line">timer1 = setTimeout(function() &#123;</div><div class="line">console.log(&apos;执行第一个定时器&apos;); // 第一个执行</div><div class="line">&#125;, 1000);</div><div class="line">timer2 = setTimeout(function() &#123;</div><div class="line">console.log(&apos;执行第二个定时器&apos;); // 第二个执行</div><div class="line">&#125;, 2000);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>点击按钮后可以发现timer1执行，再过一秒后timer2也执行，一切正常。因为在事件处理程序里面没有其他代码要添加到队列里，效果比较不明显。</p><p>那么我们添加点其他代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var btn = document.getElementById(&quot;bindBtn&quot;);</div><div class="line">btn.onclick = function() &#123;</div><div class="line">console.time(&apos;time:&apos;);</div><div class="line">for (var i=0,a=0;i&lt;99999999;i++) &#123;</div><div class="line">a = Math.floor(Math.random()*10000);</div><div class="line">&#125;;</div><div class="line">a=null;</div><div class="line">console.timeEnd(&apos;time:&apos;);</div><div class="line"></div><div class="line">timer1 = setTimeout(function() &#123;</div><div class="line">console.log(&apos;执行第一个定时器&apos;); // 第一个执行</div><div class="line">&#125;, 1000);</div><div class="line">timer2 = setTimeout(function() &#123;</div><div class="line">console.log(&apos;执行第二个定时器&apos;); // 第二个执行</div><div class="line">&#125;, 2000);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>现在明显感受到定时器输出的晚了几秒。<br>解析一下:点击后，队列中执行for循环，等待for循环结束后，再把timer1和timer2的代码放入队列相隔设置好的时间后执行。这样一来，就好理解多了。</p><h2 id="2、setInterval"><a href="#2、setInterval" class="headerlink" title="2、setInterval()"></a>2、setInterval()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var btn = document.getElementById(&quot;bindBtn&quot;);</div><div class="line">btn.onclick = function() &#123;</div><div class="line">var b = 0;</div><div class="line">timer1 = setInterval(function() &#123;</div><div class="line">console.time(&apos;time:&apos;);</div><div class="line">for(var i = 0, a = 0; i &lt; 99999999; i++) &#123;</div><div class="line">a = Math.floor(Math.random() * 10000);</div><div class="line">&#125;;</div><div class="line">a = null;</div><div class="line">console.log(&apos;第&apos; + ++b + &apos;次定时器执行&apos;);</div><div class="line">console.timeEnd(&apos;time:&apos;); // 基本上每次都间隔2.5秒</div><div class="line">&#125;, 2000);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这个例子中第一个定时器是在2000ms处添加到队列中，但是代码块需要2.5s左右时间执行，所以第一个打印记录时间是4.5s。而在4s的时候本来是应该执行第二个定时器的代码，这时候就会没有延迟的立即执行第二个定时器代码在6s的时候显示”第2次定时器执行”。</p><p>书上有说会缺失间隔的代码，不知道是执行的代码时间不够长还是怎样，执行起来并没有。了解详情的还望指教一下。</p><h2 id="3、Yielding-Processes"><a href="#3、Yielding-Processes" class="headerlink" title="3、Yielding Processes"></a>3、Yielding Processes</h2><p>JavaScript在浏览器中有一个限制是长时间运行脚本的制约，会弹出一个浏览器错误的对话框，告诉用户某个脚本会用过长的时间执行，询问是允许其继续执行还是停止它。</p><p>脚本长时间运行问题通常是两个原因之一造成的：过深的嵌套、过长的函数调用或者是进行大量处理的循环。</p><p>其实就是当你发现某个循环占用了大量时间，如果这个数据的处理不会造成其他运行的阻塞。</p><p>那么你就可以用定时器分割这个循环。这是一种叫“数组分块”的技术，小块小块地处理数组。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">for (var i = 0,len = data.length; i &lt; len; i++) &#123;</div><div class="line">process(data[i]);</div><div class="line">&#125;</div><div class="line">这个事件处理执行产生有可能会造成页面卡顿，这非常影响用户体验，使用数组分块来优化：</div><div class="line">setTimeout(function()&#123;</div><div class="line">var item = array.shift();</div><div class="line">process(item); //  执行某操作</div><div class="line"></div><div class="line">if(array.length &gt; 0) &#123;</div><div class="line">setTimeout(arguments.callee, 100);  // 调用同一个匿名函数</div><div class="line">&#125;</div><div class="line">&#125;, 100);</div></pre></td></tr></table></figure><blockquote><p>数组分块的重要性在于它可以将多个项目的处理在执行队列上分开。</p><p>一旦某个函数需要花50ms以上的时间完成，那么最好看看能否将任务分割为一系列可以使用定时器的小任务。</p></blockquote><h2 id="4、函数节流"><a href="#4、函数节流" class="headerlink" title="4、函数节流"></a>4、函数节流</h2><p>函数节流的基本思想是指，某些代码不可以在没有间断的情况连续重复执行。第一次调用函数创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清楚前一次定时器并设置另一个。</p><p>以下是该模式的基本形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">runTime: null,</div><div class="line"></div><div class="line">//实际进行处理的方法</div><div class="line">run: function() &#123;</div><div class="line">//实际执行的代码</div><div class="line">&#125;,</div><div class="line"></div><div class="line">//初始处理调用的方法</div><div class="line">readyRun: function() &#123;</div><div class="line">clearTimeout(this.runTime);</div><div class="line">var that = this;</div><div class="line">this.timeoutId = setTimeout(function() &#123;</div><div class="line">that.run();</div><div class="line">&#125;, 1000);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码中，拟人化的创建了一个人，有两个方法：run()和readyRun()。前者是实际进行的动作，后者是初始化动作所必须调用的。</p><p>当调用readyRun()，第一步是清楚存好的runTime，来阻止之前的调用被执行。然后创建一个新的定时器调用run()。由于setTimeout中用到的函数环境总是window，所以有必要保存this的引用方便使用。</p><p>这样的好处是即使1000ms内调用了readRun(),run()也只会调用一次。（毕竟人不可能一秒跑那么多步的好嘛！）</p><p>节流在resize，scorll事件中是最常用的。如果你基于该事件来改变页面布局的话，最好控制处理的频率，以确保浏览器不会再极短的时间内进行过多的计算。</p><p>这里先设计一个函数封装一下这个方法，方便以后常用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function throttle(fn, delay, context) &#123;</div><div class="line">clearTimeout(fn.throTime); //默认你给需要执行的函数里都有throTime属性</div><div class="line">fn.throTime = setTimeout(function() &#123;</div><div class="line">fn.call(context); //函数在指定环境执行</div><div class="line">&#125;, delay);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>写一个滑动滚轮改变盒子大小的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function changeBg() &#123;</div><div class="line">var div = document.getElementById(&quot;dragTarget&quot;);</div><div class="line">div.style.width = div.offsetWidth + 10 + &apos;px&apos;;</div><div class="line">div.style.height = div.offsetHeight + 10 + &apos;px&apos;;</div><div class="line">&#125;;</div><div class="line">下面使用优化一下onscroll的事件处理程序</div><div class="line">window.onscroll = function() &#123;</div><div class="line">throttle(changeBg, 100);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里多数情况下用户使感觉不到变化的，可是这大大节省了浏览器的计算。<br>只要代码是周期性执行的，都应该使用节流，并且适当控制速率。</p><h1 id="四、自定义事件"><a href="#四、自定义事件" class="headerlink" title="四、自定义事件"></a>四、自定义事件</h1><p>如果每个对象都有对其他所有对象的引用，那么整个代码就会紧密耦合，同时维护也变得很困难，因为对某个对象的修改也会影响到其他对象。使用自定义事件有助于解耦相关对象，保持功能的隔绝。</p><p>实际上，在很多情况下，触发事件的代码和舰艇事件的代码是完全分离的。</p><p>自定义事件背后的概念是创建一个管理事件的对象，让其他对象监听那些事件。实现此功能的基本模式可以如下定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">function EventTarget() &#123;</div><div class="line">this.handlers = &#123;&#125;; //  存放事件名的对象</div><div class="line">&#125;</div><div class="line">EventTarget.prototype = &#123;</div><div class="line">con: function() &#123; //输出当前存放的所有事件名</div><div class="line">console.log(JSON.stringify(this.handlers));</div><div class="line">&#125;,</div><div class="line">addHandler: function(type, handler) &#123; // 添加事件</div><div class="line">if(typeof this.handlers[type] == &quot;undefined&quot;) &#123;</div><div class="line">this.handlers[type] = []; // 如果没有就创建一个新的事件</div><div class="line">&#125;</div><div class="line">this.handlers[type].push(handler); //  把事件处理程序添加到事件的数组里面</div><div class="line">&#125;,</div><div class="line">fire: function(event) &#123; // 触发事件</div><div class="line">if(!event.target) &#123;</div><div class="line">event.target = this;</div><div class="line">&#125;</div><div class="line">if(this.handlers[event.type] instanceof Array) &#123;</div><div class="line">var handlers = this.handlers[event.type];</div><div class="line">for(var i = 0, len = handlers.length; i &lt; len; i++) &#123;</div><div class="line">handlers[i](event);</div><div class="line">&#125;</div><div class="line">&#125; else &#123;</div><div class="line">console.log(&apos;没有注册过该事件&apos;);</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line">removeHandler: function(type, handler) &#123; // 移除指定事件处理程序</div><div class="line">if(this.handlers[event.type] instanceof Array) &#123;</div><div class="line">var handlers = this.handlers[type];</div><div class="line">for(var i = 0, len = handlers.length; i &lt; len; i++) &#123;</div><div class="line">if(handlers[i] === handler) &#123; // 找到事件处理程序的位置，跳出循环</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125; else &#123;</div><div class="line">console.log(&apos;没有注册过该事件&apos;);</div><div class="line">&#125;</div><div class="line">handlers.splice(i, 1); // 删除事件处理程序</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后，使用EventTarget类型的自定义事件可以如下使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function handleMessage(event) &#123;</div><div class="line">console.log(&quot;Message received&quot; + event.message);</div><div class="line">&#125;</div><div class="line">var dom = new EventTarget();</div><div class="line">dom.addHandler(&quot;dianJi&quot;,handleMessage);</div><div class="line">dom.fire(&#123;type:&apos;dianJi&apos;, message: &apos;I am Click&apos;&#125;);// &quot;Message receivedI am Click&quot;</div><div class="line">dom.removeHandler(&quot;dianJi&quot;,handleMessage);</div><div class="line">dom.fire(&#123;type:&apos;dianJi&apos;, message: &apos;I am Click&apos;&#125;);// Error: Cannot read property &apos;type&apos; of undefined&quot;</div><div class="line">其他对象可以继承这种自定义对象</div><div class="line">function Person(name, age) &#123;</div><div class="line">this.name = name;</div><div class="line">this.age = age;</div><div class="line">&#125;</div><div class="line">Person.prototype = new EventTarget();</div><div class="line">var person = new Person(&apos;Tom&apos;, 20);</div><div class="line">function handleMessage(event) &#123;</div><div class="line">console.log(&quot;I talk &quot; + event.message);</div><div class="line">&#125;</div><div class="line">person.addHandler(&quot;say&quot;, handleMessage);</div><div class="line">person.fire(&#123;type:&apos;say&apos;, message:&apos;I am Person&apos;&#125;); // &quot;I talk I am Person&quot;</div></pre></td></tr></table></figure><h1 id="五、拖放"><a href="#五、拖放" class="headerlink" title="五、拖放"></a>五、拖放</h1><p>拖放是一种非常流行的用户界面模式。他的概念很简单：点击某个对象，并按住鼠标按钮不放，将鼠标移动到另一个区域，然后释放鼠标按钮将对象“放”在这里。</p><p>简单的拖放界面可用一下代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">var DragDrop = function() &#123;</div><div class="line">var dragging = null,// 拖放对象</div><div class="line">diffX = 0,</div><div class="line">diffY = 0;</div><div class="line">function handleEvent(event) &#123;</div><div class="line">// 获取事件和目标</div><div class="line">event = event || window.event;</div><div class="line">var target = event.target || window.event.target;</div><div class="line">switch(event.type) &#123;</div><div class="line">case &quot;mousedown&quot;:</div><div class="line">console.log(target)</div><div class="line">if(target.className.indexOf(&quot;draggable&quot;) &gt; -1) &#123;</div><div class="line">dragging = target;</div><div class="line">diffX = event.clientX - target.offsetLeft;</div><div class="line">diffY = event.clientY - target.offsetTop;</div><div class="line">&#125;</div><div class="line">break;</div><div class="line">case &quot;mousemove&quot;:</div><div class="line">if(dragging !== null) &#123;</div><div class="line">dragging.style.left = event.clientX - diffX + &apos;px&apos;;</div><div class="line">dragging.style.top = event.clientY - diffY + &apos;px&apos;;</div><div class="line">&#125;</div><div class="line">break;</div><div class="line">case &quot;mouseup&quot;:</div><div class="line">dragging = null;</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">return &#123;</div><div class="line">enable: function() &#123;</div><div class="line">document.addEventListener(&apos;mousedown&apos;, handleEvent);</div><div class="line">document.addEventListener(&apos;mousemove&apos;, handleEvent);</div><div class="line">document.addEventListener(&apos;mouseup&apos;, handleEvent);</div><div class="line">&#125;,</div><div class="line">disable: function() &#123;</div><div class="line">document.removeEventListener(&apos;mousedown&apos;, handleEvent);</div><div class="line">document.removeEventListener(&apos;mousemove&apos;, handleEvent);</div><div class="line">document.removeEventListener(&apos;mouseup&apos;, handleEvent);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">DragDrop().enable();</div></pre></td></tr></table></figure></p><p>DragDrop对象封装了拖放的所有基本功能。拖放的时候回自动针对所有包含“draggable”类的元素启用。</p><blockquote><p>为了元素能被拖放，它必须是绝对定位的。</p></blockquote><p>结合前面的自定义事件完善该功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">var dragdrop = new EventTarget();</div><div class="line">var DragDrop = function() &#123;</div><div class="line">var dragging = null,</div><div class="line">diffX = 0,</div><div class="line">diffY = 0;</div><div class="line"></div><div class="line">function handleEvent(event) &#123;</div><div class="line">event = event || window.event;</div><div class="line">var target = event.target;</div><div class="line">switch(event.type) &#123;</div><div class="line">case &quot;mousedown&quot;:</div><div class="line">if(target.className.indexOf(&quot;draggable&quot;) &gt; -1) &#123;</div><div class="line">dragging = target;</div><div class="line">diffX = event.clientX - target.offsetLeft;</div><div class="line">diffY = event.clientY - target.offsetTop;</div><div class="line">//  这里触发自定义事件，比如：</div><div class="line">dragdrop.fire(&#123;</div><div class="line">type: &quot;dragStart&quot;,</div><div class="line">target: dragging</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">break;</div><div class="line">case &quot;mousemove&quot;:</div><div class="line">if(dragging !== null) &#123;</div><div class="line">dragging.style.left = event.clientX - diffX + &apos;px&apos;;</div><div class="line">dragging.style.top = event.clientY - diffY + &apos;px&apos;;</div><div class="line">//  这里触发自定义事件，比如：</div><div class="line">dragdrop.fire(&#123;</div><div class="line">type: &quot;dragging&quot;,</div><div class="line">target: dragging</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">break;</div><div class="line">case &quot;mouseup&quot;:</div><div class="line">//  这里触发自定义事件，比如：</div><div class="line">dragdrop.fire(&#123;</div><div class="line">type: &quot;dragend&quot;,</div><div class="line">target: dragging</div><div class="line">&#125;);</div><div class="line">dragging = null;</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">dragdrop.enable = function() &#123;</div><div class="line">document.addEventListener(&apos;mousedown&apos;, handleEvent);</div><div class="line">document.addEventListener(&apos;mousemove&apos;, handleEvent);</div><div class="line">document.addEventListener(&apos;mouseup&apos;, handleEvent);</div><div class="line">&#125;</div><div class="line">dragdrop.disable = function() &#123;</div><div class="line">document.removeEventListener(&apos;mousedown&apos;, handleEvent);</div><div class="line">document.removeEventListener(&apos;mousemove&apos;, handleEvent);</div><div class="line">document.removeEventListener(&apos;mouseup&apos;, handleEvent);</div><div class="line">&#125;</div><div class="line">return dragdrop;</div><div class="line">&#125;</div><div class="line">DragDrop().addHandler(&quot;dragStart&quot;, function(event) &#123;</div><div class="line">event.target.innerHTML = &quot;准备移动！&quot;;</div><div class="line">&#125;);</div><div class="line">DragDrop().addHandler(&quot;dragging&quot;, function(event) &#123;</div><div class="line">event.target.innerHTML = &quot;正在移动ing！&quot;;</div><div class="line">&#125;);</div><div class="line">DragDrop().addHandler(&quot;dragend&quot;, function(event) &#123;</div><div class="line">event.target.innerHTML = &quot;移动结束！&quot;;</div><div class="line">&#125;);</div><div class="line">DragDrop().enable();</div></pre></td></tr></table></figure><p>其实这里有个坑跟书上的不一样，就是new EventTarget()要在外一层new。</p><hr><blockquote><h1 id="以上就是《JavaScript高级程序设计》书上的高级技巧和本人对这些知识点的一些理解，所码的文章。"><a href="#以上就是《JavaScript高级程序设计》书上的高级技巧和本人对这些知识点的一些理解，所码的文章。" class="headerlink" title="以上就是《JavaScript高级程序设计》书上的高级技巧和本人对这些知识点的一些理解，所码的文章。"></a>以上就是《JavaScript高级程序设计》书上的高级技巧和本人对这些知识点的一些理解，所码的文章。</h1><p>本文经常更新知识点以及修正一些错误，因此转载请保留原出处，方便溯源，避免陈旧错误知识的误导，同时有更好的阅读体验。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h1 id=&quot;摘要：&quot;&gt;&lt;a href=&quot;#摘要：&quot; class=&quot;headerlink&quot; title=&quot;摘要：&quot;&gt;&lt;/a&gt;摘要：&lt;/h1&gt;&lt;p&gt;博客开了几个月了也没写什么，想着还是随手写一点吧，也有助于自己的加深理解。最近又在看《JavaScript
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>这是我的第一篇文章</title>
    <link href="http://yoursite.com/2017/07/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E7%AB%A0/"/>
    <id>http://yoursite.com/2017/07/25/我的第一个文章/</id>
    <published>2017-07-25T03:00:58.446Z</published>
    <updated>2017-09-30T05:33:57.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><ul><li>[x]  <strong>npm i hexo –save</strong></li><li>点击<a href="http://note.youdao.com/" target="_blank" rel="external">这里</a>访问我的博客</li><li><img src="http://note.youdao.com/favicon.ico" alt="ddd"></li><li>谢谢</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装hexo&quot;&gt;&lt;a href=&quot;#安装hexo&quot; class=&quot;headerlink&quot; title=&quot;安装hexo&quot;&gt;&lt;/a&gt;安装hexo&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;[x]  &lt;strong&gt;npm i hexo –save&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/07/24/hello-world/"/>
    <id>http://yoursite.com/2017/07/24/hello-world/</id>
    <published>2017-07-24T05:09:23.631Z</published>
    <updated>2017-09-30T05:35:07.453Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
